<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue路由动态配置]]></title>
    <url>%2F2020%2F02%2F10%2Fvue%E8%B7%AF%E7%94%B1%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在后台系统这类的项目中，用户角色和权限的区分是不可分割的一部分需求。常见的用户权限区分形式有两种，一是前端请求接口拿到后台配置的用户权限信息；另一种是直接由前端来定义每种用户角色的权限页面，然后在生成对应的路由。今天我们来了解前端配置路由权限的方式。 角色权限页面配置 在配置角色对应的路由页面时，可以参考项目所用的前端框架导航组件的参数，我们以elment ui的menu组件为例：可对审核方（Auditor）、供应商（Supplier）和需求方（Business）做如下配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 const appMenuitem = &#123; // 审核方下拉选项（路由）菜单 Auditor: [ &#123; // icon: "el-icon-view", // operationLog userConfiguration title: "基本配置", index: "1", subs: [ &#123; index: "dataOverview", title: "数据概览" &#125; ] &#125;, &#123; // icon: "el-icon-view", title: "需求审核", index: "2", subs: [ &#123; index: "demendManage", title: "需求管理" &#125; ] &#125; ], // 业务方下拉选项和路由 Business: [ &#123; title: "基本配置", index: "1", subs: [ &#123; index: "demandList", title: "需求列表" &#125; ] &#125; ], // 供应商 Supplier: [ &#123; title: "需求制作", index: "1", subs: [ &#123; index: "needList", title: "需求列表" &#125; ] &#125; ]&#125;; 这样配置后，所有用户角色的权限信息都在appMenuitem中，在项目的开发，我们可以按照配置的对象属性index（这里是可以由开发按自己的习惯约定）的值，如dataOverview、demendManage等来建立页面。如图： 生成侧边菜单逻辑（需配置好路由router才能运行）： 12345678910111213141516171819202122232425262728293031323334353637&lt;el-menu background-color=&quot;#fff&quot; text-color=&quot;#222222&quot; theme=&quot;dark&quot; :default-active=&quot;onRoute&quot; :collapse=&quot;false&quot; router&gt; &lt;template v-for=&quot;(item, index) in items&quot;&gt; &lt;!-- 有子选项 --&gt; &lt;template v-if=&quot;item.subs &amp;&amp; item.subs.length &gt; 0&quot;&gt; &lt;el-submenu :index=&quot;item.index&quot; :key=&quot;index&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i :class=&quot;item.icon&quot; &gt;&lt;/i&gt; &lt;span&gt;&#123;&#123; item.title &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item v-for=&quot;(subItem, index2) in item.subs&quot; :key=&quot;index2&quot; :index=&quot;subItem.index&quot; &gt; &lt;span&gt;&#123;&#123; subItem.title &#125;&#125;&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/template&gt; &lt;!-- 无子选项 --&gt; &lt;template v-else&gt; &lt;el-menu-item :index=&quot;item.index&quot; :key=&quot;item.index&quot;&gt; &lt;i :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &#123;&#123; item.title &#125;&#125; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;/template&gt;&lt;/el-menu&gt; 1this.items = appMenuitem[userMap[this.userInfo.role]]; 手动配置上的工作就完成了。后面就是完成路由的动态生成了。 路由生成 首页配置在router.js中配置项目通用路由： 12345678910111213 let router = new Router(&#123; routes: [ &#123; path: "/", redirect: "/home", &#125;, &#123; path: "/login", name: "login", component: resolve =&gt; require(["../views/Login.vue"], resolve) &#125; ]&#125;); home是主路由，前面配置的路由页面均嵌套在其中。下面来看看生成其他路由的方法 12345678910111213141516171819202122232425262728293031323334 function initRouter() &#123; // 登录用户 角色 审核方 业务方 供应商 const userType = userMap[store.state.userInfo.role] || 'Auditor'; let subs = appMenuitem[userType], children = []; subs = subs .map(c =&gt; c["subs"]) .forEach(sub =&gt; &#123; children = children.concat(sub); &#125;); children = children.map((child, index) =&gt; &#123; if (index == 0) &#123; return &#123; path: `/$&#123;child.index&#125;`, component: resolve =&gt; require([`@/views/$&#123;userType&#125;/$&#123;child.index&#125;.vue`], resolve) &#125;; &#125; return &#123; path: `/$&#123;child.index&#125;`, name: `$&#123;child.index&#125;`, component: resolve =&gt; require([`@/views/$&#123;userType&#125;/$&#123;child.index&#125;.vue`], resolve) &#125;; &#125;); // 为了配置 菜单导航 children.unshift(&#123; path: "/", redirect: children[0].path &#125;); // console.log(children) return children;&#125; 只要调用这个方法就可以生成，home的子级路由了。接下来我们可以通过router的APIaddRoutes完成路由的添加 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 // 在页面不刷新的前提 避免重复生产动态路由 window.hasRoutes = false; router.beforeEach((to, from, next) =&gt; &#123; // 路由卫士 if (to.path === "/login") &#123; // 请除登录信息 localStorage.removeItem("hasLogin"); &#125; let user = localStorage.getItem("hasLogin") == null; // 这里store.state.userInfo.role 是后台返回来的 用户角色信息 role 取值 为 1 2 3 分别 对应前面的键值 Author... if ((user|| !store.state.userInfo.role) &amp;&amp; to.path !== "/login" ) &#123; // 登录信息失效 直接去登录页面 next(&#123; path: "/login" &#125;); &#125; else &#123; // 获取动态路由 if (store.state.userInfo.role &amp;&amp; !window.hasRoutes) &#123; // window.hasRoutes 为了简单，使用的全局变量 进入登录login.vue 页面也可以重置为false即可 // router 创建新的路由对象 let newRouter = new Router(&#123; routes: [ &#123; path: "/", redirect: "/home", &#125;, &#123; path: "/login", name: "login", component: resolve =&gt; require(["../views/Login.vue"], resolve) &#125; ] &#125;) let children = initRouter(); router.matcher = newRouter.matcher; // 添加路由 router.addRoutes([ &#123; path: "/home", // name: "home", component: resolve =&gt; require(["@/views/Home.vue"], resolve), children: children &#125; ]); // 避免重复 window.hasRoutes = true; // 这里 时在实际情况存在 切换登录对象的时候, 首次路由加载不成功,需要刷新, 我们 手动跳到 home 重新走下刚刚的逻辑 if(from.path == '/login') &#123; router.push(&#123;path:'/home'&#125;) &#125;else&#123; router.push(&#123; path: to.path &#125;) &#125; &#125; else &#123; next(); &#125; &#125;&#125;); 最后,前端配置生成动态路由的方法基本就是这样啦,这是我在项目中遇到的坑,希望有所帮助.]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa原理浅析]]></title>
    <url>%2F2020%2F01%2F11%2FKoa%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[koa是现在我们最常用的node框架，它是一个轻量的web框架，只提供了http的协议的解析和中间件功能。我们要实现路由、静态页面托管和文件上传等功能均需要插件来实现。 koa源码结构上图是koa的源码结构，lib放着koa的核心文件：：application.js、context.js、request.js、response.js。 application.jsapplication.js是koa的入口文件，它向外到处了Koa类，即函数。Koa继承了node的事件模块event，因此，我们new Koa()的实例app，可以基于事件来实现观察订阅的功能。Koa还有内置了常用的几个函数：listen、use、createContext、toJSON。listen方法是通过http.createServer开启并监听了http服务，并且它里面还进行了中间件的合并、上下文context的初始化,并且每次请求来的中件合并、context都会重新初始化。 context.js这部分是对中间件上下对象ctx封装和暴露，里面的重点在delegate，这个就是代理，比如我们要访问ctx.repsponse.status但是我们通过delegate，可以直接访问ctx.status访问到它。 1234567891011121314151617181920212223242526272829303132// 暴露出来的对象const proto = module.exports = &#123; toJSON() &#123; return &#123; // this.request 是通过application.js 中的createContext 方法将 reques和response对象挂载 request: this.request.toJSON(), response: this.response.toJSON(), app: this.app.toJSON(), originalUrl: this.originalUrl, req: '&lt;original node req&gt;', res: '&lt;original node res&gt;', socket: '&lt;original node socket&gt;' &#125;; &#125;, get cookies() &#123; // .... &#125;, set cookies(_cookies) &#123; // .... &#125;&#125;;// 代理 ctx.reponse 和ctx.requestdelegate(proto, 'response') .method('attachment') .method('redirect') // ...delegate(proto, 'request') .method('acceptsLanguages') .method('acceptsEncodings') // ... request.js、response.js这两个文件是对原生对象req和res的解析,主要是使用了Getter和setter的方式来对http协议完成解析,便于我们使用. 12345678910111213141516// requestmodule.exports = &#123; get header() &#123; return this.req.headers; &#125;, set header(val) &#123; this.req.headers = val; &#125; // ........ get url() &#123; return this.req.url; &#125;, set url(val) &#123; this.req.url = val; &#125;,&#125; 上面的this.req 也是application.js 里面的application 方法挂载的123456789101112131415161718createContext(req, res) &#123; const context = Object.create(this.context); // 初始化上下文ctx对象 的 request和repoonse 属性 const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); // 保留app 实例 context.app = request.app = response.app = this; // 保留原生的 req 和 res 对象 也是 上面 request.js文件里面 写法的原因 context.req = request.req = response.req = req; context.res = request.res = response.res = res; //保留上下文 request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = &#123;&#125;; return context;&#125; Koa整体流程梳理123456789101112131415161718192021222324252627282930313233const http = require("http");class Application &#123; constructor() &#123; // 用来存储 use进来的中间件函数 this.middleware = []; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); &#125; use(middleware) &#123; // 将中间件加到数组⾥里里 this.middleware.push(middleware); &#125; listen(..args)&#123; const server = http.createServer(async(req,res)=&gt;&#123; // compose 会组合所有中间件 const fn = compose(this.middleware); // 初始化上下文 const ctx = this.createContext(req, res); // 执⾏行行合成函数并传⼊入上下⽂文 await fn(ctx); // 简单处理ctx.body res.end(ctx.body); //源码中是通过handlRequest来处理请求 并在函数 reponse中对 ctx.body的各种取值情况做了判断 &#125;) server.listen(...args); &#125; compose() &#123; //..... &#125;&#125;module.exports = Application; 中间件的原理koa的中间件机制是一个剥洋葱式的模型，多个中间件通过use放进一个数组队列然后从外层开始执行，遇到next后进入队列中的下一个中间件，所有中间件执行完后开始回帧，执行队列中之前中间件中未执行的代码部分，这就是剥洋葱模型。koa的中间件机制,是基于async/await + Promise实现的. compose函数实现12345678910111213141516function compose(middlewares) &#123; return function (ctx) &#123; // 初始执行第一个中间件函数 return disPatch(0) function disPatch(i) &#123; let fn = middlewares[0]; if(!fn) &#123; return Promise.resolve() &#125; // 返回promise return Promise.resolve(fn(ctx,function next()&#123; return disPatch(++i) &#125;)) &#125; &#125;&#125; koa-compose源码1234567891011121314151617181920212223242526272829function compose (middleware) &#123; // 错误处理 if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!') for (const fn of middleware) &#123; if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!') &#125; return function (context, next) &#123; let index = -1 // 从第一个中间件开始执行 return dispatch(0) function dispatch (i) &#123; // 中间件重复执行 if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] // 边界处理 这里的next 为undefined if (i === middleware.length) fn = next // 当fn为undefined 不执行 直接resolved if (!fn) return Promise.resolve() try &#123; // 实际app.use 中的 next 就是 disptch函数,它对应这当前的中间件函数 return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125;module.exports = compose 来看下洋葱模型的执行结果:1234567891011121314151617181920async function fn1(next) &#123; console.log("fn1"); await next(); console.log("end fn1"); &#125;async function fn2(next) &#123; console.log("fn2"); await delay(); await next(); console.log("end fn2"); &#125;function fn3(next) &#123; console.log("fn3");&#125;function delay() &#123; return new Promise((reslove, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reslove(); &#125;, 2000); &#125;); &#125;const middlewares = [fn1, fn2, fn3]; const finalFn = compose(middlewares); finalFn(); 总结koa的核心对象:Koa类构造函数、request、response、context都有梳理,koa的源码做了许多细节处理,这样处理有什么好处,还需和大家共同探讨]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vant pupop弹框锁住背景]]></title>
    <url>%2F2019%2F12%2F20%2Fvant-pupop%E5%BC%B9%E6%A1%86%E9%94%81%E4%BD%8F%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[我们在做移动端项目开发时，经常会遇到弹框不能锁定背景的背景的问题。比如有一个站视规则并且可以滚动的弹框，这是我们滑动滚动条浏览更多内容的时候，页面会跟随着一起滑动，这种体验不太友好。那么如何解决呢？ html、body设置hidden 我们可以设置html和body的overflow为hidden，1234.lock&#123; height: 100%; overflow: hidden;&#125; 当弹框展现时，我们可通过js为html和body加上类名，弹框隐藏时，移除类名lock。一些ui框架的弹框也是采用这种方法，如vant的popup弹出层组件。但是这种方法并不能在所有的移动设置生效。 阻止touchmove默认事件 为 body 绑定 touchmove 事件，然后调用 preventDefault() 方法，禁止 touchmove 的默认行为。123456789function preventDefaultFn(event)&#123; event.preventDefault();&#125;// 弹出时$('body').on('touchmove', preventDefaultFn);// 隐藏时$('body').off('touchmove', preventDefaultFn); 如果是vue的项目，有一个更简洁的方式,在弹框的遮罩层加上`@touchmove.prevent`即可1&lt;div class=&quot;mask&quot; @touchmove.prevent&gt; 但这种方法有一定的局限性，它适合于弹框内的元素不发生滚动，如果弹框的内容需要滚动，那么这种方法就不行了，滚动的内容无法继续滚动了，当然我们可以通过js模拟滚动，不过这有些麻烦。还好我们有第三种方案。 设置body为fixed定位 监听页面弹框的显现与隐藏，当页面有弹框出现时，我们将body设为fixed定位，然后设置 top 为页面滚动的高度，弹框隐藏时移除 body 的 fixed 定位，并把页面重新滚动到之前的位置。下面时我在vue项目中解决body随弹框滚动的问题。 123456789101112131415161718192021222324watch:&#123;// visible是页面中用来控制弹框显示与隐藏的变量集合 visible: &#123; deep: true, handler(newval) &#123; const hasPoup = Object.values(newval).some(val =&gt; val == true); // 如果有弹框显示 if (hasPoup) &#123; pageTop = document.documentElement.scrollTop || document.body.scrollTop; // body 为 fixed定位 document.body.classList.add(&quot;body-fixed&quot;); // 设置页面位置 document.body.style.top = `-$&#123;pageTop&#125;px`; &#125; else &#123; // 弹框隐藏 document.body.classList.remove(&quot;body-fixed&quot;); document.body.style.top = `0rem`; window.scrollTo(0, pageTop); &#125; &#125;, immediate: true &#125;&#125; 123456 .body-fixed &#123; position: fixed; // top: 0; height: 100%; overflow: hidden;&#125;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js文件处理]]></title>
    <url>%2F2019%2F12%2F08%2Fjs%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[下载文件 在后台的管理系统中，数据统计是必不可少的系统功能模块。因此，导出统计数据，下载文件是常见的需求。今天我们来看看实现常用的文件下载的几种方式。 window.open打开新页面下载文件 1window.open(`url`, '') 这种方式，后台提供文件下载路径，我们调用window.open方法就可以实现文件下载了，简单方便，但是当参数错误时，或其它原因导致接口请求失败，这时无法监听到接口返回的错误信息，需要保证请求必须是正确的且能正确返回数据流，不然打开页面会直接输出接口返回的错误信息，体验不好。 a标签打开新页面下载1234567891011121314function exportFile(url,filename) &#123; var link = document.createElement('a'); var body = document.querySelector('body'); link.href = url; // 自定义文件名字 link.download = filename; // 兼容火狐 link.style.display = 'none' body.appendChild(link)； link.click(); // 移除a标签 body.removeChild(link);&#125; a标签下载的方式和window.open一样，非常简单，还可以自定义下载的文件名，但是同样无法监听错误信息。而且，这两种方式在下载.mp3格式或者浏览器支持的音视频文件时，会直接播放，而不是下载这个文件。 文件流下载 为了解决下载音视频文件播放的文件，我们需要借助Blob对象和ArrayBuffer对象。 获取文件通过axios获取文件1234567891011121314import axios from 'axios'const getFile = url =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; axios(&#123; method:'get', url, responseType: 'arraybuffer' &#125;).then(data =&gt; &#123; resolve(data.data) &#125;).catch(error =&gt; &#123; reject(error.toString()) &#125;) &#125;)&#125; 保存文件接下来就是保持文件：12345678910111213141516const saveAs = (blob, filename) =&gt; &#123; if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveOrOpenBlob(blob, filename); &#125; else &#123; const link = document.createElement("a"); const body = document.querySelector("body"); link.href = window.URL.createObjectURL(blob); // 创建对象url link.download = filename; // fix Firefox link.style.display = "none"; body.appendChild(link); link.click(); body.removeChild(link); window.URL.revokeObjectURL(link.href); // 通过调用 URL.createObjectURL() 创建的 URL 对象 &#125;&#125; 调用方法123456export const download = (url,filename='')=&gt;&#123; getFile(url).then((blod)=&gt;&#123; // application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8 excel的mimeType saveAs( new Blob([res],&#123;type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8"&#125;),`$&#123;formatDate(new Date(), "yyyy-MM-dd")&#125;统计数据`) &#125;)&#125; 上传文件 除了表单的形式，我们还可以借助FileReader对象来完成文件上传。 new FileReader FileReader主要用于将文件内容读入内存，通过一系列异步接口，可以在主线程中访问本地文件。 使用FileReader对象，web应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容，可以使用File对象或者Blob对象来指定所要处理的文件或数据。 1var reader = new FileReader(); 方法 abort():void 终止文件读取操作 readAsArrayBuffer(file):void 异步按字节读取文件内容，结果用ArrayBuffer对象表示 readAsBinaryString(file):void 异步按字节读取文件内容，结果为文件的二进制串 readAsDataURL(file):void 异步读取文件内容，结果用data:url的字符串形式表示 readAsText(file,encoding):void 异步按字符读取文件内容，结果用字符串形式表示 事件 onabort 当读取操作被中止时调用 onerror 当读取操作发生错误时调用 onload 当读取操作成功完成时调用 onloadend 当读取操作完成时调用,不管是成功还是失败 onloadstart 当读取操作将要开始之前调用 onprogress 在读取数据过程中周期性调用 文件上传1234567891011121314151617181920212223const input = document.getElementById('file'); // input file 标签input.onchange = function() &#123; var file = this.files[0]; if(!!file) &#123; var reader = new FileReader(); reader.readAsArrayBuffer(file); reader.onload = function() &#123; // 读取的数据 var binary = this.result; upload(binary) &#125; &#125;&#125;function upload(binary) &#123; const blob = new Blob([this.result]); const formdata = new formdata(); formdata.append('file', blob); axios.post(url,formData).then(function (response) &#123; console.log("res: ",response); &#125;)&#125;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用js的方式实现vue弹框]]></title>
    <url>%2F2019%2F11%2F30%2F%E7%94%A8js%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0vue%E5%BC%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[在平常，我们使用vue组件的时候，都要先在.vue文件中引入我们要使用的组件。虽然这样能满足大部分日常开发的需求，但这种方法在某些场景下，就有些难以应对。 组件的模板是通过调用接口从服务端获取的，需要动态渲染组件； 实现类似原生 window.alert() 的提示框组件，它的位置是在 下，而非 ，并且不会通过常规的组件自定义标签的形式使用，而是像 JS 调用函数一样使用。 extend Vue.extend 的作用，就是基于 Vue 构造器，创建一个“子类”，它的参数跟 new Vue 的基本一样，但 data 要跟组件一样，是个函数，再配合 $mount ，就可以让组件渲染，并且挂载到任意指定的节点上，比如 body。1234567891011121314151617import Vue from &apos;vue&apos;;&lt;!-- 创建了一个构造器，这个过程就可以解决异步获取 template 模板的问题 --&gt;const AlertComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;, data () &#123; return &#123; message: &apos;Hello, Aresn&apos; &#125;; &#125;,&#125;);&lt;!-- 调用 $mount 方法对组件进行了手动渲染， --&gt;const component = new AlertComponent().$mount();&lt;!-- 挂载节点 --&gt;document.body.appendChild(component.$el);&lt;!-- 快捷的挂载方式 --&gt;new AlertComponent().$mount(&apos;#app&apos;); 这样就可以满足我们用js方法调用的方式来控制组件，但是在平常的开发中，我们用的vue的runtime编译环境，不支持template模板，而且用字符串来描述组件的模板，也有些不太友好。那么，我们可以试试用new Vue()的方式。 new Vue new Vue()也可以直接创建 Vue 实例，并且用一个 Render 函数来渲染一个 .vue 文件。123456789101112131415import Vue from &apos;vue&apos;;import Notification from &apos;./notification.vue&apos;;const props = &#123;&#125;; // 这里可以传入一些组件的 props 选项const Instance = new Vue(&#123; render (h) &#123; return h(Notification, &#123; props: props &#125;); &#125;&#125;);const component = Instance.$mount();document.body.appendChild(component.$el); 这样既可以使用 .vue 来写复杂的组件,还可以根据需要传入适当的 props。渲染后，如果想操作 Render 的 Notification 实例，也是很简单的:1const notification = Instance.$children[0]; 实例 接下来就给大家，看下我在项目中用new Vue()的方式来实现的弹框组件。首先我们要新建一个vue文件来，完成弹框的基本布局和样式。 modal-dialog 此文件实现了弹框的基本布局，蒙层和关闭事件,弹框内容可以通过插槽来控制，支持的props有width,height,bgSrc(弹框的背景图片),visible,hasClose(是否有关闭‘X’) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;template&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div style=&quot;position:fixed;top: 0;left: 0;width:100vw;height:100vh;z-index:100;&quot; v-if=&quot;isShow&quot; &gt; &lt;div class=&quot;mask&quot; @click.stop=&quot;closeDialog&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dialog&quot; :class=&quot;classObject&quot; :style=&quot;&#123; width, height, backgroundImage: `url($&#123;bgSrc&#125;)`, backgroundRepeat: &apos;no-repeat&apos;, ...wrapStyle &#125;&quot; &gt; &lt;slot&gt;&lt;/slot&gt; &lt;div v-if=&quot;hasClose&quot; class=&quot;close&quot; @click.stop=&quot;closeDialog&quot; :style=&quot;closeStyle&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;modalDialog&quot;, props: &#123; visible: &#123; type: Boolean, default: false &#125;, width: &#123; type: String, default: &quot;6.52rem&quot; &#125;, bgSrc: &#123; type: String, required: true &#125;, height: &#123; type: String, default: &quot;6.83rem&quot; &#125;, hasClose: &#123; type: Boolean, default: true &#125;, wrapClass: &#123; type: String, default: &quot;&quot; &#125;, wrapStyle: &#123; type: Object, default: function() &#123; return &#123;&#125;; &#125; &#125;, closeStyle: &#123; type: Object, default: function() &#123; return &#123;&#125;; &#125; &#125; &#125;, watch: &#123; visible(val) &#123; &lt;!-- 同步visible的变化 --&gt; this.isShow = val; &#125; &#125;, data() &#123; return &#123; &lt;!-- vue单向数据流，因此我们重新定义一个属性isShow --&gt; isShow: this.visible, classObject: &#123; [this.wrapClass]: true &#125; &#125;; &#125;, created() &#123;&#125;, methods: &#123; closeDialog() &#123; this.isShow = false; &lt;!-- 通知父组件 visible的变化 父组件使用.sync修饰符即可 --&gt; this.$emit(&quot;update:visible&quot;, false); &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;@imgPath: &quot;../assets/img/dialog&quot;;.translateXCenter &#123; left: 50%; transform: translateX(-50%) !important; -webkit-transform: translateX(-50%) !important;&#125;.translateCenter &#123; top: 50%; left: 50%; transform: translate(-50%, -50%) !important; -webkit-transform: translate(-50%, -50%) !important;&#125;.translateY(@y) &#123; left: 50%; top: 50%; transform: translate(-50%, @y); -webkit-transform: translate(-50%, @y);&#125;.background(@imgName) &#123; background: url(&quot;@&#123;imgPath&#125;/@&#123;imgName&#125;&quot;) no-repeat; background-size: 100% auto;&#125;.mask &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(10, 13, 24, 0.8); z-index: 100;&#125;.dialog &#123; // background-repeat: no-repeat background-size: 100% auto; position: absolute; z-index: 100; // .translateXCenter; .translateCenter;&#125;.close &#123; width: 0.56rem; height: 0.56rem; position: absolute; top: -0.4rem; right: 0rem; .background(&quot;btn_close.png&quot;);&#125;.fade-enter-active,.fade-leave-active &#123; transition: all 0.2s ease-in;&#125;.fade-enter,.fade-leave-to &#123; opacity: 0;&#125;.fade-enter-to,.fade-leave &#123; opacity: 1;&#125;&lt;/style&gt; 弹框的基本功能实现后，我们就用它来建一个常用的通知组件 alert-box。文件中的图片大家自行替换呀。样式方面也请自行调整呀。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;template&gt; &lt;modal-dialog &lt;!-- 这里一定要加sync修饰符 --&gt; :visible.sync=&quot;isShow&quot; width=&quot;6.7rem&quot; height=&quot;5.51rem&quot; :bgSrc=&quot;require(&apos;@img/dialog/tuan_bg.png&apos;)&quot; &gt; &lt;div class=&quot;content&quot;&gt; &lt;ul&gt; &lt;template v-if=&quot;textArr.length &gt; 0&quot;&gt; &lt;li v-for=&quot;(text, index) in textArr&quot; :key=&quot;index&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;div class=&quot;btn-wrap&quot;&gt; &lt;div class=&quot;konw&quot; @click=&quot;hideBox&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/modal-dialog&gt;&lt;/template&gt;&lt;script&gt;import ModalDialog from &quot;@/components/modalDialog.vue&quot;;export default &#123; name: &quot;AlertBox&quot;, props: &#123; &lt;!-- 显示隐藏 --&gt; visible: &#123; type: Boolean, default: false &#125;, &lt;!-- 消息的内容 --&gt; textArr: &#123; type: Array, default() &#123; return []; &#125; &#125; &#125;, components: &#123; ModalDialog &#125;, data: function() &#123; return &#123; &lt;!-- props单向数据流，组件内部用isShow记录组件状态，最后同步给父级 --&gt; isShow: this.visible, &#125;; &#125;, methods: &#123; hideBox() &#123; this.isShow = false; &#125; &#125;, watch: &#123; visible(newval) &#123; this.isShow = newval; &#125;, isShow(newval) &#123; &lt;!-- 通知父组件，同步组件显示隐藏状态 --&gt; this.$emit(&quot;update:visible&quot;, newval); &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;@imgPath: &quot;../assets/img/dialog&quot;;.background(@imgName) &#123; background: url(&quot;@&#123;imgPath&#125;/@&#123;imgName&#125;&quot;) no-repeat; background-size: 100% auto;&#125;.translateCenter &#123; top: 50%; left: 50%; transform: translate(-50%, -50%) !important; -webkit-transform: translate(-50%, -50%) !important;&#125;.content &#123; width: 100%; height: 100%; position: relative; ul &#123; position: absolute; // background-color: skyblue; width: 5.24rem; height: 2.83rem; color: #914e4c; font-size: 0.32rem; display: flex; flex-direction: column; justify-content: center; align-items: center; top: 0.9rem; left: 0.76rem; // font-weight: 600; li &#123; text-align: justify; &#125; &#125; .btn-wrap &#123; position: absolute; top: 4.2rem; width: 100%; .konw &#123; width: 2.66rem; height: 1.05rem; margin: 0 auto; display: block; .background(&quot;btn_know.png&quot;); &#125; &#125;&#125;&lt;/style&gt; 最后，是重头戏，如何将这个alertBox的实例挂载在vue的原型上呢？下面我们用new Vue来实现alert.js12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from "vue";import AlertBox from "./alertBox.vue";let contain = document.body, messageInstance = null, component = null;AlertBox.newInstance = properties =&gt; &#123; const props = properties || &#123;&#125;; // props : visible ; textType 传入props visible，我们还可以传入很多的props 详情查看官方文档 const Instance = new Vue(&#123; render(h) &#123; return h(AlertBox, &#123; props, nativeOn: &#123; "update:visible": function(val) &#123; // 监听alerBox isShow变化的事件，如果组件隐藏，我们移除挂载节点，并销毁实例 if (!val) &#123; contain.removeChild(component.$el); Instance.$destroy(); &#125; &#125; &#125; &#125;); &#125; &#125;); // 组件渲染 component = Instance.$mount(); // 组件挂载 contain.appendChild(component.$el);&#125;;// 保证单一实例function getMessageInstance(props) &#123; messageInstance = messageInstance || AlertBox.newInstance(props);&#125;export default &#123; // 暴露info方法，后面可以增加新的方法 info(props) &#123; return getMessageInstance(props); &#125;&#125;; 最后我们在项目的main.js文件引入alert.js12import MyAlert from "./components/alert";Vue.prototype.$myAlert = MyAlert; 就可以在vue文件中，用 this.$myAlert.info() 实现通知弹框了。1234this.$myAlert.info(&#123; visible: true, textArr: ["团队解散失败，请重试"]&#125;);]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js处理字符串和数字]]></title>
    <url>%2F2019%2F10%2F20%2Fjs%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[字符串字符串在自然世界中充当着非常重要的角色，所有的自然语言（比如汉语、英语等）都由多个字符组成，比如经典的 “Hello World” 这句话则由 11 个字符组成：H,e,l,l,o,,W,o,r,l,d。 创建字符串在 JavaScript 中创建一个字符串跟其他语言并没有较大的区别，可以分别使用 ‘、” 和 ` 作为边界标识。 123const str1 = 'string 1'const str2 = "string 2"const str3 = `string 3` 虽然 ` 同样可以以与 &#39; 和 &quot; 一样的使用方式使用，但也可以有更高级的用法。 12const target = 'World'const word = `Hello $&#123;target&#125;` //=&gt; Hello World 同时 ` 也可以用于创建一个“多行字符串”，即字符串内容中包含多行文本。 12345678const str = `HelloWorld`//=&gt;// Hello// World 分割字符串一般来说人们都会使用词频统计作为数据科学的 “Hello World”，简单来说就是对一段英语内容中的单词进行频次（出现次数）统计。我们在进行词频统计之前，我们首先需要对源内容进行预处理。首先我们要了解的是，我们可以看到这段内容中有小写字母、大写字母以及标点符号（包括逗号、句号、括号、双引号、斜杠和冒号）。 而从语言角度，HELLO、hello 和 Hello 都是一样的，所以我们需要先完成以下预处理任务： 去除文本中的标点符号、数字 将所有大写字母转换为小写字母 假设原文为 “Hey dude, how is it going?”，则需要首先转换为 “hey dude how is it going”。 去除文本中的标点符号在做任何需求之前，都需要先对需求的上下文进行多方位理解，比如去除标点符号、数字这个需求在全英语的语境下可以说是约等于只保留英文字母。这样我们就可以从文本中直接筛选出英文字母和空格即可，这里可以使用 ASCII 码进行甄别。大写字母的 ASCII 码范围为 65 到 90，即 A 到 Z，而小写字母则为 97 到 122，空格的 ASCII 码为 32，换行符的 ASCII 码为 10。在 JavaScript 可以用 string.charCodeAt() 方法获取字符的 ASCII 码。 1234567891011const originalText = 'Hey dude, how is it going?'let wordOnlyText = ''for (let i = 0; i &lt; originalText.length; ++i) &#123; const letter = originalText[i] const asciiCode = letter.charCodeAt() if ((asciiCode &gt;= 65 &amp;&amp; asciiCode &lt;= 90) || (asciiCode &gt;= 97 &amp;&amp; asciiCode &lt;= 122) || asciiCode === 32) &#123; wordOnlyText += letter &#125;&#125;console.log(wordOnlyText) //=&gt; "Hey dude how is it going" 将所有大写字母转换为小写字母上面我们用到了 string.charCodeAt() 方法来获取字符的 ASCII 码，那么自然也有对应的方法用于将 ASCII 码转换为对应字符 String.fromCharCode(code)。 而从字母的 ASCII 码范围可以看到，将大写字母的 ASCII 码数值加上 32 便是其对应小写字母的 ASCII 码数值。 1234567891011121314let lowerCaseText = ''for (let i = 0; i &lt; wordOnlyText.length; ++i) &#123; const letter = wordOnlyText[i] const asciiCode = letter.charCodeAt() if (asciiCode &gt;= 65 &amp;&amp; asciiCode &lt;= 90) &#123; lowerCaseText += String.fromCharCode(asciiCode + 32) &#125; else &#123; lowerCaseText += letter &#125;&#125;console.log(lowerCaseText) //=&gt; "hey dude how is it going" JavaScript 内置将文本中的大写字母转换为小写字母的 API —— string.toLowerCase()。 完成了文本的预处理之后，就可以将文本数据进行分割了。而最主要用到的方法便是 string.split(separator) 123456789101112131415161718192021222324const originalText = `Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.`let wordOnlyText = ''for (let i = 0; i &lt; originalText.length; ++i) &#123; const letter = originalText[i] const asciiCode = letter.charCodeAt() if ((asciiCode &gt;= 65 &amp;&amp; asciiCode &lt;= 90) || (asciiCode &gt;= 97 &amp;&amp; asciiCode &lt;= 122) || asciiCode === 32) &#123; wordOnlyText += letter &#125;&#125;const lowerCaseText = wordOnlyText.toLowerCase()/*---------------------------------------------------------------------*/const words = lowerCaseText.split(' ')console.log(words.length) //=&gt; 163 组装字符串字符串之间的连接可以直接使用 + 运算符完成。若当数据量比较大时，需要将多个数据量“嵌入”到一个文本模板中。一般情况下，开发工程师会选择一个较为顺手的模板引擎来实现这个功能，但在这里我们一切从简，使用 JavaScript 中的字符串模板特性 ` 来完成这个需求。 数字除了自然语言以外，当我们需要准确地表达世界上任何事物时，我们还需要有数字的帮助。 四则运算四则运算是所有数学运算的基础。 1234567const a = 3const b = 4a + b //=&gt; 7b - a //=&gt; 1a * b //=&gt; 12a / b //=&gt; 0.75 幂运算幂运算，又称指数运算，是数学中非常重要的一种运算方式，具体定义便是同一个数值的多次自乘结果。有了幂运算才有后面更为深入的对数运算、导数运算、方差运算等等。在 JavaScript 中，使用 Math.pow(base, exponent) 来进行幂运算，其中 base 为底数即上式中的 n，而 exponent 则为指数即右上角的 3。 12345678910const V1 = 3 * 3 * 3console.log(V1) //=&gt; 27const V2 = Math.pow(3, 3)console.log(V2) //=&gt; 27const calcCubeVolume = function(sideLength) &#123; return Math.pow(sideLength, 3)&#125;console.log(calcCubeVolume(3)) //=&gt; 27 对数运算数学中这就涉及了对数运算，比如求“27 是 3 的多少次方”则为 而在数学中有一个神奇的数值自然对数，关于这个数值的传奇故事你可以搜索到非常多的文章甚至视频。在 JavaScript 中的 Math.log(x) 函数只接受一个参数，而这个函数的直接作用便是计算以自然对数 为底 的对数。 那么就很奇怪了，我们要如何在 JavaScript 中计算并非以为底的对数结果呢？这得先回到数学推导上来。对数中有一个经典公式为换底公式，定义如下： 具体推导可以参考维基百科页面 · 对数。那么代入我们前面公式中就可以用这样的方式解决了。 换成使用 JavaScript 实现便是： 12345function getBaseLog(base, x) &#123; return Math.log(x) / Math.log(base)&#125;console.log(getBaseLog(2, 1024)) //=&gt; 10]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目配合axios实现loading效果]]></title>
    <url>%2F2019%2F10%2F13%2Fvue%E9%A1%B9%E7%9B%AE%E9%85%8D%E5%90%88axios%E5%AE%9E%E7%8E%B0loading%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[问题 在实际项目中，前端发送请求获取数据刷新页面是大家非常熟悉的操作。请求响应的快慢，与业务逻辑的复杂程度和网络环境有关，很有可能出现请求延迟的情况，如果我们不处理请求响应前后的交互，那么页面在请求响应成功之前这段事件就没有任何提示信息，这是非常影响用户体验的。但是如何为每个请求单独处理loading状态，那么工作量是非常大的。 axios是我们开发中常用的请求工具库，并且和vue能很好的搭配。下面向大家介绍我自己在项目中使用axios配置来完场全局的loading状态处理 store状态记录index.js12345678910111213141516import Vue from "vue";import Vuex from "vuex";Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; // 是否在请求中 isAppending: false &#125;, mutations: &#123; changeAppending(state, bool) &#123; state.isAppending = bool; &#125; &#125;&#125;); axios 配置axios/index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * axios配置 */import axios from "axios";import qs from "qs";// 引入 vuex 入口文件 记录全局loading状态import store from "../store/store";// 定时器数组，一般我们都是等请求时间超过1秒后，才出现loading状态，如果一开始就提示，用户体验也不是很好let timers = [], timer = null;const service = axios.create(&#123; // 设置超时时间 timeout: 60000, baseURL: process.env.VUE_APP_BASE_URL&#125;);/* * post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置 *即设置post的请求头为application/x-www-form-urlencoded;charset=UTF-8 */service.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";// 拦截请求service.interceptors.request.use( config =&gt; &#123; // 配置formData的方式 config.data = qs.stringify(config.data); // 每次请求开始前 都开启延迟定时器，并记录在数组中，便于响应回来后 清除 timer = setTimeout(() =&gt; &#123; !store.state.isAppending &amp;&amp; store.commit("changeAppending", true); &#125;, 1000); timers.push(timer); return config; &#125;, error =&gt; &#123; // ... return Promise.reject(error); &#125;);// 拦截响应service.interceptors.response.use( response =&gt; &#123; // 请除所有的定时器; clearAllTimer(); // 去除 loading 效果 store.commit("changeAppending", false); return response; &#125;, error =&gt; &#123; clearAllTimer(); store.commit("changeAppending", false); return Promise.reject(error); &#125;);function clearAllTimer() &#123; timers.forEach(item =&gt; &#123; clearTimeout(item); &#125;); timers = [];&#125;export default service; vue项目中使用 我的项目中应用了vue的UI组件库—-vant，使用其提供的Toast组件即可完成loading状态的交互。 具体使用main.js12345678910111213141516171819import Vue from "vue";// 按需引入Toastimport &#123; Toast &#125; from "vant";import App from "./App.vue";import router from "./router/index";import axios from "./axios/index";import store from "./store/store";import "./common/less/reset.less";// 注册Vue.use(Toast);Vue.config.productionTip = false;Vue.prototype.$axios = axios;// runtimexnew Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount("#app"); 最后，我们在项目根组件App.vue中监听 isAppending状态即可app.vue12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &quot;vuex&quot;;export default &#123; name: &quot;App&quot;, data() &#123; return &#123;&#125;; &#125;, computed: &#123; ...mapState([&quot;isAppending&quot;]) &#125;, watch: &#123; isAppending(val) &#123; console.log(&quot;isApending&quot;, val); val ? this.$toast.loading(&#123; message: &quot;加载中...&quot;, duration: 0, forbidClick: true &#125;) : this.$toast.clear(); &#125; &#125;, created() &#123;&#125;, methods: &#123;&#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;@import &quot;./common/less/reset.less&quot;;&lt;/style&gt; 大功告成了！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG01]]></title>
    <url>%2F2019%2F10%2F05%2FSVG01%2F</url>
    <content type="text"><![CDATA[理解SVG中的 viewport，viewBox, preserveAspectRatio 理解viewport该属性表示的是SVG可见区域的大小。或者也可以叫画布的大小。就好比我们的电脑屏幕，我们只能看到我们电脑屏幕的可视区里面的内容，但是看不到电脑屏幕之外的内容。比如如下代码： 1&lt;svg width="200" height="200" style="border: 1px solid red"&gt;&lt;/svg&gt; 上述代码设置了svg的画布大小为200px*200px, 如果没有带单位的话，该单位默认是 px(像素)。当然也有其他单位： em: 相对于父元素的字体大小。 ex: 相对于小写字母的 ‘x’ 的高度(不常用) px: 像素(在支持css2的图形系统中，每英寸为96像素)。 pt: 点(1/72英寸) pc: 12点(1/6英寸)。 cm: 厘米 mm: 毫米 in: 英寸 svg元素的width和height还可以为百分比，当我们的svg元素嵌套在一个div里面去的话，那么它的百分比是相对于外层的div元素的宽度和高度进行计算的。当然如果我们的svg元素为根元素的话，那么它的百分比是相对于窗口的尺寸来计算的 123&lt;div style="width:400px;height:400px; border: 1px solid red; "&gt; &lt;svg width="20%" height="20%" style="border: 1px solid red;"&gt;&lt;/svg&gt;&lt;/div&gt; 如果我们没有给svg设置宽度和高度的话，它默认的宽度为300px，高度为150px 理解默认用户坐标在svg中有一个默认的坐标系统，其中 水平坐标(x坐标)向右递增的，垂直坐标(y坐标)是向下递增的。原点坐标是(0, 0). 该坐标系统类似于我们数学几何中的坐标。 比如我们现在建立一个200px宽，200px高的视口，然后我们在里面绘制一个矩形，该矩形左上角在坐标(10, 10)的位置，该矩形的宽度为50px, 高度为 50px，基本代码如下： 1234&lt;svg style="border: 1px solid red;" width="200" height="200"&gt; &lt;rect x="10" y="10" width="50" height="50" style="stroke: black; fill:none;"&gt;&lt;/rect&gt;&lt;/svg&gt;&lt;div style="width:100px;height:100px;margin-left:10px;background: red;"&gt;&lt;/div&gt; 理解viewBox viewBox=”x, y, w, h”; 该属性的含义是可视区盒子，即画布的可视区。 viewport 和 viewBox 分别有自己的坐标系，默认情况下，该两个坐标系是重合的，即转换关系是 1:1。 x: 指左上角的坐标，y: 左上角的纵坐标，w: 指宽度，h: 指高度 画布(viewport)、可视区(viewBox) 的宽度的高度相等情况12345&lt;div style="width:100%;display:inline-block;"&gt; &lt;svg style="border: 1px solid red;" width="400" height="200" viewBox="0,0,400,200"&gt; &lt;rect x="10" y="10" width="100" height="100" style="stroke: black; fill:none;"&gt;&lt;/rect&gt; &lt;/svg&gt;&lt;/div&gt; 如上代码，svg的画布大小，宽度为400px，高度为200px，然后使用viewBox属性定义画布的可视区的大小宽度也是400px，高度也是200px, 因此该两个坐标系是重合的，因此我们使用 rect 来创建矩形的话，定义宽度和高度分别为100px，x轴和y轴的偏移位置为10px 画布不变，可视区的宽度减小的情况比如如下代码，可视区的宽度减少100px,12345&lt;div style="width:100%;display:inline-block;"&gt; &lt;svg style="border: 1px solid red;" width="400" height="200" viewBox="0,0,300,200"&gt; &lt;rect x="10" y="10" width="100" height="100" style="stroke: black; fill:none;"&gt;&lt;/rect&gt; &lt;/svg&gt;&lt;/div&gt; 画布不变，可视区的高度减小的情况1234&lt;svg style="float:left;border: 1px solid red;" width="200" height="200" viewBox="0,0,200,100"&gt; &lt;rect x="10" y="10" width="100" height="100" style="stroke: black; fill:none;"&gt;&lt;/rect&gt;&lt;/svg&gt;&lt;div style="float:left; margin-left: 20px; border: 1px solid red;width:200px;height:100px;margin-top:60px"&gt;&lt;/div&gt; 如上可以看到，矩形向下偏移的距离 = 200 - 100 / 2 + 10 = 60px; 因此我们可以看到我们的下面的div元素 margin-top:60px; 就可以对齐了。 可视区不变，画布宽度变小如果可视区不变的话，画布宽度减少的话，那么矩形也要等比例缩小，比如如下代码：1234&lt;svg style="float:left;border: 1px solid red;" width="100" height="200" viewBox="0,0,200,200"&gt; &lt;rect x="0" y="0" width="100" height="100" style="stroke: black; fill:none;"&gt;&lt;/rect&gt;&lt;/svg&gt;&lt;div style="float:left; margin-left: 20px; border: 1px solid red;width:100px;height:200px;margin-top:50px"&gt;&lt;/div&gt; 如上可以看到，矩形本来大小是 100px*100px，现在画布的宽度改成100px了，那么矩形也变成原来的一半了，至于向下移动距离的计算 = 200 - 100 / 2 = 50px; 可视区不变，画布的高度变小可视区不变，画布高度变小的话，那么矩形也要等比例缩放；如下代码所示：123456&lt;div style="width:100%;display:inline-block;"&gt; &lt;svg style="float:left;border: 1px solid red;" width="200" height="80" viewBox="0,0,200,200"&gt; &lt;rect x="0" y="0" width="100" height="100" style="stroke: black; fill:none;"&gt;&lt;/rect&gt; &lt;/svg&gt;&lt;/div&gt;&lt;div style="margin-top:10px;border: 1px solid red;width:200px;height:80px;margin-left:60px"&gt;&lt;/div&gt; 可视区宽度和高度大于画布的宽度和高度1234&lt;svg style="float:left;border: 1px solid red;" width="45" height="135" viewBox="0,0,200,200"&gt; &lt;rect x="0" y="0" width="100" height="100" style="stroke: black; fill:none;"&gt;&lt;/rect&gt;&lt;/svg&gt;&lt;div style="float:left;margin-left:20px;border: 1px solid red;width:45px;height:135px;margin-top:46px"&gt;&lt;/div&gt; 如果可视区宽度和高度大于画布的宽度和高度的话，那么 矩形的宽度和高度的计算方式以 宽度和高度最小的那个来等比例计算，什么意思呢？我们如上的画布的宽度是45px，高度是135px，那么宽度小于高度，因此需要按照45px来计算，因此计算方式 =123200 100--- = ----45 x 理解 preserveAspectRatio该属性的作用是：它允许我们指定被缩放的图像相对视口的对齐方式。基本的使用方法如下所示： preserveAspectRatio = “alignment [meet | slice]” 其中 alignment 指定轴和位置，默认值为 preserveAspectRatio = “xMidYMid meet”; preserveAspectRatio 该属性是应用在SVG上，且和viewBox属性配合一起使用的。viewBox属性值可以指明是否可以等比例缩放(宽高比相同的情况下)，以扩展到viewport指定的大小区域中。 第二个参数有3个值可选，分别为：meet 和 slice 和 none。 meet 的含义是：viewBox保持等比例缩放，整个viewBox在viewport中都是可见的。在满足2个约束的条件基础上，尽可能的放大viewBox,当viewport的宽高比和viewBox的宽高比不匹配的时候，那么取宽高比中较小的那个。 slice 的含义是：修剪viewBox保持等比例缩放，整个viewport区域会被viewBox覆盖。在满足2个约束的条件基础之上，尽可能的缩小viewBox，当viewport的宽高比和viewBox的宽高比不匹配时，取宽高缩放比中比较大的那个。 none 的含义是：不强制等比例缩放，尽量以viewBox和viewport以实际的宽高比来缩放图形，尽量把宽度和高度扩展到这个viewport上。最后的结果就会使图像变模糊。 preserveAspectRatio=”xMinYMin meet”情况强制缩放比例，xMin：viewBox的x轴和viewport的x轴最左边对齐，YMin：viewBox的y轴和viewport的y轴最左边对齐。 123456789&lt;svg style="border: 1px solid red;" width="400" height="200" viewBox="0,0,300,200" preserveAspectRatio="xMinYMin meet"&gt; &lt;rect x="10" y="10" width="100" height="100" style="stroke: black; fill:none;"&gt;&lt;/rect&gt;&lt;/svg&gt; preserveAspectRatio=”xMinYMid meet”情况下强制缩放比例，xMin：viewBox的x轴和viewport的x轴最左边对齐，YMid：viewBox的y轴和viewport的y轴中点对齐。 preserveAspectRatio=”xMinYMax meet”情况下强制缩放比例，xMin：viewBox的x轴和viewport的x轴最左边对齐，YMax：viewBox的y轴和viewport的y轴最下边对齐 preserveAspectRatio=”xMidYMin meet”情况下强制缩放比例，xMid：viewBox的x轴的中心和viewport的x轴中心对齐，yMin: viewBox的Y轴最上方和viewport的y轴最上方对齐。 preserveAspectRatio=”xMidYMid meet”强制等比例缩放，xMid：viewBox的x轴中点和viewport的x轴中点对齐，YMid： viewBox的y轴中点 和 viewport的y轴中点对齐。]]></content>
      <categories>
        <category>svg</category>
      </categories>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue倒计时组件]]></title>
    <url>%2F2019%2F09%2F28%2Fvue%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[倒计时vue组件 最近在项目中，有了倒计时的需求，于是结合vue自己写了一个组件，我们只需传入一个结束时间endtime，即可开启倒数计时，倒计时结束后，我们可以监听timeOver事件。 注意事项 倒计时无缝滚动，安卓手机bug处理nextTick和 setTimeout timeOver事件，最好判断下 是否传入的endtime 是不一样的，不然可能出现死循环本组件支持时、分、秒的倒计时，并实现了无缝滚动的效果。具体参看代码呀！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280&lt;template&gt; &lt;div class=&quot;time&quot;&gt; &lt;!-- 小时 十位数 --&gt; &lt;div class=&quot;column&quot; :class=&quot;&#123; animation: col1 &#125;&quot; ref=&quot;col1&quot;&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;8&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;9&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;/div&gt; &lt;!-- 小时各位数 --&gt; &lt;div class=&quot;column&quot; :class=&quot;&#123; animation: col2 &#125;&quot; ref=&quot;col2&quot;&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;8&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;9&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;colon&quot;&gt;&lt;/div&gt; &lt;!-- 分钟十位 --&gt; &lt;div class=&quot;column&quot; :class=&quot;&#123; animation: col3 &#125;&quot; ref=&quot;col3&quot;&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;/div&gt; &lt;!-- 分钟各位数 --&gt; &lt;div class=&quot;column&quot; :class=&quot;&#123; animation: col4 &#125;&quot; ref=&quot;col4&quot;&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;8&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;9&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;colon&quot;&gt;&lt;/div&gt; &lt;!-- 秒钟十位数 --&gt; &lt;div class=&quot;column&quot; :class=&quot;&#123; animation: col5 &#125;&quot; ref=&quot;col5&quot;&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;/div&gt; &lt;!-- 秒钟个位数 --&gt; &lt;div class=&quot;column&quot; :class=&quot;&#123; animation: col6 &#125;&quot; ref=&quot;col6&quot;&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;8&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;9&lt;/div&gt; &lt;div class=&quot;num&quot; :class=&quot;&#123; android: isArd &#125;&quot;&gt;0&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;TimeClock&quot;, props: &#123; activityInfo: &#123; type: Object, default() &#123; return &#123; endTime: &quot;&quot;, type: &quot;&quot; &#125;; &#125; &#125; &#125;, data() &#123; return &#123; fontSize: &quot;0.26rem&quot;, nowTime: new Date(), classList: [&quot;visible&quot;, &quot;close&quot;, &quot;far&quot;, &quot;far&quot;, &quot;distant&quot;, &quot;distant&quot;], lastEndtime: 0, timer: null, col1: true, col2: true, col3: true, col4: true, col5: true, col6: true, // 是否为安卓手机 isArd: false &#125;; &#125;, watch: &#123; activityInfo(val) &#123; if (this.timer) &#123; clearInterval(this.timer); &#125; const endTime = val.endTime; // 在这里触发定时器 能获取最新的endTime ，但在触发结束事件 timeOver 作判断防止死循环 this.run(endTime); &#125; &#125;, created() &#123; this.isArd = this.isAndroid(); &#125;, beforeDestroy() &#123; if (this.timer) &#123; clearInterval(this.timer); &#125; &#125;, methods: &#123; isAndroid() &#123; const ua = navigator.userAgent.toLowerCase(); if (ua.match(/android/i) == &quot;android&quot;) &#123; return true; &#125; else &#123; return false; &#125; &#125;, padClock(n, i) &#123; n = parseInt(n) &gt; 9 ? n + &quot;&quot; : String(n).padStart(2, &quot;0&quot;); i = parseInt(i) &gt; 9 ? i + &quot;&quot; : String(i).padStart(2, &quot;0&quot;); return n + i; &#125;, getClock(surplusTime) &#123; // 858631309 let hours = Math.floor(surplusTime / (1000 * 3600)), // 计算小时候的剩余 毫秒数 leave1 = surplusTime % (1000 * 3600), // 分钟 minutes = Math.floor(leave1 / (1000 * 60)), // 分钟后剩余的毫秒数 leave2 = leave1 % (1000 * 60), // 秒 seconds = Math.floor(leave2 / 1000); return [hours, minutes, seconds].reduce(this.padClock); &#125;, getClass(n, i2) &#123; return ( this.classList.find(function(class_, classIndex) &#123; return i2 - classIndex === n || i2 + classIndex === n; &#125;) || &quot;&quot; ); &#125;, run(endTime = &quot;0&quot;) &#123; const self = this; let columns = [&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;, &quot;col4&quot;, &quot;col5&quot;, &quot;col6&quot;], fontSize = 0.4, lastTimeNums = &quot;&quot;; this.timer = setInterval(() =&gt; &#123; let surplusTime = new Date(endTime) - new Date(), timenums = this.getClock(surplusTime); if (surplusTime &lt;= 0) &#123; clearInterval(this.timer); // 倒计时结束后，通知父组件 // console.log(&quot;endTime&quot;, endTime); if (endTime != &quot;0&quot; &amp;&amp; self.lastEndtime != endTime) &#123; this.$emit(&quot;timeOver&quot;, this.activityInfo.type); &#125; self.lastEndtime = endTime; return false; &#125; columns.forEach((ele, i) =&gt; &#123; let n = parseInt(timenums[i]), cuRef = this.$refs[ele], len = cuRef.children.length, // 每个格子的高度 offset = -n * fontSize; if (lastTimeNums[i] != n) &#123; if (n == len - 2) &#123; this[ele] = false; // 安卓手机bug this.$nextTick(() =&gt; &#123; cuRef.style.transform = `translateY($&#123;-(len - 1) * fontSize&#125;rem)`; &#125;); setTimeout(() =&gt; &#123; this[ele] = true; // 安卓手机bug this.$nextTick(() =&gt; &#123; cuRef.style.transform = `translateY($&#123;offset&#125;rem)`; &#125;); // 大于浏览器的帧数 &#125;, 30); &#125; else &#123; cuRef.style.transform = `translateY($&#123;offset&#125;rem)`; &#125; &#125; &#125;); lastTimeNums = timenums; // &#125;, 1000); &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;// @isArd: `navigator.userAgent.toLowerCase() .match(/ android/i) == &quot;android&quot; `;.time &#123; height: 0.4rem; overflow: hidden; .column &#123; display: inline-block; vertical-align: top; font-size: 0.26rem; color: #fff; width: 0.24rem; text-align: center; margin-left: 0.05rem; // position: relative; &#125; .colon &#123; width: 0.16rem; display: inline-block; font-size: 0.26rem; line-height: 0.4rem; &#125; .column:nth-of-type(1) &#123; margin-left: 0; &#125; .animation &#123; transition: transform 300ms; &#125; .num &#123; -webkit-transition: opacity 500ms, text-shadow 100ms; transition: opacity 500ms, text-shadow 100ms; text-align: center; height: 0.4rem; line-height: 0.4rem; width: 100%; // opacity: 0.025; opacity: 1; box-sizing: border-box; padding-left: 0.02rem; &#125; .android &#123; padding-top: 0.02rem; &#125; .num.visible &#123; opacity: 1; text-shadow: 1px 1px 0px #336699; &#125; .num.close &#123; opacity: 0.35; &#125; .num.far &#123; opacity: 0.15; &#125; .num.distant &#123; opacity: 0.1; &#125;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月项目回顾]]></title>
    <url>%2F2019%2F09%2F14%2F8%E6%9C%88%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[开车了项目回顾总结问题回顾（技术问题，业务问题皆可，或者项目中使用的新技术，插件，解决方案）问题1 safari浏览器抖动问题问题描述：(问题的背景，出现场景)描述： Safari浏览器，多个input框聚焦输入，当input失去焦点时，页面会整体往上移动，导致底部留白，并且页面其他按钮错位？ 解决方案（代码，截图）解决： 当前页面，没有激活状态的input框是，在将页面复原。123456789101112131415// 可以附上代码 const reg = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/; let msg=''; if (this.boardNumber.replace(/^ +| +$/).length === 0) &#123; return; &#125; if (!reg.test(this.boardNumber)) &#123; msg = '请输入正确的车牌格式'; &#125; if (msg) &#123; this.$toast.show(&#123;text: msg&#125;) &#125; if (document.activeElement.tagName.toLowerCase() !== 'input') &#123; window.scrollTo(0,0); &#125; 问题2 clipboardjs多个按钮复制问题描述：(问题的背景，出现场景)vue组件中循环渲染‘复制’按钮，当全局只创建一个clipboard对象或者不动态绑定‘文本复制源’，那么每个按钮复制的文本会相同？123456// 动态指定文本源new ClipboardJS('.btn', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125;&#125;); 解决方案（代码，截图）在每个按钮的点击事件中，均创建一个clipboard对象，并且动态地绑定按钮对应的文本元素123456789&lt;input type=&quot;text&quot; :value=&quot;awardInfo.snCode&quot; id=&quot;sncode&quot; :class=&quot;&#123;[&apos;sncode&apos;+index]:true&#125;&quot; :ref=&quot;&apos;sncode&apos;+index&quot; style=&quot;position: absolute;opacity: 0;top: -0.4rem;&quot;/&gt;&lt;button class=&quot;operator&quot; :class=&quot;&#123;[&apos;copyBtn&apos;+index]:true&#125;&quot; @click=&quot;copyLink(awardInfo.prizeType)&quot; &gt;复制劵码&lt;/button&gt; 123456789101112131415161718192021222324 copyLink(prizeType) &#123; console.log(1111) let _this = this, clipboard = null; clipboard = new this.$clipboard(`.copyBtn$&#123;_this.index&#125;`,&#123; target: function() &#123; return _this.$refs['sncode'+ _this.index] &#125; &#125;); // &#125; this.domPoint('KZQ003001','点击复制券码'); clipboard.on('success', function() &#123; // console.log(_this.text) _this.$toast.show(&#123; text: '复制成功', type: 'success' &#125;); // clipboard.destroy(); &#125;); clipboard.on('error', function() &#123; _this.$toast.show(&#123;text: '复制失败', type: 'fail'&#125;); &#125;);&#125; 问题3 动画按顺序执行问题描述：(问题的背景，出现场景)项目中遇到，一次可能走2段或多段弧线的问题，如果一次循环执行运动函数，那么会执行跳到最后一段弧线初始位置并执行动画，前面的弧线没有动画效果？1234567// draw 是每段曲线的运动函数 let arr = this.points.slice(currentSiteIndex, targetSiteIndex); const lastIndex = arr.length - 1, self = this; arr = arr.forEach((item, index) =&gt; &#123; draw.apply(self, [...item,150,20,true])(3) &#125;) 解决方案（代码，截图）采用动画队列的思想，前面弧线运动动画执行完后，再执行数组队列中的下一段弧线。123456789// nextRunfunction nextRun(self,arr,index) &#123; let point = arr[index]; draw.apply(self,point)(3)&#125;// draw 动画执行完，判断if (index &lt;= self.toRunPoints.length-1) &#123; nextRun(self,self.toRunPoints,index)&#125; 1234567891011121314151617181920212223 // 根据起点查找弧线，执行runCar(currentSiteIndex, targetSiteIndex) &#123; let arr = this.points.slice(currentSiteIndex, targetSiteIndex); const lastIndex = arr.length - 1, self = this; arr = arr.map((item, index) =&gt; &#123; if (targetSiteIndex == 12 &amp;&amp; index == lastIndex) &#123; /* * 需要判断最后一段弧线 * draw.apply(self, [...item,150,20,true])(3) */ item = [...item, index, 150, 20, true]; &#125; else &#123; item = [...item, index]; // draw.apply(self,[item)(3) &#125; return item; &#125;); this.toRunPoints = arr; // 动画按队列执行 nextRun(self, arr, 0);&#125; 问题4 Http 转态为0问题描述：(问题的背景，出现场景)开车了项目‘看咨询添加加速机会’，需要跳转页面，inituer接口没有完成，导致加速机会没有及时刷新？ 解决方案（代码，截图）initUser接口的状态码为0，是ajax的send没有执行，所以我们需要等咨询请求完成后，再跳转页面和initUser() 12345678910111213141516171819202122 // 看资讯showInfomation(str) &#123; const self = this; getInfomation().then(res =&gt; &#123; const &#123;code, msg&#125; = res; if (code == 0) &#123; // 初始化 self.initUser(1).then(()=&gt;&#123; window.location.href = 'https://owner.car.cmbchina.biz/information-h5/details.html?informationId=MAZcLgfZ&amp;popup=true'; &#125;); &#125; else &#123; window.location.href = 'https://owner.car.cmbchina.biz/information-h5/details.html?informationId=MAZcLgfZ&amp;popup=true'; self.$toast.show(&#123;text: msg, type: 'fail'&#125;); &#125; &#125;); if (str!='isnpc') &#123; self.domPoint('KZQ001004','点击看资讯'); &#125;&#125; 问题5 原生audio在苹果手机不能成功播放问题描述：(问题的背景，出现场景)开车了项目要播放‘小车’运动时的背景音乐，使用原生的audio标签在苹果手机中兼容问题。 解决方案（代码，截图）使用soundjs插件播放音频，注意soundjs与mock数据冲突。具体代码：12&lt;title&gt;点亮回家路&lt;/title&gt;&lt;script src="https://operation-kaichela.srv.cmbchina.biz/sound.min.js"&gt;&lt;/script&gt; 123456789101112131415// 注册音频mounted() &#123; window.createjs.Sound.alternateExtensions = ['mp3']; window.createjs.Sound.on('fileload', function() &#123; console.log('sound ok') &#125;, this); window.createjs.Sound.registerSound(require('../../public/car_music.mp3'), 'carMusic'); // window.createjs.Sound.registerSound(require('../assets/media/btn_music.mp3'), 'btnMusic',1); &#125;// 播放 carPlay() &#123; this.instance = window.createjs.Sound.play('carMusic'); this.instance.volume = 1; &#125; 项目心得/改进/建议（个人或团队）开车了小结 项目前期多花些时间，梳理，确认需求，团队应加强沟通，完善好客户的需求，也方便后期的测试。 对项目有一个概览，对于数据状态的管理需要认真思考，可和同事交流，让代码结构灵活一些，以便后期应对需求改动的情况。 经过了开车了项目的开发，我对h5嵌套页面这种开发模式有了一定的了解，但是许多地方还是一知半解，比如分享链接参数的传递，首先请求接口获取参数，拼接在链接上，通过微信分享，点击链接，会进入后端，后端重新获取参数，再重定向到前端页面。。。 这一系列流程，还是有些不理解，希望在后面的开发过程中，能理解这套方案。 项目中遇到以前没有用到的插件，可向导师求助，了解基本用法。如果在使用中，出现bug，一定要去官网查看相关API，搜索博客找到API的用法，我在项目中遇到使用clipboardjs多个按钮复制文本相同的问题，就是结合官网和博客解决的。 前期的话要规划好项目的状态管理，比如项目中有许多弹框，在开车了中有10个左右的弹框，每个弹框都需要一个变量记录其显示与隐藏的状态，并且全部在 home.vue组件中维护，通过sync层层传递到home.vue步骤很繁琐，后面的项目中会尝试在vuex中配置一个弹框字段的对象dialogConfig，每个弹框都有对应的字符串，再使用一个变量isDialogShow来取dialogConfig相应的字段，如果字符相同弹框就显示，isDialogShow直接设置为空就可以让弹框隐藏。 王者荣耀小结 基本了解了分享助力带参数的流程。首先，前端调用初始化接口获取到自己的userId，然后在微信分享链接后面传自己的userId给后台；用户点击分享链接，后端会重定向到前端的wxIndex.vue微信落地页，这里我们可以从url上面截取到 帮我助力的helpId和微信图像等信息，再通过短链拼接将helpId和微信图像等信息传给后台，后台再次重定向再App首页 ，前端就可以截取到helpId并通过助力接口传给后台，判断助力情况。 了解了唤醒登录和微信禁止分享功能，代码块已收藏到为知笔记。]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不受控制的 position:fixed]]></title>
    <url>%2F2019%2F09%2F07%2F%E4%B8%8D%E5%8F%97%E6%8E%A7%E5%88%B6%E7%9A%84-position-fixed%2F</url>
    <content type="text"><![CDATA[场景 最近在一个活动H5页面中，使用了translate3d技术来移动‘小车’，实现的效果在移动端测试还不错，小车按着规定的曲线，不急不慢的运动着，一切都是完美的。然而，问题来了，我后面加上的任务栏，明明是fixed相对屏幕定位，竟然在小车运动的时候，跟着背景图滚动，我的心也跟着了。。。 抱着万事找度娘的想法，我开始了网上冲浪之旅。终于，找了fixed定位失效的场景。 失效的 position:fixed 首先MDN 用一句话概括了这种情况： 当元素祖先的 transform 属性非 none 时，定位容器由视口改为该祖先。 通俗的讲就是指定了 position:fixed 的元素，如果其祖先元素存在非 none 的 transform 值 ，那么该元素将相对于设定了 transform 的祖先元素进行定位。 那么，为什么会发生这种情况呢？说好的相对视口（Viewport）定位呢？继续百度后，发现了堆叠上下文的概念（Stacking Context） 任何非 none 的 transform 值都会导致一个堆叠上下文（Stacking Context）和包含块（Containing Block）的创建。 由于堆叠上下文的创建，该元素会影响其子元素的固定定位。设置了 position:fixed 的子元素将不会基于 viewport 定位，而是基于这个父元素。 Stacking Context – 堆叠上下文堆叠上下文是 HTML 元素的三维概念，这些 HTML 元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的 z 轴上延伸，HTML 元素依据其自身属性按照优先级顺序占用层叠上下文的空间。简单理解，就是生成了 Stacking Context 的元素会影响该元素的层叠关系与定位关系。 按照上面的说法，堆叠上下文的创建，该元素会影响其子元素的固定定位。设置了 position:fixed 的子元素将不会基于 viewport 定位，而是基于这个父元素。 那么问题来了，是否所有能够生成堆叠上下文的元素，都会使得其子元素的 position:fixed 相对它，而不是相对视口（Viewport）进行定位呢？ ##创建堆叠上下文的方式 首先要找到所有能够使元素生成堆叠上下文的方法。如何触发一个元素形成 堆叠上下文 ？方法如下（参考自 MDN）根元素 (HTML), z-index 值不为 “auto”的 绝对/相对定位， 一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex， opacity 属性值小于 1 的元素（参考 the specification for opacity）， transform 属性值不为 “none”的元素， mix-blend-mode 属性值不为 “normal”的元素， filter值不为“none”的元素， perspective值不为“none”的元素， isolation 属性被设置为 “isolate”的元素，position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值 -webkit-overflow-scrolling 属性被设置 “touch”的元素 小结 在最新的 Blink 内核下，发现并不是所有能够生成层叠上下文的元素都会使得 position:fixed 失效，但也不止 transform 会使 position:fixed 失效。所以，MDN 关于 position:fixed 的补充描述不够完善。下述 3 种方式目前都会使得 position:fixed 定位的基准元素改变（本文重点）： transform 属性值不为 none 的元素 perspective 值不为 none 的元素 在 will-change 中指定了任意 CSS 属性]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue递归组件]]></title>
    <url>%2F2019%2F08%2F25%2Fvue%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[递归组件与动态组件递归组件递归组件就是指组件在模板中调用自己，开启递归组件的必要条件，就是在组件中设置一个 name 选项。比如下面的示例： 12345678910&lt;template&gt; &lt;div&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;my-component&apos; &#125;&lt;/script&gt; 在 Webpack 中导入一个 Vue.js 组件，一般是通过 import myComponent from &#39;xxx&#39; 这样的语法，然后在当前组件（页面）的 components: { myComponent } 里注册组件。这种组件是不强制设置 name 字段的，组件的名字都是使用者在 import 进来后自定义的，但递归组件的使用者是组件自身，它得知道这个组件叫什么，因为没有用 components 注册，所以 name 字段就是必须的了。除了递归组件用 name，也会通过遍历匹配组件的 name 选项来寻找组件实例。不过呢，上面的示例是有问题的，如果直接运行，会抛出 max stack size exceeded 的错误，因为组件会无限递归下去，死循环。解决这个问题，就要给递归组件一个限制条件，一般会在递归组件上用 v-if 在某个地方设置为 false 来终结。比如我们给上面的示例加一个属性 count，当大于 5 时就不再递归： 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;my-component :count=&quot;count + 1&quot; v-if=&quot;count &lt;= 5&quot;&gt;&lt;/my-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;my-component&apos;, props: &#123; count: &#123; type: Number, default: 1 &#125; &#125; &#125;&lt;/script&gt; 所以，实现一个递归组件的必要条件是： 要给组件设置 name； 要有一个明确的结束条件 动态组件有的时候，我们希望根据一些条件，动态地切换某个组件，或动态地选择渲染某个组件。Vue.js 提供了另外一个内置的组件 &lt;component&gt; 和 is 特性，可以更好地实现动态组件。 先来看一个 &lt;component&gt; 和 is 的基本示例，首先定义三个普通组件： 1234567891011&lt;!-- a.vue --&gt;&lt;template&gt; &lt;div&gt; 组件 A &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt; 1234567891011&lt;!-- b.vue --&gt;&lt;template&gt; &lt;div&gt; 组件 B &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt; 1234567891011&lt;!-- c.vue --&gt;&lt;template&gt; &lt;div&gt; 组件 C &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt; 然后在父组件中导入这 3 个组件，并动态切换： 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;handleChange(&apos;A&apos;)&quot;&gt;显示 A 组件&lt;/button&gt; &lt;button @click=&quot;handleChange(&apos;B&apos;)&quot;&gt;显示 B 组件&lt;/button&gt; &lt;button @click=&quot;handleChange(&apos;C&apos;)&quot;&gt;显示 C 组件&lt;/button&gt; &lt;component :is=&quot;component&quot;&gt;&lt;/component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import componentA from &apos;../components/a.vue&apos;; import componentB from &apos;../components/b.vue&apos;; import componentC from &apos;../components/c.vue&apos;; export default &#123; data () &#123; return &#123; component: componentA &#125; &#125;, methods: &#123; handleChange (component) &#123; if (component === &apos;A&apos;) &#123; this.component = componentA; &#125; else if (component === &apos;B&apos;) &#123; this.component = componentB; &#125; else if (component === &apos;C&apos;) &#123; this.component = componentC; &#125; &#125; &#125; &#125;&lt;/script&gt; 这里的 is 动态绑定的是一个组件对象（Object），它直接指向 a / b / c 三个组件中的一个。除了直接绑定一个 Object，还可以是一个 String，比如标签名、组件名。下面的这个组件，将原生的按钮 button 进行了封装，如果传入了 prop: to，那它会渲染为一个 &lt;a&gt; 标签，用于打开这个链接地址，如果没有传入 to，就当作普通 button 使用。来看下面的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- button.vue --&gt;&lt;template&gt; &lt;component :is=&quot;tagName&quot; v-bind=&quot;tagProps&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/component&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; // 链接地址 to: &#123; type: String, default: &apos;&apos; &#125;, // 链接打开方式，如 _blank target: &#123; type: String, default: &apos;_self&apos; &#125; &#125;, computed: &#123; // 动态渲染不同的标签 tagName () &#123; return this.to === &apos;&apos; ? &apos;button&apos; : &apos;a&apos;; &#125;, // 如果是链接，把这些属性都绑定在 component 上 tagProps () &#123; let props = &#123;&#125;; if (this.to) &#123; props = &#123; target: this.target, href: this.to &#125; &#125; return props; &#125; &#125; &#125;&lt;/script&gt; 使用组件： 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;i-button&gt;普通按钮&lt;/i-button&gt; &lt;br&gt; &lt;i-button to=&quot;https://juejin.im&quot;&gt;链接按钮&lt;/i-button&gt; &lt;br&gt; &lt;i-button to=&quot;https://juejin.im&quot; target=&quot;_blank&quot;&gt;新窗口打开链接按钮&lt;/i-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import iButton from &apos;../components/a.vue&apos;; export default &#123; components: &#123; iButton &#125; &#125;&lt;/script&gt; 最终会渲染出一个原生的 &lt;button&gt; 按钮和两个原生的链接 &lt;a&gt;。 再回到第一个 a / b / c 组件切换的示例，如果这类的组件，频繁切换，事实上组件是会重新渲染的，比如我们在组件 A 里加两个生命周期： 12345678910111213141516&lt;!-- a.vue --&gt;&lt;template&gt; &lt;div&gt; 组件 A &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted () &#123; console.log(&apos;组件创建了&apos;); &#125;, beforeDestroy () &#123; console.log(&apos;组件销毁了&apos;); &#125; &#125;&lt;/script&gt; 只要切换到 A 组件，mounted 就会触发一次，切换到其它组件，beforeDestroy 也会触发一次，说明组件再重新渲染，这样有可能导致性能问题。为了避免组件的重复渲染，可以在 &lt;component&gt; 外层套一个 Vue.js 内置的 &lt;keep-alive&gt; 组件，这样，组件就会被缓存起来： 123&lt;keep-alive&gt; &lt;component :is=&quot;component&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 这时，只有 mounted 触发了，如果不离开当前页面，切换到其它组件，beforeDestroy 不会被触发，说明组件已经被缓存了。 keep-alive 还有一些额外的 props 可以配置： include：字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude：字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max：数字。最多可以缓存多少组件实例。 异步组件还有一类是异步组件，事实上异步组件我们用的很多，比如 router 的配置列表，一般都是用的异步组件形式： 1234&#123; path: &apos;/form&apos;, component: () =&gt; import(&apos;./views/form.vue&apos;)&#125; 这样每个页面才会在路由到时才加载对应的 JS 文件，否则入口文件会非常庞大。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的构造器-extend]]></title>
    <url>%2F2019%2F08%2F20%2FVue%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8-extend%2F</url>
    <content type="text"><![CDATA[Vue 的构造器——extend 与手动挂载——$mount我们来看看Vue.js 内置但却不常用的 API——extend 和 $mount，它们经常一起使用。不常用，是因为在业务开发中，基本没有它们的用武之地，但在独立组件开发时，在一些特定的场景它们是至关重要的。 使用场景我们在写 Vue.js 时，不论是用 CDN 的方式还是在 Webpack 里用 npm 引入的 Vue.js，都会有一个根节点，并且创建一个根实例，比如： 12345678&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const app = new Vue(&#123; el: &apos;#app&apos; &#125;);&lt;/script&gt; Webpack 也类似，一般在入口文件 main.js 里，最后会创建一个实例： 1234567import Vue from &apos;vue&apos;;import App from &apos;./app.vue&apos;;new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App)&#125;); 因为用 Webpack 基本都是前端路由的，它的 html 里一般都只有一个根节点 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;，其余都是通过 JavaScript 完成，也就是许多的 Vue.js 组件（每个页面也是一个组件）。 有了初始化的实例，之后所有的页面，都由 vue-router 帮我们管理，组件也都是用 import 导入后局部注册（也有在 main.js 全局注册的），不管哪种方式，组件（或页面）的创建过程我们是无需关心的，只是写好 .vue 文件并导入即可。这样的组件使用方式，有几个特点： 所有的内容，都是在 #app 节点内渲染的； 组件的模板，是事先定义好的； 由于组件的特性，注册的组件只能在当前位置渲染。 比如你要使用一个组件 &lt;i-date-picker&gt;，渲染时，这个自定义标签就会被替换为组件的内容，而且在哪写的自定义标签，就在哪里被替换。换句话说，常规的组件使用方式，只能在规定的地方渲染组件，这在一些特殊场景下就比较局限了，例如： 组件的模板是通过调用接口从服务端获取的，需要动态渲染组件； 实现类似原生 window.alert() 的提示框组件，它的位置是在 &lt;body&gt; 下，而非 &lt;div id=&quot;app&quot;&gt;，并且不会通过常规的组件自定义标签的形式使用，而是像 JS 调用函数一样使用。 一般来说，在我们访问页面时，组件就已经渲染就位了，对于场景 1，组件的渲染是异步的，甚至预先不知道模板是什么。对于场景 2，其实并不陌生，在 jQuery 时代，通过操作 DOM，很容易就能实现，你可以沿用这种思路，只是这种做法不那么 Vue，既然使用 Vue.js 了，就应该用 Vue 的思路来解决问题。对于这两种场景，Vue.extend 和 vm.$mount 语法就派上用场了。 用法我们说到，创建一个 Vue 实例时，都会有一个选项 el，来指定实例的根节点，如果不写 el 选项，那组件就处于未挂载状态。Vue.extend 的作用，就是基于 Vue 构造器，创建一个“子类”，它的参数跟 new Vue 的基本一样，但 data 要跟组件一样，是个函数，再配合 $mount ，就可以让组件渲染，并且挂载到任意指定的节点上，比如 body。 比如上文的场景，就可以这样写： 12345678910import Vue from &apos;vue&apos;;const AlertComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;, data () &#123; return &#123; message: &apos;Hello, Aresn&apos; &#125;; &#125;,&#125;); 这一步，我们创建了一个构造器，这个过程就可以解决异步获取 template 模板的问题，下面要手动渲染组件，并把它挂载到 body 下： 1const component = new AlertComponent().$mount(); 这一步，我们调用了 $mount 方法对组件进行了手动渲染，但它仅仅是被渲染好了，并没有挂载到节点上，也就显示不了组件。此时的 component 已经是一个标准的 Vue 组件实例，因此它的 $el 属性也可以被访问： 1document.body.appendChild(component.$el); 当然，除了 body，你还可以挂载到其它节点上。 $mount 也有一些快捷的挂载方式，以下两种都是可以的： 1234// 在 $mount 里写参数来指定挂载的节点new AlertComponent().$mount(&apos;#app&apos;);// 不用 $mount，直接在创建实例时指定 el 选项new AlertComponent(&#123; el: &apos;#app&apos; &#125;); 实现同样的效果，除了用 extend 外，也可以直接创建 Vue 实例，并且用一个 Render 函数来渲染一个 .vue 文件： 123456789101112131415import Vue from &apos;vue&apos;;import Notification from &apos;./notification.vue&apos;;const props = &#123;&#125;; // 这里可以传入一些组件的 props 选项const Instance = new Vue(&#123; render (h) &#123; return h(Notification, &#123; props: props &#125;); &#125;&#125;);const component = Instance.$mount();document.body.appendChild(component.$el); 这样既可以使用 .vue 来写复杂的组件（毕竟在 template 里堆字符串很痛苦），还可以根据需要传入适当的 props。渲染后，如果想操作 Render 的 Notification 实例，也是很简单的： 1const notification = Instance.$children[0]; 因为 Instance 下只 Render 了 Notification 一个子组件，所以可以用 $children[0] 访问到。 需要注意的是，我们是用 $mount 手动渲染的组件，如果要销毁，也要用 $destroy 来手动销毁实例，必要时，也可以用 removeChild 把节点从 DOM 中移除。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件通信-广播与派发]]></title>
    <url>%2F2019%2F08%2F15%2FVue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-%E5%B9%BF%E6%92%AD%E4%B8%8E%E6%B4%BE%E5%8F%91%2F</url>
    <content type="text"><![CDATA[组件的通信 2：派发与广播 dispatch 和 broadcast 方法provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。然后有两种场景它不能很好的解决： 父组件向子组件（支持跨级）传递数据； 子组件向父组件（支持跨级）传递数据。 这种父子（含跨级）传递数据的通信方式，Vue.js 并没有提供原生的 API 来支持，而是推荐使用大型数据状态管理工具 Vuex，而我们之前已经介绍过 Vuex 的场景与在独立组件（或库）中使用的限制。我们可采用已经废弃的apidispatch 和 broadcast实现父子组件间通信的方法 $on 与 $emit$emit 会在当前组件实例上触发自定义事件，并传递一些参数给监听器的回调，一般来说，都是在父级调用这个组件时，使用 @on 的方式来监听自定义事件的，比如在子组件中触发事件： 12345678// child.vue，部分代码省略export default &#123; methods:&#123; handleEmitEvent ()&#123; this.$emit(&apos;test&apos;,&apos;hello vue.js&apos;) &#125; &#125;&#125; 在父组件中监听由 child.vue 触发的自定义事件 test： 12345678910111213&lt;!-- parent.vue，部分代码省略--&gt;&lt;template&gt; &lt;child-component @test="handleEvent"&gt;&lt;/child-component&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; handleEvent (text)&#123; console.log(text) // hello vue.js &#125; &#125;&#125;&lt;/script&gt; 这里是在父组件 parent.vue 中绑定的自定义事件 test 的处理句柄，然而事件 test 并不是在父组件上触发的，而是在子组件 child.vue 里触发的，只是通过 v-on 在父组件中监听。既然是子组件自己触发的，那它自己也可以监听到，这就要使用 $on 来监听实例上的事件，换言之，组件使用 $emit 在自己实例上触发事件，并用 $on 监听它。 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;button @click="handleEmitEvent"&gt;触发自定义事件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export defalut &#123; methods: &#123; handleEmitEvent ()&#123; // 在当前组件上触发自定义事件 test，并传值 this.$emit('test', 'Hello Vue.js') &#125; &#125;, mounted ()&#123; // 监听自定义事件 test this.$on('test', (text)=&gt;&#123; window.$alert(text) &#125;) &#125; &#125;&lt;/script&gt; $on 监听了自己触发的自定义事件 test，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。虽然看起有些多余，因为大可在 handleEmitEvent 里直接写 window.alert(text) 之所以多此一举，是因为 handleEmitEvent 是当前组件内的 &lt;button&gt; 调用的，如果这个方法不是它自己调用，而是其它组件调用的，那么就可以在其他组件改变这个组件的状态。 Vue.js 1.x 的 $dispatch 与 $broadcast在 Vue.js 1.x 中，提供了两个方法：$dispatch 和 $broadcast ，前者用于向上级派发事件，只要是它的父级（一级或多级以上），都可以在组件内通过 $on （或 events，2.x 已废弃）监听到，后者相反，是由上级向下级广播事件的。 12345678910111213&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;button @click="handleDispatch"&gt;派发事件&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; handleDispatch ()&#123; this.$dispatch('test','Hello, Vue.js') &#125; &#125;&#125;&lt;/script&gt; 12345678910111213&lt;!-- 父组件，部分代码省略 --&gt;&lt;template&gt; &lt;child-component&gt;&lt;/child-component&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted ()&#123; this.$on('test',(text)=&gt;&#123; console.log(text); // Hello, Vue.js &#125;) &#125; &#125;&lt;/script&gt; $broadcast 类似，只不过方向相反。这两种方法一旦发出事件后，任何组件都是可以接收到的，就近原则，而且会在第一次接收到后停止冒泡，除非返回 true。知道了 $dispatch 和 $broadcast 的前世今生，我们可以尝试 Vue.js 2.x 中自行实现这两个方法。 自行实现 dispatch 和 broadcast 方法通过目前已知的信息，我们要实现的 dispatch 和 broadcast 方法，将具有以下功能： 在子组件调用 dispatch 方法，向上级指定的组件实例（最近的）上触发自定义事件，并传递数据，且该上级组件已预先通过 $on 监听了这个事件； 相反，在父组件调用 broadcast 方法，向下级指定的组件实例（最近的）上触发自定义事件，并传递数据，且该下级组件已预先通过 $on 监听了这个事件。 实现这对方法的关键点在于，如何正确地向上或向下找到对应的组件实例，并在它上面触发方法。因为 Vue.js 内置的方法，才是以 $ 开头的，比如 $nextTick、$emit 等，为了避免不必要的冲突并遵循规范，这里的 dispatch 和 broadcast 方法名前不加 $。并且该方法可能在很多组件中都会使用，复用起见，我们封装在混合（mixins）里。那它的使用样例可能是这样的： 1234567891011121314// 部分代码省略import Emitter from '../mixins/emitter.js'export default &#123; mixins: [ Emitter ], methods: &#123; handleDispatch () &#123; this.dispatch(); // ① 三个参数 componentName, eventName, params &#125;, handleBroadcast () &#123; this.broadcast(); // ② &#125; &#125;&#125; 实现这对方法的关键点在于准确地找到组件实例。那在寻找组件实例上，我们的“惯用伎俩”就是通过遍历来匹配组件的 name 选项，在独立组件（库）里，每个组件的 name 值应当是唯一的，name 主要用于递归组件。 emitter.js 的代码：12345678910111213141516171819202122232425262728293031323334function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; const name = child.$options.name; if(name == componentName)&#123; child.$emit.apply(child,[eventName].concat(params)) &#125;else &#123; broadcast.apply(child,[componentName,eventName].concat(params)) &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName,eventName,params)&#123; let parent = this.$parent || this.$root; let name = parent.$options.name; while(parent &amp;&amp; (!name || name != componentName))&#123; parent = parent.$parent; if(parent)&#123; name = parent.$options.name &#125; &#125; if(parent)&#123; parent.$emit.apply(parent,[eventName].concat(params)) &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125; 因为是用作 mixins 导入，所以在 methods 里定义的 dispatch 和 broadcast 方法会被混合到组件里，自然就可以用 this.dispatch 和 this.broadcast 来使用。 这两个方法都接收了三个参数，第一个是组件的 name 值，用于向上或向下递归遍历来寻找对应的组件，第二个和第三个就是上文分析的自定义事件名称和要传递的数据。 可以看到，在 dispatch 里，通过 while 语句，不断向上遍历更新当前组件（即上下文为当前调用该方法的组件）的父组件实例（变量 parent 即为父组件实例），直到匹配到定义的 componentName 与某个上级组件的 name 选项一致时，结束循环，并在找到的组件实例上，调用 $emit 方法来触发自定义事件 eventName。broadcast 方法与之类似，只不过是向下遍历寻找。 来看一下具体的使用方法。有 A.vue 和 B.vue 两个组件，其中 B 是 A 的子组件，中间可能跨多级，在 A 中向 B 通信： 1234567891011121314151617&lt;!-- A.vue --&gt;&lt;template&gt; &lt;button @click="handleClick"&gt;&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import Emitter from '../mixins/emitter.js' export default &#123; name: 'componentA', mixins: [Emitter], methods: &#123; handleClick ()&#123; this.broadcast('componentB','on-message','Hello Vue.js') &#125; &#125; &#125;&lt;/script&gt; 123456789101112// B.vueexport default &#123; name: 'componentB', created ()&#123; this.$on('on-message',this.showMessage) &#125;, methods: &#123; showMessage (text) &#123; window.alert(text); &#125; &#125;&#125; 同理，如果是 B 向 A 通信，在 B 中调用 dispatch 方法，在 A 中使用 $on 监听事件即可。 以上就是自行实现的 dispatch 和 broadcast 方法, 相比Vue.js 1.x，有以下不同： 需要额外传入组件的 name 作为第一个参数； 无冒泡机制； 第三个参数传递的数据，只能是一个（较多时可以传入一个对象），而 Vue.js 1.x 可以传入多个参数，当然，你对 emitter.js 稍作修改，也能支持传入多个参数，只是一般场景传入一个对象足以。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信3-findComponent系列方法]]></title>
    <url>%2F2019%2F08%2F11%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A13-findComponent%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[组件的通信 3：找到任意组件实例——findComponents 系列方法provide / inject 和 dispatch / broadcast。它们有各自的使用场景和局限，比如前者多用于子组件获取父组件的状态，后者常用于父子组件间通过自定义事件通信。 findComponents 系列方法，它并非 Vue.js 内置，而是需要自行实现，以工具函数的形式来使用，它是一系列的函数，可以说是组件通信的终极方案。findComponents 系列方法最终都是返回组件的实例，进而可以读取或调用该组件的数据和方法。 5 个不同的函数: 由一个组件，向上找到最近的指定组件； 由一个组件，向上找到所有的指定组件； 由一个组件，向下找到最近的指定组件； 由一个组件，向下找到所有指定的组件； 由一个组件，找到指定组件的兄弟组件。 实现5 个函数的原理，都是通过递归、遍历，找到指定组件的 name 选项匹配的组件实例并返回。 向上找到最近的指定组件——findComponentUpward123456789101112131415// assist.js// 由一个组件，向上找到最近的指定组件function findComponentUpward (context, componentName) &#123; let parent = context.$parent; let name = parent.$options.name; while(parent &amp;&amp; (!name || [componentName].indexOf(name) &lt; 0)&#123; parent = parent.$parent; if(parent)&#123; name = parent.$options.name &#125; &#125; return parent&#125;export &#123; findComponentUpward &#125; findComponentUpward 接收两个参数，第一个是当前上下文，比如你要基于哪个组件来向上寻找，一般都是基于当前的组件，也就是传入 this；第二个参数是要找的组件的 name 。 findComponentUpward 方法会在 while 语句里不断向上覆盖当前的 parent 对象，通过判断组件（即 parent）的 name 与传入的 componentName 是否一致，直到直到最近的一个组件为止。 与 dispatch 不同的是，findComponentUpward 是直接拿到组件的实例，而非通过事件通知组件。比如下面的示例，有组件 A 和组件 B，A 是 B 的父组件，在 B 中获取和调用 A 中的数据和方法： 12345678910111213141516171819202122232425&lt;!-- component-a.vue --&gt;&lt;template&gt; &lt;div&gt; 组件 A &lt;component-b&gt;&lt;/component-b&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import componentB from './component-b.vue'; export default &#123; name: 'componentA', components: &#123; componentB &#125;, data() &#123; return &#123; name: 'Aresn' &#125; &#125;, methods: &#123; sayHello () &#123; console.log('Hello, Vue.js'); &#125; &#125; &#125;&lt;/script&gt; 123456789101112131415161718192021&lt;!-- component-b.vue --&gt;&lt;template&gt; &lt;div&gt; 组件 B &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; findComponentUpward &#125; from '../utils/assist.js'; export default &#123; name: 'componentB', mounted () &#123; const comA = findComponentUpward(this, 'componentA'); if (comA) &#123; console.log(comA.name); // Aresn comA.sayHello(); // Hello, Vue.js &#125; &#125; &#125;&lt;/script&gt; findComponentUpward 只会找到最近的一个组件实例，如果要找到全部符合要求的组件，就需要另外实现方法。 向上找到所有的指定组件——findComponentsUpward1234567891011121314// assist.js// 由一个组件，向上找到所有的指定组件function findComponentsUpward (context, componentName) &#123; let parents = []; const parent = context.$parent; if(parent)&#123; if(parent.$options.name == componentName) parents.push(parent); return parents.concat(findComponentsUpward(parent, componentName)) &#125;else&#123; return [] &#125;&#125;export &#123; findComponentsUpward &#125;;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信一provide inject]]></title>
    <url>%2F2019%2F08%2F07%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%B8%80provide-inject%2F</url>
    <content type="text"><![CDATA[组件的通信 1：provide / inject vue提供的API，ref 和 $parent / $children 在跨级通信时是有弊端的。为了解决这种跨级通信情况，我们往往会借助Bus和Vuex这些第三方库。但我们还可以借用vue 内置的 provide / inject 接口，实现无依赖的组件通信。 provide / inject provide / inject 是 Vue.js 2.2.0 版本后新增的 API，在文档中这样介绍 ： https://cn.vuejs.org/v2/api/#provide-inject 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。这与 React 的上下文特性context很相似。官网提示provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。不过建议归建议，如果你用好了，这个 API 会非常有用。 假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件。 1234567891011121314// A.vueexport default &#123; provide: &#123; name: &apos;Aresn&apos; &#125;&#125;// B.vueexport defaul &#123; inject: [&apos;name&apos;], mounted()&#123; console.log(this.name) // Aresn &#125;&#125; 在 A.vue 里，我们设置了一个 provide: name，值为 Aresn，它的作用就是将 name 这个变量提供给它的所有子组件。而在 B.vue 中，通过 inject 注入了从 A 组件中提供的 name 变量，那么在组件 B 中，就可以直接通过 this.name 访问这个变量了，它的值也是 Aresn。这就是 provide / inject API 最核心的用法。 需要注意的是： provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象,具体参照https://segmentfault.com/a/1190000019836663，那么其对象的属性还是可响应的。 所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 Aresn。 替代 Vuex在做 Vue 大型项目时，可以使用 Vuex 做状态管理，它是一个专为 Vue.js 开发的状态管理模式，用于集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 那了解了 provide / inject 的用法，下面来看怎样替代 Vuex。 使用 Vuex，最主要的目的是跨组件通信、全局数据维护、多人协同开发。需求比如有：用户的登录信息维护、通知信息维护等全局的状态和数据。 一般在 webpack 中使用 Vue.js，都会有一个入口文件 main.js，里面通常导入了 Vue、VueRouter、iView 等库，通常也会导入一个入口组件 app.vue 作为根组件。一个简单的 app.vue 可能只有以下代码： 12345678910&lt;template&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt; 使用 provide / inject 替代 Vuex，就是在这个 app.vue 文件上做文章。 app.vue 理解为一个最外层的根组件，用来存储所有需要的全局数据和状态，甚至是计算属性（computed）、方法（methods）等。因为项目中所有的组件（包含路由），它的父组件（或根组件）都是 app.vue，所以我们把整个 app.vue 实例通过 provide 对外提供。任何子组件通过injec注入app就可以直接通过this.app来访问根组件app.vue这个实例。 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; provide()&#123; return &#123; app: this &#125; &#125;, data()&#123; return &#123; &#125; &#125;, methods:&#123; &#125;&#125;&lt;/script&gt;&lt;style lang="less" &gt;&lt;/style&gt; 并且app.vue是项目的根组件，只会渲染一次（即使切换路由，app.vue也不会重新渲染），所有app.vue很适合存储一些全局的状态数据并且管理，如用户的登录信息。 app.vue，部分代码省略： 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; provide() &#123; return &#123; app: this &#125;; &#125;, data() &#123; return &#123; userInfo: null &#125;; &#125;, methods: &#123; getUserInfo() &#123; // 这里通过 ajax 获取用户信息后，赋值给 this.userInfo，以下为伪代码 $.ajax("/user/info", data =&gt; &#123; this.userInfo = data; &#125;); &#125; &#125;, mounted() &#123; this.getUserInfo(); &#125;&#125;;&lt;/script&gt;&lt;style lang="less" &gt;&lt;/style&gt; 这样，任何页面或组件，只要通过 inject 注入 app 后，就可以直接访问 userInfo 的数据了。 12345678910&lt;template&gt; &lt;div&gt; &#123;&#123; app.userInfo &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; inject: ['app'] &#125;&lt;/script&gt; 也可以调用app根组件实例方法，修改用户信息。 某个页面： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &#123;&#123; app.userInfo &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; inject: ['app'], methods: &#123; changeUserInfo () &#123; // 这里修改完用户数据后，通知 app.vue 更新，以下为伪代码 $.ajax('/user/update', () =&gt; &#123; // 直接通过 this.app 就可以调用 app.vue 里的方法 this.app.getUserInfo(); &#125;) &#125; &#125; &#125;&lt;/script&gt; 进阶技巧如果项目足够复杂，在 app.vue 里会写非常多的代码，多到结构复杂难以维护。这时可以使用 Vue.js 的混合 mixins，将不同的逻辑分开到不同的 js 文件里。比如上面的用户信息，就可以放到混合里： user.js 123456789101112131415161718export default &#123; data() &#123; return &#123; userInfo: null &#125; &#125;, methods: &#123; getUserInfo() &#123; // 这里通过 ajax 获取用户信息后，赋值给 this.userInfo，以下为伪代码 $.ajax('/user/info', (data) =&gt; &#123; this.userInfo = data; &#125;); &#125; &#125;, mounted() &#123; this.getUserInfo(); &#125;&#125; 然后在 app.vue 中混合： app.vue 123456789101112&lt;script&gt; import mixins_user from '../mixins/user.js' export default &#123; mixins: [mixins_user], data() &#123; return &#123; &#125; &#125; &#125;&lt;/script&gt; 如果使用vue 内置的API $parent 来获取组件的多层上级组件实例，可以借助计算属性： 123456789computed: &#123; form() &#123; let parent = this.$parent; while(parent.$options.name !== &apos;Form&apos; )&#123; parent = parent.$parent; &#125; return parent &#125;&#125; 前提，每个组件都可以设置 name 选项，作为组件名的标识，利用这个特点，通过向上遍历，直到找到需要的组件。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件三个API：prop、event、slot]]></title>
    <url>%2F2019%2F08%2F04%2Fvue%E7%BB%84%E4%BB%B6%E4%B8%89%E4%B8%AAAPI%EF%BC%9Aprop%E3%80%81event%E3%80%81slot%2F</url>
    <content type="text"><![CDATA[基础：Vue.js 组件的三个 API：props、event、slot 我们自己写的vue组件，通常由三部分组成：props、event、slot，这就是我们自己编写组件的API。如果开发一个通用组件，那一定要事先设计好这三部分，因为组件一旦发布，后面再修改 API 就很困难了，使用者都是希望不断新增功能，修复 bug，而不是经常变更接口。如果你阅读别人写的组件，也可以从这三个部分展开，它们可以帮助你快速了解一个组件的所有功能。 属性propsvue 父子组件是通过props进行单向的数据传递，props定义了子组件可配置的属性。写通用组件props最好是使用对象的写法，这样可以针对每个属性设置类型、默认值或自定义校验属性的值。如果直接使用props数组的用法，这样往往不够严谨，下面是一个iView的一个按钮组件&lt;i-button&gt;&lt;/i-button&gt; 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;button :class="'i-button-size'+size" :disabled="disabled"&gt;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;// 判断参数是否是其中之一function oneOf(value,validList)&#123; for (let i = 0; i &lt; validList.length; i++) &#123; if (value === validList[i]) &#123; return true; &#125; &#125; return false;&#125;export default &#123; props: &#123; size:&#123; validator (value)&#123; return oneOf(value, ['small', 'large', 'default']); &#125;, default: 'default' &#125;, disabled: &#123; type: Boolean, default: false &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="less" scoped&gt;.i-button-sizesmall&#123;&#125;.i-button-sizelarge&#123;&#125;.i-button-sizedefault&#123;&#125;&lt;/style&gt; 使用组件：12&lt;i-button size="large"&gt;&lt;/i-button&gt;&lt;i-button disabled&gt;&lt;/i-button&gt; 组件中定义了两个属性：尺寸 size 和 是否禁用 disabled。其中 size 使用 validator 进行了值的自定义验证，也就是说，从父级传入的 size，它的值必须是指定的 small、large、default 中的一个，默认值是 default，如果传入这三个以外的值，都会抛出一条警告。 要注意的是，组件里定义的 props，都是单向数据流，也就是只能通过父级修改，组件自己不能修改 props 的值，只能修改定义在 data 里的数据，非要修改，也是通过后面介绍的自定义事件通知父级，由父级来修改。 在使用组件时，也可以传入一些标准的 html 特性，比如 id、class：1&lt;i-button id=&quot;btn1&quot; class=&quot;btn-submit&quot;&gt;&lt;/i-button&gt; 这样的 html 特性，在组件内的 &lt;button&gt; 元素上会继承，并不需要在 props 里再定义一遍。这个特性是默认支持的，如果不期望开启，在组件选项里配置 inheritAttrs: false 就可以禁用了。实例属性 $attrs可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。 插槽 slot如果我们需要自定义按钮&lt;i-button&gt;添加文字内容，就要用到插槽 slot，它可以分发组件的内容，比如在上面的按钮组件中定义一个插槽：12345&lt;template&gt; &lt;button :class="'i-button-size' + size" :disabled="disabled"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/button&gt;&lt;/template&gt; 使用： 1234&lt;i-button&gt;按钮 1&lt;/i-button&gt;&lt;i-button&gt; &lt;strong&gt;按钮 2&lt;/strong&gt;&lt;/i-button&gt; 当需要多个插槽时，会用到具名 slot：123456&lt;template&gt; &lt;button :class=&quot;&apos;i-button-size&apos; + size&quot; :disabled=&quot;disabled&quot;&gt; &lt;slot name=&quot;icon&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/button&gt;&lt;/template&gt; 1234&lt;i-button&gt; &lt;i-icon slot=&quot;icon&quot; type=&quot;checkmark&quot;&gt;&lt;/i-icon&gt; 按钮 1&lt;/i-button&gt; 这样，父级内定义的内容，就会出现在组件对应的 slot 里，没有写名字的，就是默认的 slot。 自定义事件 event给组件 &lt;i-button&gt; 加一个点击事件，我们先看自定义事件 event（部分代码省略）：1234567891011121314&lt;template&gt; &lt;button @click="handleClick"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; handleClick (event) &#123; this.$emit('on-click', event); &#125; &#125; &#125;&lt;/script&gt; 通过 $emit，就可以触发自定义的事件 on-click ，在父级通过 @on-click 来监听： 1&lt;i-button @on-click="handleClick"&gt;&lt;/i-button&gt; 上面的 click 事件，是在组件内部的 &lt;button&gt; 元素上声明的，这里还有另一种方法，直接在父级声明，但为了区分原生事件和自定义事件，要用到事件修饰符 .native，所以上面的示例也可以这样写： 1&lt;i-button @click.native="handleClick"&gt;&lt;/i-button&gt; 如果不写 .native 修饰符，那上面的 @click 就是自定义事件 click，而非原生事件 click，但我们在组件内只触发了 on-click 事件，而不是 click，所以直接写 @click 会监听不到。 组件的通信一般来说，组件可以有以下几种关系： A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。组件间经常会通信，Vue.js 内置的通信手段一般有两种： ref：给元素或组件注册引用信息； $parent / $children：访问父 / 子实例。 这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据，比如下面的示例中，用 ref 来访问组件（部分代码省略）： 12345678910111213// component-aexport default &#123; data () &#123; return &#123; title: &apos;Vue.js&apos; &#125; &#125;, methods: &#123; sayHello () &#123; window.alert(&apos;Hello&apos;); &#125; &#125;&#125; 123456789101112&lt;template&gt; &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted () &#123; const comA = this.$refs.comA; console.log(comA.title); // Vue.js comA.sayHello(); // 弹窗 &#125; &#125;&lt;/script&gt; $parent 和 $children 类似，也是基于当前上下文访问父组件或全部子组件的。 这两种方法的弊端是，无法在跨级或兄弟间通信，比如下面的结构： 1234// parent.vue&lt;component-a&gt;&lt;/component-a&gt;&lt;component-b&gt;&lt;/component-b&gt;&lt;component-b&gt;&lt;/component-b&gt; 我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案 扩展阅读 Vue 组件通信之 Bus Vuex 通俗版教程]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HappyPack构建优化]]></title>
    <url>%2F2019%2F08%2F01%2FHappyPack%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是HappyPack? 作用是什么​ webpack在构建文件时，比如js，css，图片及字体时，它需要一个一个去解析和编译，不能同时处理多个任务。特别当文件数量变多后，webpack构建慢的问题会显得更为严重。因此HappyPack出现了，它能让webpack同时处理多个任务，它将任务分解给多个子进程去并发执行，子进程处理完成后再将结果发送给主进程中。 ​ HappyPack的基本原理：在webpack构建过程中，我们需要使用Loader对js，css，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大的，且这些转换操作不能并发处理文件，而是需要一个个文件进行处理，HappyPack的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间。 在配置中使用HappyPackjs/main.js 入口文件代码如下： 1234567require('../styles/main.styl');const $ = require('jquery');$('#app').html('欢迎你来我的博客');console.log('这是main.js');require('./demo1.js'); js/demo1.js 文件如下： 123export default function printMe() &#123; console.log('11111111');&#125; styles/main.styl 代码如下： 1234567@import "./index.styl"; #app font-size 18px width 200px height 200px display flex border 1PX solid #ccc styles/index.styl 代码如下： 12body font-size 12px 安装HappyPack插件1npm i -D happypack 配置HappyPack首先在webpack中引入happyPack, 如下代码： 12// 引入HappyPack插件 const HappyPack = require('happypack'); js模块默认不使用 HappyPack编译, 是如下配置： 1234567891011module.exports = &#123; module:&#123; rules:[ &#123; test:/\.js$/, loader: 'babel-loader', exclude: path.resolve(__dirname,'node_modules') &#125; ] &#125;&#125; 使用 HappyPack 配置，变成如下： 123456789101112module.exports = &#123; module:&#123; rules:[ &#123; test: /\.js$/, // 将对.js文件的处理转交给id为babel的HappyPack的实列 use: ['happypack/loader?id=babel'], exclude: path.resolve(__dirname,'node_modules') &#125; ] &#125;&#125; plugins配置如下： 1234567891011module.exports = &#123; plugins:[ /**** 使用HappyPack实例化 *****/ new HappyPack(&#123; // 用唯一的标识符id来代表当前的HappyPack 处理一类特定的文件 id: 'babel', // 如何处理.js文件，用法和Loader配置是一样的 loaders: ['babel-loader'] &#125;) ]&#125; 因此所有的webpack配置代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141const path = require('path');// 提取css的插件const ExtractTextPlugin = require('extract-text-webpack-plugin');// 清除dist目录下的文件// const ClearWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');// 引入打包html文件const HtmlWebpackPlugin = require('html-webpack-plugin');// 引入 DllReferencePluginconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');// 引入HappyPack插件 const HappyPack = require('happypack');module.exports = &#123; // 入口文件 entry:&#123; main: './js/mian.js' &#125;, output: &#123; filename: '[name].js', // 将输出的文件都放在dist目录下 path: path.resolve(__dirname, 'dist') &#125;, module:&#123; rules:[ &#123; test: /\.styl$/, use: ExtractTextPlugin.extract(&#123; fallback:&#123; loader: 'style-loader' &#125;, use:[ &#123; loader: 'css-loader', options: &#123;&#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: [ require('postcss-cssnext')(), require('cssnano')(), require('postcss-pxtorem')(&#123; rootValue: 16, unitPrecision: 5, propWhiteList: [] &#125;), require('postcss-sprites')() ] &#125; &#125;, &#123; loader: 'stylus-loader', options: &#123;&#125; &#125; ] &#125;) &#125;, &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; use: ['happypack/loader?id=css-pack'] &#125;) &#125;, &#123; test: /\.(png|jpg)$/, use: ['happypack/loader?id=image'] &#125;, &#123; test: /\.js$/, // 将对.js文件的处理转交给id为babel的HappyPack的实列 use: ['happypack/loader?id=babel'], // loader: 'babel-loader', exclude: path.resolve(__dirname, 'node_modules') // 排除文件 &#125; ] &#125;, resolve: &#123; extensions: ['*', '.js', '.json'] &#125;, devtool: 'cheap-module-eval-source-map', devServer: &#123; // contentBase: path.join(__dirname, "dist"), port: 8081, host: '0.0.0.0', headers: &#123; 'X-foo': '112233' &#125;, // hot: true, inline: true, // open: true, overlay: true, stats: 'errors-only' &#125;, mode: 'development', plugins:[ new HtmlWebpackPlugin(&#123; template: './index.html' // 模版文件 &#125;), // new ClearWebpackPlugin(['dist']), new ExtractTextPlugin(&#123; // 从js文件中提取出来的 .css文件的名称 filename: `main.css` &#125;), // 告诉webpack使用了哪些第三方库代码 new DllReferencePlugin(&#123; context: path.join(__dirname), // jquery 映射到json文件上去 manifest: require('./dist/jquery.manifest.json') &#125;), new DllReferencePlugin(&#123; context: path.join(__dirname), // echarts 映射到json文件上去 manifest: require('./dist/echarts.manifest.json') &#125;), /**** 使用HappyPack实例化 *****/ new HappyPack(&#123; // 用唯一的标识符id来代表当前的HappyPack 处理一类特定的文件 id: 'babel', // 如何处理.js文件，用法和Loader配置是一样的 loaders: ['babel-loader'] &#125;), new HappyPack(&#123; id: 'image', loaders: [&#123; loader: require.resolve('url-loader'), options: &#123; limit: 10000, name: '[name].[ext]' &#125; &#125;] &#125;), // 处理css文件 new HappyPack(&#123; id: 'css-pack', loaders: ['css-loader'] &#125;) ]&#125; 小结如上配置代码： 在Loader配置中，对所有的文件的处理都交给了happypack/loader（除了styl中使用postcss外，对这个处理貌似会报错），happypack/loader?id=xx 紧跟的id=xxx,就是告诉happy-loader选择哪个happyPack的实列处理文件。 在plugin插件配置中新增了HappyPack的实列，作用是告诉HappyPack如何处理该文件 HappyPack实列中除了有 id 和 loaders两个属性外，还有如下几个属性：threads: 代表开启几个子进程去处理这一类文件，默认是3个，必须是整数。verbose: 是否允许HappyPack输出日志，默认为true。threadPool: 代表共享进程池。即多个HappyPack实列都使用同一个共享进程池中的子进程去处理任务。以防止资源占用过多。 12345678910111213141516const HappyPack =require (’happypack’);// 构造出共享进程池，在进程池中包含 5 个子进程const happyThreadPool = HappyPack.ThreadPool(&#123; size : 5 )) ;module.exports = &#123; plugins: [ new HappyPack(&#123; // 用唯一的标识符id来代表当前的HappyPack 处理一类特定的文件 id: 'babel', // 如何处理.js文件，用法和Loader配置是一样的 loaders: ['babel-loader'], // 使用共享进程池中的子进程去处理任务。 threadPool: happyThreadPool &#125;) ]&#125;;]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dllplugin]]></title>
    <url>%2F2019%2F07%2F15%2FDllplugin%2F</url>
    <content type="text"><![CDATA[DllPlugin 在平常的项目中，我们要使用到很多的第三方库，如react 、vue 、jquery等。但是他们的内容基本是不变的，版本升级除外。而且这些库每次打包时都要重复的构建，所以我们需要把他们和我们自己写的项目源代码分开。webpack只需要打包我项目本身的文件代码，而不会再去编译第三方库，那么第三方库在第一次打包的时候只打包一次，以后只要我们不升级第三方包的时候，那么webpack就不会对这些库去打包，因此为了解决这个问题，DllPlugin 和DllReferencePlugin插件就产生了。 DLLPlugin 这个插件是在一个额外独立的webpack设置中创建一个只有dll的bundle，也就是说我们在项目根目录下除了有webpack.config.js，还会新建一个webpack.dll.config.js文件。webpack.dll.config.js作用是把所有的第三方库依赖打包到一个bundle的dll文件里面，还会生成一个名为 manifest.json文件。该manifest.json的作用是用来让 DllReferencePlugin 映射到相关的依赖上去的。 DllReferencePlugin 这个插件是在webpack.config.js中使用的，该插件的作用是把刚刚在webpack.dll.config.js中打包生成的dll文件引用到需要的预编译的依赖上来。 webpack.dll.config.js在项目根目录下创建一个 `webpack.dll.config.js` 文件。然后配置代码如下： 1234567891011121314151617181920212223242526272829303132333435const path = require('path')const DllPlugin = require('webpack/lib/DllPlugin')module.exports = &#123; entry:&#123; // 项目中用到该两个依赖库文件 react: ['react'], reactDom: ['react-dom'], loadsh: ['loadsh'] &#125;, output:&#123; // 文件名称 filename: '[name].dll.js', // 将输出的文件放到dist目录下 path: path.resolve(__dirname,'dist/dll'), /* 存放相关的dll文件的全局变量名称，比如对于jquery来说的话就是 _dll_jquery, 在前面加 _dll 是为了防止全局变量冲突。 */ library: '_dll_[name]' &#125;, plugins:[ // 使用插件 DllPlugin /* 该插件的name属性值需要和 output.library保存一致，该字段值，也就是输出的 manifest.json文件中name字段的值。 比如在jquery.manifest文件中有 name: '_dll_jquery' */ new DllPlugin(&#123; name: '_dll_[name]', /* 生成manifest文件输出的位置和文件名称 */ path: path.join(__dirname, 'dist/dll', '[name].manifest.json') &#125;) ]&#125; 执行语句1webpack --config webpack.dll.config.js 生成文件目录 DllReferencePluginDllReferencePlugin项的参数有如下： context: manifest文件中请求的上下文。 manifest: 编译时的一个用于加载的JSON的manifest的绝对路径。 context: 请求到模块id的映射(默认值为 manifest.content) name: dll暴露的地方的名称(默认值为manifest.name) scope: dll中内容的前缀。 sourceType: dll是如何暴露的libraryTarget。webpack.config.js 所有代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123;CleanWebpackPlugin&#125; = require('clean-webpack-plugin');const webpack = require('webpack')// 引入 DllReferencePluginconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');module.exports = &#123; mode:'development', entry:'./index.js', output: &#123; path:path.resolve(__dirname,'dist'), // filename:'bundle.js', [name].[contenthash].js 上线生产环境使用 filename: '[name].[hash].js' // publicPath:'dist' 引入文件路径 和图片路径均变化 &#125;, devtool:'cheap-module-eval-source-map', module:&#123; rules:[ &#123; test:/\.jsx?$/, exclude: /node_modules/, loader:'babel-loader', options:&#123; // ['@babel/preset-env',&#123;useBuiltIns:'usage'&#125;] &#125; &#125;, &#123; test:/\.css$/, use:['style-loader','css-loader'] &#125;, &#123; test:/\.png|jpg|gif$/, use:[ &#123; loader:'url-loader', options:&#123; name:'images/[name].[ext]', // outputPath:'images/', limit: 1024*4, // publicPath:'dist/images' &#125;&#125; ] &#125; ] &#125;, optimization:&#123; // tree Shaking 只支持 es moudle usedExports: true, // 代码分割 splitChunks:&#123; chunks:'all', cacheGroups: &#123; vendors:false &#125; &#125; &#125;, plugins:[ new HtmlWebpackPlugin(&#123; template: './index.html' &#125;), new CleanWebpackPlugin(), // new webpack.HotModuleReplacementPlugin() 与contenthash 冲突 // 告诉webpack使用了哪些第三方库代码 new DllReferencePlugin(&#123; manifest: require('./dist/dll/reactDom.manifest.json') &#125;), new DllReferencePlugin(&#123; manifest: require('./dist/dll/react.manifest.json') &#125;), new DllReferencePlugin(&#123; manifest: require('./dist/dll/loadsh.manifest.json') &#125;) ], devServer: &#123; clientLogLevel: 'warning', historyApiFallback: true, hot: true, compress: true, host: 'localhost', port: 9000 &#125;&#125;]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weakMap]]></title>
    <url>%2F2019%2F07%2F12%2FweakMap%2F</url>
    <content type="text"><![CDATA[weakMap的特性及应用场景总结： 特性WeakMap 只接受对象作为键名12345const map = new WeakMap();map.set(1, 2);// TypeError: Invalid value used as weak map keymap.set(null, 2);// TypeError: Invalid value used as weak map key WeakMap 的键名所引用的对象是弱引用​ WeakMaps 保持了对键名所引用的对象的弱引用。在计算机程序中弱引用和强应用是相对的，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 在JavaScript中，一般我们创建的对象，都是强引用； 1var obj = new Object(); 只有当我们手动设置为null时，才会回收obj 如果创建一个弱引用对象： 12// 假设可以这样创建一个var obj = new WeakObject(); 那么垃圾回收机制执行时，obj所引用的对象会被回收。 正常情况： 1234const key = new Array(5 * 1024 * 1024);const arr = [ [key, 1]]; 使用这种方式，我们其实建立了 arr 对 key 所引用的对象(我们假设这个真正的对象叫 Obj)的强引用。所以当你设置 key = null 时，只是去掉了 key 对 Obj 的强引用，并没有去除 arr 对 Obj 的强引用，所以 Obj 还是不会被回收掉。Map 类型也是类似： 1234567let map = new Map();let key = new Array(5 * 1024 * 1024);// 建立了 map 对 key 所引用对象的强引用map.set(key, 1);// key = null 不会导致 key 的原引用对象被回收key = null; 如果你想要让 Obj 被回收掉，你需要先 delete(key) 然后再 key = null: 12345let map = new Map();let key = new Array(5 * 1024 * 1024);map.set(key, 1);map.delete(key);key = null; WeakMaps 保持了对键名所引用的对象的弱引用: 1234const wm = new WeakMap();let key = new Array(5 * 1024 * 1024);wm.set(key, 1);key = null; 当设置 wm.set(key, 1) 时，其实建立了 wm 对 key 所引用的对象的弱引用，但因为 let key = new Array(5 1024 1024) 建立了 key 对所引用对象的强引用，被引用的对象并不会被回收，但是当我们设置 key = null 的时候，就只有 wm 对所引用对象的弱引用，下次垃圾回收机制执行的时候，该引用对象就会被回收掉。 因此，WeakMap 可以帮我们省掉手动删除对象关联数据的步骤。弱引用的特性，就是 WeakMaps 保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。 也正是因为这样的特性，WeakMap 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakMap 不可遍历。 所以 WeakMap 不像 Map，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有 size 属性，也不支持 clear 方法，所以 WeakMap只有四个方法可用：get()、set()、has()、delete()。 应用DOM 对象上保存相关数据​ 传统使用 jQuery ，我们通过 $.data() 方法在 DOM 对象上储存相关信息(就比如在删除按钮元素上储存帖子的 ID 信息)，jQuery 内部会使用一个对象管理 DOM 和对应的数据，当你将 DOM 元素删除，DOM 对象置为空的时候，相关联的数据并不会被删除，你必须手动执行 $.removeData() 方法才能删除掉相关联的数据，WeakMap 就可以简化这一操作： 12345678let wm = new WeakMap(), element = document.querySelector(".element");wm.set(element, "data");let value = wm.get(elemet);console.log(value); // dataelement.parentNode.removeChild(element);element = null; 数据缓存​ 在不修改原有对象的情况下储存某些属性或者根据对象储存一些计算的值等，而且又不用管理这些数据的死活时非常适合考虑使用 WeakMap。 123456789101112const cache = new WeakMap();function countOwnKeys(obj) &#123; if (cache.has(obj)) &#123; console.log('Cached'); return cache.get(obj); &#125; else &#123; console.log('Computed'); const count = Object.keys(obj).length; cache.set(obj, count); return count; &#125;&#125; 私有属性WeakMap 也可以被用于实现私有变量： 1234567891011121314151617const privateData = new WeakMap();class Person &#123; constructor(name, age) &#123; privateData.set(this, &#123; name: name, age: age &#125;); &#125; getName() &#123; return privateData.get(this).name; &#125; getAge() &#123; return privateData.get(this).age; &#125;&#125;export default Person; 原文地址(冴羽)： https://segmentfault.com/a/1190000015774465]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postCss]]></title>
    <url>%2F2019%2F07%2F06%2FpostCss%2F</url>
    <content type="text"><![CDATA[PostCss​ PostCss是一个样式处理工具，它通过自定义的插件和工具生态体系来重新定义css。这些插件可以检查（lint）你的 CSS，支持 CSS Variables 和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。插件链接 webpack中使用postcss​ 比如我们使用less来编写css代码，因此文件就是这样的文件 文件名.less了，因此该文件需要依次经过less-loader, postcss-loader css-loader, style-loader编译。因此需要如下配置： 12345678910111213141516171819202122232425module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, exclude: /node_modules/, use: [ &#123; loader: 'style-loader', &#125;, &#123; loader: 'css-loader', options: &#123; importLoaders: 1, &#125; &#125;, &#123; loader: 'postcss-loader' &#125;, "less-loader" ] &#125; ] &#125;&#125; 运行npm run dev 会报错，因为less需要安装less包支持： 1npm install less --save-dev 安装完成后，继续打包还是会有报错，命令行会提示错误No PostCSS Config found。这是项目的根目录下，我们还需要新建一个 postcss.config.js 文件，然后里面添加一个如下简单的代码即可： 1234567module.exports = &#123; plugins: [ //require('precss'), //require('autoprefixer') ]&#125;//默认不做任何处理 但是如上代码仅仅配置了postcss，但是并没有使用内部的插件，因此我们需要把对应的一些常用的插件加上，比如 autoprefixer 自动添加前缀，cssnano 压缩css代码，postcss-cssnext css的下一代，使用css4的新语法等等。先安装这几个插件吧，如下命令安装： 1npm install --save-dev autoprefixer cssnano postcss-cssnext 在postcss.config.js文件做如下配置即可： 1234567module.exports = &#123; plugins: [ require('autoprefixer')(), require('postcss-cssnext')(), require('cssnano')() ]&#125; 然后我们就可以在浏览器查看，postCss预处理的效果。 js API对于其它的应用环境，你可以使用 JS API： 12345678910111213const autoprefixer = require('autoprefixer')const postcss = require('postcss')const precss = require('precss')const fs = require('fs')fs.readFile('src/app.css', (err, css) =&gt; &#123; postcss([precss, autoprefixer]) .process(css, &#123; from: 'src/app.css', to: 'dest/app.css' &#125;) .then(result =&gt; &#123; fs.writeFile('dest/app.css', result.css) if ( result.map ) fs.writeFile('dest/app.css.map', result.map) &#125;)&#125;) 阅读 PostCSS API 文档 获取更多有关 JS API 的信息. PostCSS可以解决的问题 解决全局 CSS 的问题 提前使用先进的 CSS 特性 更佳的 CSS 可读性 图片和字体 提示器（Linters） 详情请查看 链接]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceMap]]></title>
    <url>%2F2019%2F07%2F02%2FSourceMap%2F</url>
    <content type="text"><![CDATA[什么是SourceMap?​ webpack4在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩，去掉多余的空格，且babel编译化后，最终会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发不好调式，因此sourceMap出现了，它就是为了解决不好调式代码问题。 webpack中的SourceMapeval​ eval 会将每一个module模块，执行eval，执行后不会生成sourcemap文件，仅仅是在每一个模块后，增加sourceURL来关联模块处理前后对应的关系。在webpack中配置devtool: ‘eval’ 123456789101112131415(function(modules) &#123; // webpackBootstrap "use strict"; eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() &#123; return printMe; &#125;);\n\nfunction printMe() &#123;\n console.log('11111111');\n&#125;\n\n//# sourceURL=webpack:///./js/demo1.js?"); /***/ "./js/main.js": /*!********************!*\ !*** ./js/main.js ***! \********************/ /*! no exports provided */ /***/ (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _demo1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./demo1.js */ \"./js/demo1.js\");\n\n\nconsole.log('main.js');\n\n//# sourceURL=webpack:///./js/main.js?"); &#125;)&#125;) ​ 每一个打包后的模块后面都增加了包含sourceURL的注释，sourceURL的值是压缩前存放的代码的位置，这样就通过sourceURL关联了压缩前后的代码。 优点是：打包速度非常快，因为不需要生成sourcemap文件。缺点是：由于会映射到转换后的代码，而不是映射到原始代码，所以不能正确的显示行数。 source-map​ 在webpack中配置加上 devtool: ‘source-map’ 配置完成后，source-map会为每一个打包后的模块生成独立的sourcemap文件 123"scripts": &#123; "build": "webpack --progress --colors --devtool source-map"&#125; 打包后文件： 12345678910111213141516171819202122(function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); /* harmony import */ var _demo1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./demo1.js */ "./js/demo1.js"); __webpack_require__(/*! ../styles/main.css */ "./styles/main.css"); console.log('main.js');/***/ &#125;), /***/ "./styles/main.css": /*!*************************!*\ !*** ./styles/main.css ***! \*************************/ /*! no static exports found */ /***/ (function(module, exports) &#123; // removed by extract-text-webpack-plugin /***/ &#125;) /******/ &#125;); //# sourceMappingURL=bundle.js.map 如上打包后的代码最后面一句代码是 //# sourceMappingURL=bundle.js.map ，同时在dist目录下会针对每一个模块生成响应的 .map文件。然后我们可以在谷歌开发者工具的Sources面板中，选中 Enable Javascript source maps，然后就可以进行源码错误调试。 inline（比如 inline-source-map）​ 该属性不会生成独立的 .map文件，而是将 .map文件以dataURL的形式插入。它会使得bundle.js文件变得非常大，因为它需要把 sourceMappingURL 以dataurl的形式插入到bundle.js里面去。 cheap(如：cheap-source-map)​ 该属性在打包后同样会为每一个文件模块生成 .map文件，但是与source-map的区别在于cheap生成的 map文件会忽略原始代码中的列信息，调式代码列信息没有什么用，因此使用cheap后，文件大小相对于source-map来讲，bundle.js 文件会变得更小。 module(如：cheap-module-source-map)​ 该属性的配置也是生成一个没有列的信息的sourceMaps文件，同时loader的sourcemap也被简化成为只包含对应行的。可以追踪第三方模块调试信息。 开发环境和线上环境如何选择​ 从上面的eval, inline, source-map, cheap, module中可以看到，各自属性值代表打包后的具体含义，因此我们可以分析下开发环境和正式环境要如何选择sourceMap。 源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。 不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个vue文件报错了，我们希望能定位到具体的vue文件，因此我们也需要module配置。 需要生成map文件的形式，因此我们需要增加 source-map属性。 eval打包后的速度非常快，因为它不生成map文件，但是会将map文件以DataURL的形式存在打包后的js文件中，增大文件体积，可以在开发环境使用。 开发环境123module.exports = &#123; devtool: 'cheap-module-eval-source-map'&#125; 生成环境 123module.exports = &#123; devtool: 'cheap-module-source-map';&#125;]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-babelrc]]></title>
    <url>%2F2019%2F06%2F27%2Fwebpack-babelrc%2F</url>
    <content type="text"><![CDATA[.babelrc的基本配置​ ES6引入了新的语法和API，使我们编写js代码更加得心应手，比如class，let,for…of promise等等这样的，但是这些js新特性只被最新版本的浏览器支持，低版本浏览器并不支持，babel可以把es6代码转换成低版本浏览器能识别的代码。可以理解为 babel是javascript语法的编译器。 Babel编译器​ 在Babel执行编译的过程中，会从项目的根目录下的 .babelrc文件中读取配置。.babelrc是一个json格式的文件。在.babelrc配置文件中，主要是对预设(presets) 和 插件(plugins) 进行配置。.babelrc配置文件一般为如下： 12345678910&#123; "plugins":[ ["transform-runtime",&#123;"polyfill":false&#125;] ], "presets":[ ["env",&#123;"moudules":false&#125;], "stage-2", "react" ]&#125; plugins​ 该属性是告诉babel要使用那些插件，这些插件可以控制如何转换代码，babel默认只转换新的javascript语法，而不转换新的API，比如Iterator、Promise、Set、Map等，还有Object、数组、字符串原型上新增的方法。因此我们需要使用 babel-polyfill和babel-runtime这样的插件来完成转换。 babel-polyfill 的原理是如果当前环境没有实现这些API，它会做兼容处理，向js中原有对象的原型prototype添加，但是这样做但造成一定全局污染 babel-runtime是将es6编译成es5去执行，它不会影响全局变量。但我们需要针对每个API做引用，如Promise就需要import Promise from &#39;babel-runtime/core-js/promise&#39; 但是这样手动加入会很麻烦，因此我们通常使用babel-plugin-transform-runtime 避免手动引入 import的痛苦，并且它还做了公用方法的抽离。比如说我们有100个模块都使用promise，但是promise的polyfill仅仅存在1份。 理解 babel-plugin-transform-runtime 的配置一些选项12345678910111213&#123; "plugins":[ [ "transform-runtime", &#123; "helpers": false, "polyfill": false, "regenerator": true, "moduleName": "babel-runtime" &#125; ] ]&#125; 配置项可以看官网，查看官网 helpers: 默认值为true，表示是否开启内联的babel helpers(即babel或者环境本来存在的某些对象方法函数)如：extends，etc这样的在调用模块名字时将被替换名字。 polyfill：默认值为true，表示是否把内置的东西(Promise, Set, Map)等转换成非全局污染的。 regenerator：默认值为true，是否开启generator函数转换成使用regenerator runtime来避免污染全局域。 moduleName：默认值为 babel-runtime，当调用辅助 设置模块（module）名字/路径. presets​ presets属性告诉Babel要转换的源码使用了哪些新的语法特性，presets是一组Plugins的集合。 babel-preset-envbabel针对每个版本的es语法都有对应的解决方案 babel-preset-es2015: 可以将es6的代码编译成es5.babel-preset-es2016: 可以将es7的代码编译为es6.babel-preset-es2017: 可以将es8的代码编译为es7.babel-preset-latest: 支持现有所有ECMAScript版本的新特性。 随着时间的推移，将来可能会有跟多的版本插件，于是babel-preset-env 产生了，它可以根据目标环境自己选择编译。我们只需在.babelrc文件简单配置即可 123&#123; "presets": ["env"1]&#125; babel-preset-env 中的选项配置 targets: {[string]: number | string }, 默认为{};含义是支持一个运行环境的对象，比如支持node版本；可以如下配置： node: ‘6.0’; targets.browsers 支持浏览器的配置项，该配置项使用方式可以到 browserslist来查询 modules 该参数的含义是：启用将ES6模块语法转换为另一种模块类型。将该设置为false就不会转换模块。默认为 ‘commonjs’. 其他取值’amd’ | ‘umd’ | ‘systemjs’ | ‘commonjs’ | false，一般设为false 在webpack中配置babel​ 由于babel所做的事情是转换代码，所有需要使用loader去转换，因此我们需要配置babel-loader。安装babel-loader之前，我们需要安装babel-core， 因为babel-core是Babel编译器的核心。 1npm install --save-dev babel-core 然后我们再安装 babel-loader, 命令如下： 1npm install --save-dev babel-loader 接着安装语法转换插件 babel-preset-env, babel-plugin-transform-runtime, babel-preset-stage-2, 1npm install --save-dev babel-preset-env babel-plugin-transform-runtime babel-preset-stage-2 .babelrc 配置如下即可： 12345678910111213141516171819&#123; "plugins": [ [ "transform-runtime", &#123; "polyfill": false &#125; ] ], "presets": [ [ "env", &#123; "modules": false &#125; ], "stage-2" ]&#125; webpack配置中需要添加 babel-loader 配置 1234567891011module.exports = &#123; module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules)/, // 排除文件 loader: 'babel-loader' &#125; ] &#125;&#125; 这样打包后，浏览器就可以运行es6代码了]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-devserver]]></title>
    <url>%2F2019%2F06%2F17%2Fwebpack-devserver%2F</url>
    <content type="text"><![CDATA[​ webpack-dev-server是一个使用了express的Http服务器，它的作用主要是为了监听资源文件的改变，该http服务器和client使用了websocket通信协议，只要资源文件发生改变，webpack-dev-server就会实时的进行编译。 contentBase​ 配置主要指定服务器资源的根目录，如果不手动设置的话，contentBase默认是当前的执行目录，webpack.config.js所有的根目录。 webpack配置代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path');// 提取css的插件const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: './js/main.js', output: &#123; filename: 'bundle.js', // 将输出的文件都放在dist目录下 path: path.resolve(__dirname, 'dist'), publicPath: '/dist' &#125;, mode: 'development', module: &#123; rules: [ &#123; // 使用正则去匹配要用该loader转换的css文件 test: /\.css$/, loaders: ExtractTextPlugin.extract(&#123; // 转换 .css文件需要使用的Loader use: ['css-loader'] &#125;) &#125;, &#123; test: /\.(png|jpg)$/, loader: 'url-loader', options: &#123; limit: 10000, name: '[name].[ext]' &#125; &#125; ] &#125;, resolve: &#123; // modules: ['plugin', 'js'] &#125;, plugins: [ new ExtractTextPlugin(&#123; // 从js文件中提取出来的 .css文件的名称 filename: `main.css` &#125;) ], devServer: &#123; contentBase: path.join(__dirname, "dist") &#125;&#125;; 如上配置完成后，我们再运行 npm run dev, 再在地址栏中 运行 http://localhost:8080/ 后看到bundle.js文件，服务器不再指向项目的根目录，而是dist文件夹，http://localhost:8080/bundle.js 可以访问bundle.js文件内容。 port该配置属性指定了开启服务器的端口号 123456moudle.exports = &#123; devServer:&#123; contentBase: path.join(__dirname,'dist'), post:8081 &#125;&#125; 配置完成后，运行打包命令 npm run dev ,我们就可以通过 如下地址 http://localhost:8081/ 也可以访问了 host​ 该配置项用于配置 DevServer的服务器监听地址。比如想让局域网的其他设备访问自己的本地服务，则可以在启动DevServer时带上 –host 0.0.0.0（局域网内所有的可用接口） host的默认值是 127.0.0.1（本机） 1234567moudle.exports = &#123; devServer:&#123; contentBase: path.join(__dirname,'dist'), post:8081, host: '0.0.0.0' &#125;&#125; headers​ 该配置项可以在HTTP响应中注入一些HTTP响应头,协商好的自定义响应头。 12345678910moudle.exports = &#123; devServer:&#123; contentBase: path.join(__dirname,'dist'), post:8081, host: '0.0.0.0', headers:&#123; 'X-foo':'123456' &#125; &#125;&#125; historyApiFallback​ 该配置项属性是用来应对返回404页面时定向跳转到特定页面的。一般是应用在 HTML5中History API 的单页应用，比如在访问路由时候，访问不到该路由的时候，会跳转到index.html页面。(historyApiFallback为true )； 如果需要配置详细的路径，我们可以通过正则来配置页面路由，比如访问以/user 开头的其他页面发生错误，跳转到 user.html，访问 /home 开头不存在的页面，跳转到home.html 123456789101112131415161718moudle.exports = &#123; devServer:&#123; contentBase: path.join(__dirname,'dist'), post:8081, host: '0.0.0.0', headers:&#123; 'X-foo':'123456' &#125;, //historyApiFallback: true // 为true 跳转到index.html historyApiFallback：&#123; // 使用正则来匹配路由 rewrites: [ &#123; from: /^\/user/, to: '/user.html' &#125;, &#123; from: /^\/home/, to: '/home.html' &#125; ] &#125; &#125;&#125; hot​ 该配置项是指模块替换换功能，DevServer 默认行为是在发现源代码被更新后通过自动刷新整个页面来做到实时预览的，但是开启模块热替换功能后，它是通过在不刷新整个页面的情况下通过使用新模块替换旧模块来做到实时预览的。我们可以在 devServer中 配置 hot: true 即可: 12345module.exports = &#123; devServer:&#123; hot: true &#125;&#125; 也可以在scripts命令行中配置，--hot 123456&#123; "scripts": &#123; "dev": "webpack-dev-server --progress --colors --devtool source-map --hot --inline", "build": "webpack --progress --colors" &#125;&#125; inlinewebpack-dev-server 有两种模式可以实现自动刷新和模块热替换机制。 iframe 页面是被嵌入到一个iframe页面，并且在模块变化的时候重载页面。 12345678910module.exports = &#123; devServer: &#123; port: 8081, host: '0.0.0.0', headers: &#123; 'X-foo': '112233' &#125;, inline: false &#125;,&#125; 如上代码配置 inline: false 就是使用iframe模式来重载页面了。 inline 模式 开启模式，只需要把上面的配置代码变为 inline: true即可，它在构建变化后的代码会通过代理客户端来控制网页刷新。 open该属性用于DevServer启动且第一次构建完成时，自动使用我们的系统默认浏览器去打开网页。 123456789101112module.exports = &#123; devServer: &#123; // contentBase: path.join(__dirname, "dist"), port: 8081, host: '0.0.0.0', headers: &#123; 'X-foo': '112233' &#125;, // hot: true, inline: true, open: true &#125; 当我们运行完成 npm run dev 打包的时候，会自动打开默认的浏览器来查看网页。 overlay该属性是用来在编译出错的时候，在浏览器页面上显示错误信息。该属性值默认为false，需要的话，设置该参数为true。 1234567891011121314module.exports = &#123; devServer: &#123; // contentBase: path.join(__dirname, "dist"), port: 8081, host: '0.0.0.0', headers: &#123; 'X-foo': '112233' &#125;, // hot: true, inline: true, open: true, overlay: true &#125;&#125; stats(字符串)该属性配置是用来在编译的时候再命令行中输出的内容，该属性值可以有如下值： stats: ‘none’ | ‘errors-only’ | ‘minimal’ | ‘normal’ | ‘verbose’ compress该属性是一个布尔型的值，默认为false，当他为true的时候，它会对所有服务器资源采用gzip进行压缩。 proxy 实现跨域​ 有时候我们使用webpack在本地启动服务器的时候，由于我们使用的访问的域名是 http://localhost:8081 这样的，但是我们服务端的接口是其他的，那么就存在域名或端口号跨域的情况下，但是很幸运的是 devServer有一个叫proxy配置项，可以通过该配置来解决跨域的问题. ​ 假如现在我们本地访问的域名是 http://localhost:8081, 但是我现在调用的是百度页面中的一个接口，该接口地址是：http://news.baidu.com/widget?ajax=json&amp;id=ad。现在我们只需要在devServer中的proxy的配置就可以了： 123456789101112131415161718192021222324module.exports = &#123; devServer: &#123; // contentBase: path.join(__dirname, "dist"), headers: &#123; 'X-foo': '112233' &#125;, // hot: true, port: '8081', inline: true, open: true, overlay: true, stats: 'errors-only', proxy: &#123; '/api': &#123; target: 'http://news.baidu.com', // 目标接口的域名 // secure: true, // https 的时候 使用该参数 changeOrigin: true, // 是否跨域 pathRewrite: &#123; '^/api' : '' // 重写路径 &#125; &#125; &#125; &#125;&#125; 调用接口时： 12345import axios from 'axios';axios.get('/api/widget?ajax=json&amp;id=ad').then(res =&gt; &#123; console.log(res);&#125;);]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实战小技巧]]></title>
    <url>%2F2019%2F06%2F11%2Fcss%E5%AE%9E%E6%88%98%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[这次我们来看下几个css简洁优雅的的使用技巧，特此声明，这里说的 CSS 并不止包含 CSS，也包含 CSS 预处理器（Less Sass 等），愿各位看官不要纠结于此。 尽量使用 padding 代替 margin​ padding 和 margin 两个是常用的属性，但是属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠，所以如果 margin 使用的过于频繁的时候，Box 的垂直距离可能就会发生重叠。第一个子元素的 margin-top 值会加在父元素上的 bug，最后一个子元素的 margin-bottom 也存在类似的问题。 ​ 原因：所有毗邻的两个或多个盒元素的 margin 将会合并为一个 margin 共享。所以我们可以在首位元素使用 padding 来替代 margin。当然有的时候使用 padding 不能满足需求，这时你也可以在“非空内容”这个条件做文章。即在父元素添加一个伪元素。 position:fixed 降级问题​ 开发中遇到的“吸顶”问题，就是position:fixed 这个属性。如果父元素有使用transform,fixed 的效果会降级为 absolute 解决方案 ​ 既然会降级为 absolute 效果，我们该怎么解决这个问题呢？我们就改考虑什么情况下 fixed和 absolute 的表现效果会是一样的。即当使用 fixed 的直接父元素的高度和屏幕的高度相同时 fixed 和 absolute 的表现效果会是一样的。如果这个直接父级内的元素存在滚动的情况，那就加上 overflow-y:auto。 合理使用 px | em | rem | % 等单位​ 在 CSS 中有许多距离单位，比如 px | em | rem | %，还有 CSS3 中的 vh | vw 等单位。px是pc端最常用的单位，但是再移动端自适应的要求下，使用的场景就不是很多了，以下几种小的适用场景。 比较小的图案​ 比如画一个 r 为 5px 的圆，如果我们使用 rem 作为单位，我们很快会发现在一些机型上的图案不圆，会呈现椭圆形。这是由于 rem 转 px 会存在精度丢失问题。 12345678910111213141516// less //使用 px 配合 dpr 来实现：/*@size 建议取双数*/.circle(@size,@backgroundColor)&#123; width:@size; height:@size; background-color:@backgroundColor; [data-dpr="1"] &amp; &#123; width: @size * 0.5; height: @size * 0.5; &#125; [data-dpr="3"] &amp; &#123; width: @size * 1.5; height: @size * 1.5; &#125;&#125; 字体大小​ 移动端，一般情况字体的大小会使用 rem 作为单位，它 是 CSS3 新增的一个相对单位（root em），即相对 HTML 根元素的字体大小的值； em 也是一个相对单位，却是相对当前元素的字体大小。line-height建议使用使用 em，因为在需要调整字体大小的时候，只需修改 font-size 的值，而 line-height 已经设置成了相对行高了。首行缩进两个字符，也适合使用em这个单位 1text-indent: 2em 视口单位 vw | vh vw: 1vw = 视口宽度的 1%vh: 1vh = 视口高度的 1% ​ 视口单位 vw | vh，可以用来解决rem单位设计弹性布局，需要再头部加载一段脚本来监听分辨率变化，动态改变根元素字体的大小，css与js耦合的问题。 上大佬们代码 123456789101112131415161718192021// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推$vm_fontsize:75;@function rem($px)&#123; @return ($px / $vm_fontsize) * 1rem;&#125;// vm$vm_design:750;html&#123; font-size:($vm_fontsize / ($vm_design / 2)) * 100vm; //rem 的值用 vm表示，后面就可以使用rem了 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 108px; &#125;&#125;// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125; 1px 细线问题​ 处理 1px 细线问题是移动端需求必不可免的，目前没有什么兼容性特别好的方案，这里我只是提供两种种相对较好的方案。 使用伪类 + transform123456789101112131415161718.border_bottom&#123; overflow: hidden; position: relative; border: none !important;&#125;.border_bottom:after&#123; content: '.'; position: absolute; left: 0; bottom: 0; width: 100%; height: 1px; background-color: #d4d6d7; -webkit-transform-origin: 0 0; transform-origin: 0 0; -webkit-transform: scaleY(0.5); transform: scaleY(0.5);&#125; 当然这个方案在一些版本较低的机型也是会出现粗细不均、细线消失断裂的兼容性问题。 使用 box-shadow 模拟1234.border_bottom &#123; box-shadow: inset 0px -1px 1px -1px #d4d6d7;&#125;/* 本可以满足所有场景，不过有个缺点也就是颜色会变浅。*/ 从 html 元素继承 box-sizing​ 在设置元素的 border 和 padding 并不希望改变元素的 width,height值，就可以为该元素设置 box-sizing:border-box;。如果不希望每次都重写一遍，可以继承来实现。 12345678html &#123; box-sizing: border-box;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125;/*不会覆盖其他组件的 box-sizing 值，又无需为每一个元素重复设置 box-sizing:border-box;*/ 内联首屏关键 CSS​ 性能优化中有一个重要的指标 —— 首次有效绘制（FMP），即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而 内联首屏关键 CSS（即 Critical CSS，可以称之为首屏关键 CSS） 能给用户一个更好的心理预期。内联 CSS 能够使浏览器开始页面渲染的时间提前，即在 HTML 下载完成之后就能渲染,我们可以将首屏的css内联再html中。 文字超出省略、文字两端对齐超出省略12345678.line-camp( @clamp:2) &#123; text-overflow: -o-ellipsis-lastline; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: @clamp; -webkit-box-orient: vertical; &#125; 两端对齐12345&lt;!-- html --&gt;&lt;div&gt;姓名&lt;/div&gt;&lt;div&gt;手机号码&lt;/div&gt;&lt;div&gt;账号&lt;/div&gt;&lt;div&gt;密码&lt;/div&gt; 123456div &#123; margin: 10px 0; width: 100px; border: 1px solid red; text-align-last: justify;&#125;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aysnc函数错误处理]]></title>
    <url>%2F2019%2F06%2F05%2Faysnc%E5%87%BD%E6%95%B0%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近，搭配koa和mysql2 （sequelize）使用的时候，查询数据库，会要捕获错误，sequelize提供的模型操作方法，均是返回promise对象，我们可以用then… catch 这样的链式方法 来获取查询数据结果，捕获错误；但是koa 支持 aysnc/ await 语法，我们可以更简洁地操作。 1234567891011121314 // 查询用户信息user = await Models.users.findOne(&#123; where:&#123; username: userName, password:mdPwd &#125;&#125;)// 创建用户信息rs = await Models.users.build(&#123; user_id:userId, username:userName, password:mdPwd&#125;).save() try … catch​ 在使用aync/await，我们可以像写同步代码一样来完成数据的增删该查，但是这种方式我们无法捕获数据操作过程中的错误信息。如果需要捕获错误，我们可以借助 try {} catch{}。 下面是我demo中的错误处理代码 12345678910111213141516171819202122232425262728293031323334353637383940414243// 查询用户信息let &#123;userName,userPwd&#125; = ctx.request.body; const mdPwd = md5(userPwd) // console.log(userName,userPwd) let user try&#123; user = await Models.users.findOne(&#123; where:&#123; username: userName, password:mdPwd &#125; &#125;) &#125;catch(err)&#123; // 捕获错误 return ctx.body = &#123; status: "1", msg: err.message &#125; &#125; // 用户名和密码已存在 if(user)&#123; return ctx.body = &#123; status: '22', msg: '用户名和密码已存在' &#125; &#125; let userId = (Math.floor(Math.random() * 100000) + 100000000); let rs; // 写入用户信息，错误捕获 try&#123; rs = await Models.users.build(&#123; user_id:userId, username:userName, password:mdPwd &#125;).save() &#125;catch(error)&#123; return ctx.body = &#123; status: '1', msg: err1.message, result: '' &#125; &#125; ​ 上述 try {} catch{} 捕获错误的方法，也是繁琐，因为aysnc/await 处理的函数均会返回一个promise对象， 我们可以包装promise，使其返回统一的格式的代码 12345678910111213 /** * 包装promise, 使其返回统一的错误格式 * @param &#123;Promise&#125; promise */ function handlerAsyncError (promise) &#123; return promise.then(res =&gt; [null, res]).catch(err =&gt; [err]) &#125; // 简洁处理错误，减少try。。catch const [err, res] = await handlerAsyncError(fetchUser(true)) if (err) &#123; console.error('touser err:', err) &#125; async 顺序​ 使用async的时候，代码执行的顺序很容易出错，比如我们要同时发起两个请求，可能会写出下面的代码 123456789101112131415161718192021222324function fetchName () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('lujs') &#125;, 3000) &#125;)&#125;function fetchAvatar () &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('https://avatars3.githubusercontent.com/u/16317354?s=88&amp;v=4') &#125;, 4000) &#125;)&#125;async fetchUser () &#123; const name = await fetchName() const avatar = await fetchAvatar() return &#123; name, avatar &#125;&#125; ​ 在上面的代码中，我们认为fetchName，fetchAvatar会并行执行，实际上并不会。fetchAvatar会等待fetchName执行完之后才开始请求。要并行请求的话需要像下面这样写: 12345678async function fetchUserParallel () &#123; const namePromise = fetchName() const avatarPromise = fetchAvatar() return &#123; name: await namePromise, avatar: await avatarPromise &#125;&#125; 使用Promise.all来并发请求123456789101112131415function fetchList (id) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(`id is : $&#123;id&#125;`) &#125;, 5000) &#125;)&#125;async function getList () &#123; const ary = [1, 2, 3, 4] const list = Promise.all( ary.map( (id) =&gt; fetchList(id))) return await list&#125;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由调转解析]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[​ 目前前端三杰 Angular、React、Vue 都推介单页面应用 SPA 开发模式，在路由切换时替换 DOM Tree 中最小修改的部分 DOM，来减少原先因为多页应用的页面跳转带来的巨量性能损耗。它们都有自己的典型路由解决方案，@angular/router、react-router、vue-router。 ​ 一般来说，这些路由插件总是提供两种不同方式的路由方式：Hash 和 History，有时也会提供非浏览器环境下的路由方式 Abstract。Hash 和 History 除了外观上的不同之外，还一个区别是：Hash 方式的状态保存需要另行传递，而 HTML5 History 原生提供了自定义状态传递的能力，我们可以直接利用其来传递信息。 Hash相关 Api​ Hash 方法是在路由中带有一个 #，主要原理是通过监听 # 后的 URL 路径标识符的更改而触发的浏览器 hashchange 事件，然后通过获取 location.hash 得到当前的路径标识符，再进行一些路由跳转的操作。 location.href：返回完整的 URL location.hash：返回 URL 的锚部分 location.pathname：返回 URL 路径名 hashchange 事件：当 location.hash 发生改变时，将触发这个事件 比如访问一个路径 http://sherlocked93.club/base/#/page1，那么上面几个值分别为： 123456# http://sherlocked93.club/base/#/page1&#123; "href": "http://sherlocked93.club/base/#/page1", "pathname": "/base/", "hash": "#/page1"&#125; 简单实现12345678910111213141516171819202122class RouterClass&#123; constructor()&#123; this.routes = &#123;&#125; // 记录路径标识符对应的cb this.currentUrl = '' // 记录hash只为方便执行cb window.addEventListener('load', () =&gt; this.render()) window.addEventListener('hashchange', () =&gt; this.render()) &#125; /* 初始化 */ static init()&#123; window.Router = new RouterClass() &#125; /* 注册路由和回调 */ route(path, cb) &#123; this.routes[path] = cb || function() &#123;&#125; &#125; /* 记录当前hash，执行cb */ render()&#123; this.currentUrl = location.hash.slice(1) || '/' this.routes[this.currentUrl]() &#125;&#125; 如果希望使用脚本来控制 Hash 路由的后退，可以将经历的路由记录下来，路由后退跳转的实现是对 location.hash 进行赋值。但是这样会引发重新引发 hashchange 事件，第二次进入 render 。所以我们需要增加一个标志位，来标明进入 render 方法是因为回退进入的还是用户跳转 123456789101112131415161718192021222324252627282930313233343536373839404142434445class RouterClass&#123; constructor()&#123; this.isBack = false //是否为 ‘后退操作’ this.routes = &#123;&#125; // 记录路径标识符对应的cb this.currentUrl = '' // 记录hash只为方便执行cb this.historyStack = [] // hash栈 window.addEventListener('load', () =&gt; this.render()) window.addEventListener('hashchange', () =&gt; this.render()) &#125; /* 初始化 */ static init()&#123; window.Router = new RouterClass() &#125; /* 注册路由和回调 */ route(path, cb) &#123; this.routes[path] = cb || function() &#123;&#125; &#125; /* 记录当前hash，执行cb */ render()&#123; if(this.isBack)&#123; this.isBack = false; return; // 此时的 render 渲染操作 由程序员手动调用的 back方法完成 &#125;; this.currentUrl = location.hash.slice(1) || '/' this.routes[this.currentUrl]() // 记录 hash历史 this.historyStack.push(this.currentUrl); &#125; /* 路由后退 */ back()&#123; this.isBack = true; this.historyStack.pop() //移除当前hash，回退到上一个 const &#123; length &#125; = this.historyStack if (!length) return let prev = this.historyStack[length - 1] // 拿到要回退到的目标hash location.hash = `#$&#123; prev &#125;` this.currentUrl = prev // 手动调整 hash this.routes[prev]() // 手动完成 回调 &#125;&#125; HTML5 History Api相关 ApiHTML5 提供了一些路由操作的 Api，在此就列举一下常用 Api 和他们的作用，详情请参照 MDN historyAPI history.go(n)：路由跳转，比如n为 2 是往前移动2个页面，n为 -2 是向后移动2个页面，n为0是刷新页面 history.back()：路由后退，相当于 history.go(-1) history.forward()：路由前进，相当于 history.go(1) history.pushState()：添加一条路由历史记录，如果设置跨域网址则报错 history.replaceState()：替换当前页在路由历史记录的信息 popstate 事件：当活动的历史记录发生变化，就会触发 popstate 事件，在点击浏览器的前进后退按钮或者调用上面前三个方法的时候也会触发。 简单实现​ 在需要路由跳转的地方使用 history.pushState 来入栈并记录 cb，前进后退的时候监听 popstate 事件拿到之前传给 pushState 的参数并执行对应 cb。 12345678910111213141516171819202122232425class RouterClass &#123; constructor(path)&#123; this.routes = &#123;&#125; //记录路径标识符对应的cb history.replaceState(&#123; path &#125;, null, path) // 进入状态 this.routes[path] &amp;&amp; this.routes[path](); window.addEventListener('popstate', e =&gt; &#123; const path = e.state &amp;&amp; e.state.path this.routes[path] &amp;&amp; this.routes[path]() &#125;) &#125; /* 初始化 */ static init() &#123; window.Router = new RouterClass(location.pathname) &#125; /* 注册路由和回调 */ route(path , cb)&#123; this.routes[path] = cb || function() &#123;&#125; &#125; /* 跳转路由，并触发路由对应回调 */ go(path) &#123; history.pushState(&#123; path &#125;, null, path) //this.routes[path] &amp;&amp; this.routes[path]() &#125;&#125; 小结​ Hash 模式是使用 URL 的 Hash 来模拟一个完整的 URL，因此当 URL 改变的时候页面并不会重载。History 模式则会直接改变 URL，所以在路由跳转的时候会丢失一些地址信息，在刷新或直接访问路由地址的时候会匹配不到静态资源。因此需要在服务器上配置一些信息，让服务器增加一个覆盖所有情况的候选资源，避免浏览器‘404’页面的出现]]></content>
      <categories>
        <category>路由</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络请求方式二]]></title>
    <url>%2F2019%2F05%2F29%2F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[fetch的使用一个基本的 fetch请求： 1234567891011121314151617181920const options = &#123; method:'POST', // 请求参数 headers:&#123; 'Content-Type':'application/json' // 设置请求头 &#125;, body:JSON.stringify(&#123;name:'123'&#125;), // 请求参数 credentials:'some-origin', // cookie设置 mode:'cors' //跨域&#125;fetch('http://www.xxx.com',options).then(function(response)&#123; return response.json()&#125;).then(function(myjson)&#123; console.log(myjson) // 响应数据&#125;).then(function(err)&#123; conosle.log(err) // 异常处理&#125;) FetchAPI提供了一个全局的 fetch()方法，以及几个辅助对象来发起一个网络请求。 fetch()fetch()方法用于发起获取资源的请求。它返回一个 promise，这个 promise 会在请求响应后被 resolve，并传回 Response 对象。 headers可以通过 Headers()构造函数来创建一个你自己的 headers对象，相当于 response/request的头信息，可以使你查询到这些头信息，或者针对不同的结果做不同的操作。 12var myHeaders = new Headers()myHeaders.append('Content-Type','text/plain') Request通过 Request()构造函数可以创建一个 Request对象，这个对象可以作为 fetch函数的第二个参数。 Response在 fetch()处理完 promises之后返回一个 Response实例，也可以手动创建一个 Response实例。 跨域总结谈到网络请求，就不得不提跨域。 浏览器的同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 跨域条件：协议，域名，端口，有一个不同就算跨域。 下面是解决跨域的几种方式： nginx使用 nginx反向代理实现跨域. corsCORS是一个 W3C标准，全称是”跨域资源共享” （Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest请求。 服务端设置 Access-Control-Allow-Origin就可以开启 CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 12345app.all('*',function(req,res,next)&#123; res.header('Access-Control-Allow-Origin','*') res.header('Access-Control-Allow-Headers','X-Requested-With') res.header('Access-Control-Allow-Mothods','PUT,POST,GET,DELETE,OPTIONS')&#125;) jsonpscript标签的 src属性中的链接可以访问跨域的 js脚本，利用这个特性，服务端不再返回 JSON格式的数据，而是返回一段调用某个函数的 js代码，在 src中进行了调用，这样实现了跨域。 jquery对 jsonp的支持: 12345678910$.ajax(&#123; type:'get', url:'http"//xxxx', dataType:'jsonp', jsonp:'callback', jsonpCallback:'doo', success:function(data)&#123; console.log(data) &#125;&#125;) fetch、axios等并没有直接提供对 jsonp的支持，如果需要使用这种方式，我们可以尝试进行手动封装： 12345678910111213141516171819202122232425262728293031323334(function(window,document) &#123;"use strict";var jsonp = function (url,data,callback) &#123;// 1.将传入的data数据转化为url字符串形式 // &#123;id:1,name:'jack'&#125; =&gt; id=1&amp;name=jackvar dataString = url.indexof('?') == -1 ? '?': '&amp;'; for(var key in data)&#123; dataString += key + '='+ data[key] + '&amp;';&#125;; // 2 处理url中的回调函数 // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉） var cbFuncName = 'my_json_cb_'+ Math.random().toString().replace('.',''); dataString += 'callback='+ cbFuncName;// 3.创建一个script标签并插入到页面中 var scriptEle = document.createElement('script'); scriptEle.src = url + dataString; // 4.挂载回调函数window[cbFuncName] = function(data) &#123; callback(data);// 处理完回调函数的数据之后，删除jsonp的script标签 document.body.removeChild(scriptEle);&#125; document.body.appendChild(scriptEle);&#125; window.$jsonp = jsonp;&#125;)(window,document) postMessage跨域postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 123456789101112131415161718//捕获iframevar domain = 'http://scriptandstyle.com';var iframe = document.getElementById('myIFrame').contentWindow;//发送消息setInterval(function()&#123; var message = 'Hello! The time is: '+ (new Date().getTime()); console.log('blog.local: sending message: '+ message); //send the message and target URI iframe.postMessage(message,domain);&#125;,6000);//响应事件window.addEventListener('message',function (event) &#123; if(event.origin !== 'http://davidwalsh.name') return; console.log('message received: '+ event.data,event); event.source.postMessage('holla back youngin!',event.origin);&#125;,false); postMessage跨域适用于以下场景：同浏览器多窗口间跨域通信、 iframe间跨域通信。 WebSocketWebSocket 是一种双向通信协议，在建立连接之后， WebSocket的 server与 client都能主动向对方发送或接收数据而不受同源策略的限制。 123456789101112131415161718192021222324252627282930313233function WebSocketTest()&#123; if("WebSocket" in window)&#123; alert("您的浏览器支持 WebSocket!"); // 打开一个 web socket var ws = new WebSocket("ws://localhost:3000/abcd"); ws.onopen = function()&#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send("发送数据"); alert("数据发送中..."); &#125;; ws.onmessage = function(evt) &#123; var received_msg = evt.data; alert("数据已接收..."); &#125;; ws.onclose = function()&#123; // 关闭 websocket alert("连接已关闭..."); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert("您的浏览器不支持 WebSocket!"); &#125;&#125;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络请求方式一]]></title>
    <url>%2F2019%2F05%2F26%2F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E4%B8%80%2F</url>
    <content type="text"><![CDATA[原生Ajax的用法​ Ajax全称 AsynchronousJavaScript+XML（异步 JavaScript和 XML，网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。Ajax本身不是一种新技术，而是用来描述一种使用现有技术集合实现的一个技术方案，浏览器的 XMLHttpRequest是实现 Ajax最重要的对象（ IE6以下使用 ActiveXObject）。 123456789101112131415161718192021222324252627282930var xhr = new XMLHttpRequest();xhr.open('post','www.xxx.com',true);// 接收返回值xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status &lt; 304)&#123; console.log(xhr.responseText) &#125; &#125;&#125;// 处理请求参数var postData = &#123;"name1":"value1","name2":"value2"&#125;;postData = (function(value)&#123; var oStr = '' for(var key in value)&#123; oStr += key + '=' + value[key] + '&amp;' &#125; return oStr;&#125;)(postData)// 设置请求头xhr.setRequestHeader('Content-type','application/x-www-form-unlencoded');// 异常处理xhr.onerror = function()&#123; console.log('Network request failed')&#125;// 跨域携带cookiexhr.withCredentials = true;// 发出请求xhr.send(postData) 下面分别对 XMLHttpRequest对象常用的的函数、属性、事件进行分析。 函数open 用于初始化一个请求，用法： 1xhr.open(method,url,async); method：请求方式，如 get、post url：请求的 url async：是否为异步请求,默认true，异步 send 用于发送 HTTP请求，即调用该方法后 HTTP请求才会被真正发出，用法： 1xhr.send(param) param：http请求的参数，可以为 string、Blob等类型. abort 用于终止一个 ajax请求，调用此方法后 readyState将被设置为 0，用法： 1xhr.abort() setRequestHeader 用于设置 HTTP请求头，此方法必须在 open()方法和 send()之间调用，用法： 1xhr.setRequestHeader(header, value); getResponseHeader 用于获取 http返回头，如果在返回头中有多个一样的名称，那么返回的值就会是用逗号和空格将值分隔的字符串，用法： 1var header = xhr.getResponseHeader(name); 属性readyState 用来标识当前 XMLHttpRequest对象所处的状态， XMLHttpRequest对象总是位于下列状态中的一个： 0 : UNSENT |代理被创建，但尚未调用 open() 方法。 1: OPENED | open() 方法已经被调用。 2: HEADERS_RECEIVED | send()方法已经被调用，并且响应头部和状态已经可获得。 3: LOADING | 下载中。接收响应内容，responseText 属性已经包含部分数据。 4：DONE | 下载操作已完成。数据完整接收 status 表示 http请求的状态, 初始值为 0。如果服务器没有显式地指定状态码, 那么 status将被设置为默认值, 即 200。 responseType 表示响应的数据类型，并允许我们手动设置，如果为空，默认为 text类型，可以有下面的取值： “”：将 responseType设为空字符串与设置为 &quot;text&quot;相同， 是默认类型 （实际上是 DOMString） arraybuffer：response 是一个包含二进制数据的 JavaScriptArrayBuffer 。 blob：response是一个包含二进制数据的 Blob 对象 。 document：response 是一个 HTMLDocument或 XMLXMLDocument，这取决于接收到的数据的 MIME 类型。 json：response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为 JSON解析得到的。 text： response是包含在 DOMString对象中的文本。 response 返回响应的正文，返回的类型由上面的 responseType决定。 withCredentials ajax请求默认会携带同源请求的 cookie，而跨域请求则不会携带 cookie，设置 xhr的 withCredentials的属性为 true将允许携带跨域 cookie。 事件回调onreadystatechange 1xhr.onreadystatechange = callback; 当 readyState属性发生变化时，callback会被触发。 onloadstart 1xhr.onloadstart = callback; 在 ajax请求发送之前（ readyState==1后, readyState==2前）， callback会被触发。 onprogress 123xhr.onprogress = function(e)&#123; console.log(e.loaded / e.total)&#125; 回调函数可以获取资源总大小 total，已经加载的资源大小 loaded，用这两个值可以计算加载进度。 onload 1xhr.onload = callback; 当一个资源及其依赖资源已完成加载时，将触发 callback，通常我们会在 onload事件中处理返回值。 异常处理onerror 1xhr.onerror = callback; 当 ajax资源加载失败时会触发 callback。 ontimeout 1xhr.ontimeout = callback; 当进度由于预定时间到期而终止时，会触发 callback，超时时间可使用 timeout属性进行设置。 jQuery对Ajax的封装`jQuery`提供的 `ajax`封装进行网络请求，包括 `$.ajax、$.get、$.post`等，这几个方法放到现在，我依然觉得很实用。 123456789101112131415161718// $.ajax只接收一个参数，这个参数接收一系列配置，其自己封装了一个 jqXHR对象$.ajax(&#123; dataType:'json', //设置返回值类型 contentType:'application/json', // 设置参数类型 headers:&#123; // 设置请求头 'Content-Type':'application/json' &#125;, url:'....', type:'post', xhrFields:&#123; withCredentials:true //跨域携带cookie &#125;, data:JSON.stringify(&#123;a:1,b;2&#125;), // 传递参数 error:function(xhr,status)&#123;&#125;, success:function(xhr,status)&#123; &#125;&#125;) 常用配置url 当前页地址。发送请求的地址。 type 类型：String 请求方式 ( &quot;POST&quot; 或 &quot;GET&quot;)， 默认为 &quot;GET&quot;。注意：其它 HTTP请求方法，如PUT和 DELETE也可以使用，但仅部分浏览器支持。 timeout 类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。 success 类型：Function 请求成功后的回调函数。 jsonp 在一个 jsonp请求中重写回调函数的名字。这个值用来替代在 &quot;callback=?&quot;这种 GET或 POST请求中 URL参数里的 &quot;callback&quot;部分。 error 类型：Function 。请求失败时调用此函数。 dataType 12345678"xml": 返回 XML 文档，可用 jQuery 处理。"html": 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。"script": 返回纯文本 JavaScript代码。不会自动缓存结果。除非设置了 "cache":参数。在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）"json": 返回 JSON 数据 。"jsonp": JSONP 格式。使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。"text": 返回纯文本字符串 data 类型：String 使用 JSON.stringify转码 complete 类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。 async 类型：Boolean 默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 contentType 类型：String默认值: &quot;application/x-www-form-urlencoded&quot;。发送信息至服务器时内容编码类型。 jQuery的替代者​ axios基于 Promise对原生的 XHR进行了非常全面的封装，使用方式也非常的优雅。另外， axios同样提供了在 node环境下的支持，可谓是网络请求的首选方案。 ​ FetchAPI是一个用用于访问和操纵HTTP管道的强大的原生 API。fetch是作为 XMLHttpRequest的替代品出现的。使用 fetch，你不需要再额外加载一个外部资源。但它还没有被浏览器完全支持，所以你仍然需要一个 polyfill。]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax封装]]></title>
    <url>%2F2019%2F05%2F21%2Fajax%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[ajax123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110;(function anonymous(window) &#123; function AJAX(options) &#123; return new init(options); &#125; let init = function init(options = &#123;&#125;) &#123; //=&gt;INIT PARAM let &#123; url, method = 'GET', data = null, dataType = 'JSON', async = true, cache = true, success, error &#125; = options; //=&gt;MOUNT:把配置项挂载到实例上 ['url', 'method', 'data', 'dataType', 'async', 'cache', 'success', 'error'].forEach(item =&gt; &#123; this[item] = eval(item); &#125;); //=&gt;SEND:发送AJAX请求 this.sendAjax(); &#125;; AJAX.prototype = &#123; constructor: AJAX, init, //=&gt;发送AJAX请求 sendAjax() &#123; this.handleData(); this.handleCache(); //=&gt;SEND let &#123;method, url, async, error, success, data&#125; = this, xhr = new XMLHttpRequest; xhr.open(method, url, async); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; //=&gt;ERROR if (!/^(2|3)\d&#123;2&#125;$/.test(xhr.status)) &#123; error &amp;&amp; error(xhr.statusText, xhr); return; &#125; //=&gt;SUCCESS let result = this.handlDataType(xhr); success &amp;&amp; success(result, xhr); &#125; &#125;; xhr.send(data); &#125;, //=&gt;处理DATA-TYPE handlDataType(xhr) &#123; let dataType = this.dataType.toUpperCase(), result = xhr.responseText; switch (dataType) &#123; case 'TEXT': break; case 'JSON': result = JSON.parse(result); break; case 'XML': result = xhr.responseXML; break; &#125; return result; &#125;, //=&gt;处理CACHE handleCache() &#123; let &#123;url, method, cache&#125; = this; if (/^GET$/i.test(method) &amp;&amp; cache === false) &#123; //=&gt;URL末尾追加时间辍 url += `$&#123;this.check()&#125;_=$&#123;+(new Date())&#125;`; this.url = url; &#125; &#125;, //=&gt;处理DATA handleData() &#123; let &#123;data, method&#125; = this; if (!data) return; //=&gt;如果是个OBJECT对象,我们把它转换为x-www-form-urlencoded这种模式,方便后期传递给服务器 if (typeof data === 'object') &#123; let str = ``; for (let key in data) &#123; if (data.hasOwnProperty(key)) &#123; str += `$&#123;key&#125;=$&#123;data[key]&#125;&amp;`; &#125; &#125; data = str.substring(0, str.length - 1); &#125; //=&gt;根据请求方式不一样,传递给服务器的方式也不同 if (/^(GET|DELETE|HEAD|TRACE|OPTIONS)$/i.test(method)) &#123; this.url += `$&#123;this.check()&#125;$&#123;data&#125;`; this.data = null; return; &#125; this.data = data;//=&gt;POST系列 &#125;, //=&gt;检测URL中是否存在问号 check() &#123; return this.url.indexOf('?') &gt; -1 ? '&amp;' : '?'; &#125; &#125;; init.prototype = AJAX.prototype; window.ajax = AJAX;&#125;)(window); Pormise 形式的ajax请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115;(function anonymous(window) &#123; //=&gt;设置默认的参数配置项 let _default = &#123; method: 'GET', url: '', baseURL: '', headers: &#123;&#125;, dataType: 'JSON', data: null,//=&gt;POST系列请求基于请求主体传递给服务器的内容 params: null,//=&gt;GET系列请求基于问号传参传递给服务器的内容 cache: true &#125;; //=&gt;基于PROMISE设计模式管理AJAX请求 let ajaxPromise = function ajaxPromise(options) &#123; //=&gt;OPTIONS中融合了:默认配置信息、用户基于DEFAULTS修改的信息、用户执行GET/POST方法时候传递的配置信息，越靠后的优先级越高 let &#123;url, baseURL, method, data, dataType, headers, cache, params&#125; = options; //=&gt;把传递的参数进一步进行处理 if (/^(GET|DELETE|HEAD|OPTIONS)$/i.test(method)) &#123; //=&gt;GET系列 if (params) &#123; url += `$&#123;ajaxPromise.check(url)&#125;$&#123;ajaxPromise.formatData(params)&#125;`; &#125; if (cache === false) &#123; url += `$&#123;ajaxPromise.check(url)&#125;_=$&#123;+(new Date())&#125;`; &#125; data = null;//=&gt;GET系列请求主体就是什么都不放 &#125; else &#123; //=&gt;POST系列 if (data) &#123; data = ajaxPromise.formatData(data); &#125; &#125; //=&gt;基于PROMISE发送AJAX return new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest; xhr.open(method, `$&#123;baseURL&#125;$&#123;url&#125;`); //=&gt;如果HEADERS存在,我们需要设置请求头 if (headers !== null &amp;&amp; typeof headers === 'object') &#123; for (let attr in headers) &#123; if (headers.hasOwnProperty(attr)) &#123; let val = headers[attr]; if (/[\u4e00-\u9fa5]/.test(val)) &#123; //=&gt;VAL中包含中文:我们把它进行编码 //encodeURIComponent/decodeURIComponent val = encodeURIComponent(val); &#125; xhr.setRequestHeader(attr, val); &#125; &#125; &#125; xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (/^(2|3)\d&#123;2&#125;$/.test(xhr.status)) &#123; let result = xhr.responseText; dataType = dataType.toUpperCase(); dataType === 'JSON' ? result = JSON.parse(result) : (dataType === 'XML' ? result = xhr.responseXML : null); resolve(result); return; &#125; reject(xhr.statusText); &#125; &#125;; xhr.send(data); &#125;); &#125;; //=&gt;把默认配置暴露出去,后期用户在使用的时候可以自己设置一些基础的默认值(发送AJAX请求的时候按照用户配置的信息进行处理) ajaxPromise.defaults = _default; //=&gt;把对象转换为URLENCODED格式的字符串 ajaxPromise.formatData = function formatData(obj) &#123; let str = ``; for (let attr in obj) &#123; if (obj.hasOwnProperty(attr)) &#123; str += `$&#123;attr&#125;=$&#123;obj[attr]&#125;&amp;`; &#125; &#125; return str.substring(0, str.length - 1); &#125;; ajaxPromise.check = function check(url) &#123; return url.indexOf('?') &gt; -1 ? '&amp;' : '?'; &#125;; //=&gt;GET ['get', 'delete', 'head', 'options'].forEach(item =&gt; &#123; ajaxPromise[item] = function anonymous(url, options = &#123;&#125;) &#123; options = &#123; ..._default,//=&gt;默认值或者基于defaults修改的值 ...options,//=&gt;用户调取方法传递的配置项 url: url,//=&gt;请求的URL地址(第一个参数:默认配置项和传递的配置项中都不会出现URL，只能这样获取) method: item.toUpperCase()//=&gt;以后执行肯定是ajaxPromise.head执行，不会设置METHODS这个配置项，我们自己需要配置才可以 &#125;; return ajaxPromise(options); &#125;; &#125;); //=&gt;POST ['post', 'put', 'patch'].forEach(item =&gt; &#123; ajaxPromise[item] = function anonymous(url, data = &#123;&#125;, options = &#123;&#125;) &#123; options = &#123; ..._default, ...options, url: url, method: item.toUpperCase(), data: data &#125;; return ajaxPromise(options); &#125;; &#125;); window.ajaxPromise = ajaxPromise;&#125;)(window); url地址解析12345678910//=&gt;URL地址解析 let queryURLParams = function (url = window.location.href) &#123; let obj = &#123;&#125;, reg = /([^?=&amp;#]+)=([^?=&amp;#]+)/g; url.replace(reg, (...arg) =&gt; &#123; let [, key, value] = arg; obj[key] = value; &#125;); return obj; &#125;;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2019%2F05%2F16%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git使用指南​ 公司一直是使用git作为代码管理，现在整理一些常用的git命令，供大家查看，不再依赖图形化工具 基本使用1、克隆仓库 克隆仓库会下载仓库完整的文件、分支和历史记录。 1git clone [&lt;options&gt;] [--] &lt;repo&gt; [&lt;dir&gt;] 1234# 克隆完整的仓库到 ./git-learning 目录下git clone git@github.com:x-cold/git-learning.git# 只克隆 dev 分支到 ./dev 目录下gti clone -b dev git@github.com:x-cold/git-learning.git dev 2、将文件变更记录写入到本地的索引库 1git add [&lt;option&gt;] [--] [pathsec]... 1234# 添加当前目录下所有文件git add .# 添加部分文件git add src/ app/ index.js 3、提交变更到工作区 1git commit [&lt;options&gt;] [--] &lt;pathsec&gt;... 123456# 最普通的提交git commit -m&apos;feat: support canvas&apos;# 修改当前的 commit messagegit commit --amend# 重置当前的 commit author 和 messagegit commit --amend --reset-author 4、推送代码到远程仓库 1git push [&lt;options&gt;] [&lt;repository&gt;] [&lt;refspec&gt;...]] 1234# 提交本地仓库当前分支到远程仓库的 master 分支git push origin master# 提交本地仓库 dev 分支到远程的 master 分支git push origin master:dev ​ Git 是一个分布式的版本控制工具，因此远程和本地可以视为两个独立的 Git 仓库。上图是一张经典的 Git 中的数据流与存储级别的介绍，其中储存级别主要包含几部分： 工作区 (Working Files)，指的是我们时刻在编辑的文件的目录，通常来说我们修改文件都是在工作区体现的 暂存区（Stage），暂存将本地的修改，然后提交到本地仓库 本地仓库（Local），commit 后 形成的历史记录区 远程仓库 总体的流程就是：：工作区 -&gt; 暂存区 -&gt; 本地仓库 -&gt; 远程仓库 常用命令git init 创建一个空白的 git 仓库 1git init git add 1git add [&lt;options&gt;] [--] &lt;pathspec&gt; ... git commit 1git commit [&lt;options&gt;] [--] &lt;pathspec&gt; ... git remote remote 指的是本地的 git 仓库关联的远程 git 仓库。 1、 查看远程仓库信息 1git remote 2、看远程仓库详细信息 1git remote -v 3、 删除远程仓库 123git remote remove &lt;name&gt;# 移除名字为 origin 的远程仓库git remote remove origin 4、添加远程仓库 1git remote origin git@github.com:x-cold/git-learning.git git branch 1、列出本地存在的分支 1git branch 2、列出远程分支 1git branch -r 3、列出本地和远程分支 1git branch -a 4、创建本地分支 1git branch [branchName] &lt;remoteBranch&gt; 12# 基于远程仓库的 dev 分支，创建本地仓库的 feature/canvas 分支git branch feature/canvas dev 5、分支重命名 123git branch [&lt;options&gt;] (-m | -M) [&lt;old-branch&gt;] &lt;new-branch&gt;# 修改 feature/canvas 分支名为 feature/canvas2git branch -M feature/canvas feature/canvas2 6、删除分支 123git branch -d | -D [branchName]# 删除 feature/canvas2 分支git branch -d feature/canvas 7、设置默认上游及分支 12# 以后只需要在 dev 分支执行 git push (无需额外的参数) 就可以提交到 origin/devgit branch --set-upstream dev origin/dev git checkout 1234# 切换当前分支到 dev 分支git checkout dev# 基于当前分支创建 test 分支，并且将当前分支切换到 test 分支git checkout -b test 除开用于分支切换，checkout 还可以用于恢复未添加到本地工作区，但是被修改过的文件。 12# 将 index.js 恢复到当前 commit 的内容git checkout index.js git merge 1234# 合并分支git merge [&lt;options&gt;] [&lt;commit&gt;....]# 合并远程仓库的 master 分支到当前分支git merge origin/master git rebase 变基，是一种常用且有风险的操作，会改变提交历史，我们需要谨慎使用！ 1git rebase git cherry-pick 魔法级的命令，cherry-pick 可以提取 N 个的提交记录，合入稳定版本的分支上。 12345git cherry-pick [&lt;options&gt;] &lt;commit-ish&gt;...# 挑选 371c2 单个提交记录，合入当前分支git cherry-pick 371c2# 挑选出 371c2 到 971209 的所有提交记录，并合入当前分支git cherry-pick 371c2...971209 git push 推送到远程仓库，同步本地仓库的提交历史到远程仓库 12345678# 提交本地仓库当前分支到远程仓库的 master 分支git push origin master# 提交本地仓库 dev 分支到远程的 master 分支git push origin master:dev# 提交单个 taggit push origin publish/1.0.0# 提交所有 taggit push origin --tags git pull 拉取远程分支，同步远程仓库的提交历史到本地仓库 123456# 通常来说，默认的 pull 行为等同于 git fetch + git merge# 下面这行命令等同于 git fetch origin master &amp;&amp; git merge origin/mastergit pull origin master# 也可以通过变基的方式来拉取代码，这样分支模型不容易受到影响# 下面这行命令等同于 git fetch origin master &amp;&amp; git rebase origin/mastergit pull --rebase origin master git tag 1、创建 tag 1git tag -a v1.1.0 -m&quot;&quot; 2、查看 tag 1git tag 3、推送到远程 1git push origin --tags 4、删除本地 tag 1git tag -d v1.1.0 5、删除远程 tag 1git push origin :refs/tags/v1.0.0 .git 仓库元数据每一个 git 的代码仓库目录下，都会有一个 .git 的文件夹，其中包含的重要文件包含以下：]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function&Object原型]]></title>
    <url>%2F2019%2F05%2F15%2FFunction%26Object%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;深入探究下 Function.proto === Function.prototype 引起的鸡生蛋蛋生鸡问题，并在这个过程中深入了解 Object.prototype、Function.prototype、function Object 、function Function 之间的关系。 Object.prototype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype表示 Object 的原型对象,其 Object.prototype.__proto__ 是 null ,因此 Object.prototype 并不是通过 Object 函数创建的。其实 Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype 就是原型链的顶端（不考虑 null 的情况下），所有对象继承了它的 toString 等方法和属性。 Function.prototype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function.prototype 对象是一个函数（对象），其 [[Prototype]] 内部属性值指向内建对象 Object.prototype。Function.prototype 对象自身没有 valueOf 属性，其从 Object.prototype 对象继承了valueOf 属性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function.prototype 的 [[Class]] 属性是 Function，所以这是一个函数，但又不大一样。为什么这么说呢？因为我们知道只有函数才有 prototype 属性，但并不是所有函数都有这个属性，因为 Function.prototype 这个函数就没有。12345678910Function.prototype// ƒ () &#123; [native code] &#125;Function.prototype.prototype// undefinedlet fun = Function.prototype.bind()// ƒ () &#123; [native code] &#125;fun.prototype// undefined 我的理解是 Function.prototype 是引擎创建出来的函数，引擎认为不需要给这个函数对象添加 prototype 属性，不然 Function.prototype.prototype… 将无休无止并且没有存在的意义。 function Object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object 作为构造函数时，其 [[Prototype]] 内部属性值指向 Function.prototype，即12Object.__proto__ === Function.prototype// true 使用 new Object() 创建新对象时，这个新对象的 [[Prototype]] 内部属性指向构造函数的 prototype 属性，对应上图就是 Object.prototype。当然也可以通过对象字面量等方式创建对象。 使用对象字面量创建的对象，其 [[Prototype]] 值是 Object.prototype。 使用数组字面量创建的对象，其 [[Prototype]] 值是 Array.prototype。 使用 function f(){} 函数创建的对象，其 [[Prototype]] 值是 Function.prototype 使用其他 JavaScript 构造器函数创建的对象，其 [[Prototype]] 值就是该构造器函数的 prototype 属性。 function Function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function 构造函数是一个函数对象，其 [[Class]] 属性是 Function。Function 的 [[Prototype]] 属性指向了 Function.prototype，即12Function.__proto__ === Function.prototype// true Function &amp; Object 鸡蛋问题12345Object instanceof Function // trueFunction instanceof Object // trueObject instanceof Object // trueFunction instanceof Function // true Object 构造函数继承了 Function.prototype，同时 Function 构造函数继承了Object.prototype。这里就产生了 鸡和蛋 的问题。为什么会出现这种问题，因为 Function.prototype 和 Function.proto 都指向 Function.prototype。 1234567891011// Object instanceof Function 即Object.__proto__ === Function.prototype // true// Function instanceof Object 即Function.__proto__.__proto__ === Object.prototype // true// Object instanceof Object 即 Object.__proto__.__proto__ === Object.prototype // true// Function instanceof Function 即 Function.__proto__ === Function.prototype // true 对于 Function.proto === Function.prototype 这一现象有如下2种解释， 按照 JavaScript 中“实例”的定义，a 是 b 的实例即 a instanceof b 为 true，默认判断条件就是 b.prototype 在 a 的原型链上。而 Function instanceof Function 为 true，本质上即 Object.getPrototypeOf(Function) === Function.prototype，正符合此定义。 Function 是 built-in 的对象，也就是并不存在“Function对象由Function构造函数创建”这样显然会造成鸡生蛋蛋生鸡的问题。实际上，当你直接写一个函数时（如 function f() {} 或 x =&gt; x），也不存在调用 Function 构造器，只有在显式调用 Function 构造器时（如 new Function(‘x’, ‘return x’) ）才有。 最后一个完整的原型链图：]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux04]]></title>
    <url>%2F2019%2F05%2F11%2Fredux04%2F</url>
    <content type="text"><![CDATA[react-redux梳理 Provider根组件 PROVIDER：当前项目的“根”组件 接收通过属性传递进来的STORE，把STOR&gt;挂载到上下文中，这样当前项目中任何一个组&gt;中，想要使用REDUX中的STORE，直接通过上下文&gt;取即可 在组件的RENDER中，把传递给PROVIDE&gt;的子元素渲染 1234567891011121314151617181920212223import React from 'react';import PropsTypes from 'prop-types';class Provider extends React.Component&#123; //=&gt;设置上下文信息类型 static childContextTypes = &#123; store:PropsTypes.object &#125; //=&gt;设置上下文信息值 getChildContext()&#123; return &#123; store:this.props.store &#125; &#125; constructor(props,context)&#123; super(props,context) &#125; render()&#123; return this.props.children; &#125;&#125; connect CONNECT：高阶组件（基于高阶函数：柯理化函数）创建的组件就是高阶组件 @PARAMSmapStateToProps：回调函数，把REDUX中的部分状态信息挂载到指定组件的属性上1234function mapStateToProps(state)&#123; //=&gt;state:REDUX容器中的状态信息 return &#123;&#125;; //=&gt;RETURN对象中有啥，就把啥挂载到属性上&#125; mapDispatchToProps：回调函数，把一些需要派发的任务方法也挂载到组件的属性上123456789function mapDispatchToProps(dispatch)&#123; //=&gt;dispatch:store中的dispatch return &#123; init()&#123; dispatch(&#123;...&#125;); &#125; &#125;; //=&gt;RETURN啥就把啥挂载到属性上（返回的方法中有执行dispatch派发任务的操作）&#125; @RETURN 返回一个新的函数 CONNECT-HOT CONNECT-HOT @PARAMS 传递进来的是要操作的组件，我们需要把指定的属性和方法都挂载到当前组件的属性上 @RETURN 返回一个新的组件Proxy（代理组件），在代理组件中，我们要获取Provider在上下文中存储的store，紧接着获取store中的state和dispatch，把mapStateToProps、mapDispatchToProps回调函数执行，接收返回的结果，在把这些结果挂载到Component这个要操作组件的属性上 1234567891011121314151617181920212223242526272829303132333435363738394041 function connect(mapStateToProps, mapDispatchToProps)&#123; return function connectHot(Component)&#123; return class Proxy extends React.Component&#123; //=&gt;获取上下文中的STORE static contextType = &#123; store: PropsTypes.object &#125; constructor(props,context)&#123; super(props,context) this.state = this.queryMountProps(); &#125; //=&gt;基于REDUX中的SUBSCRIBE向事件池中追加一个方法，当容器中状态改变，我们需要重新获取最新的状态信息，并且重新把COMPONENT渲染，把最新的状态信息通过属性传递给COMPONENT componentDidMount()&#123; this.context.store.subscribe(() =&gt; &#123; this.setState(this.queryMountProps()); &#125;); &#125; //=&gt;从REDUX中获取最新的信息，基于回调函数筛选，返回的是需要挂载到组件属性上的信息 queryMountProps = ()=&gt;&#123; let &#123; store &#125; = this.context, state = store.getState(); let propsState = typeof mapStateToProps === 'function' ? mapStateToProps(state) : &#123;&#125;; let porpsDispatch = typeof mapDispatchToProps == 'function' ?mapDispatchToProps(store.dispatch) : &#123;&#125; return &#123; ...propsState, ...propsDispatch &#125; &#125; //=&gt;渲染COMPONENT组件，并且把获取的信息（状态、方法）挂载到组件属性上（单独调取POXY组件的是时候传递的属性也给COMPONENT） render()&#123; return &lt;Component &#123;...this.state&#125; &#123;...this.props&#125;/&gt; &#125; &#125; &#125;&#125;export &#123; Provider, connect&#125;]]></content>
      <categories>
        <category>redux</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux03]]></title>
    <url>%2F2019%2F05%2F06%2Fredux03%2F</url>
    <content type="text"><![CDATA[redux梳理 createStore：创建REDUX容器的 @PARAMS reducer：函数 @RETURN store : { getState, dispatch, subscribe } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function createStore(reducer)&#123; //=&gt;创建一个STORE，STATE用来存储管理的状态信息，LISTEN-ARY用来存储事件池中的方法 //=&gt;STATE不用设置初始值，因为第一次DISPATCH执行REDUCER，STATE没有值，走的是REDUCER中赋值的默认值信息，我们自己会在创建容器的时候就把DISPATCH执行一次! let state, listenAry = []; //=&gt;DISPATCH：基于DISPATCH实现任务派发 function dispatch(action)&#123; //1.执行REDUCER，修改容器中的状态信息（接收REDUCER的返回值，把返回的信息替换原有的STATE），值得注意的是：我们是把返回值全部替换STATE，所有要求REDUCER中在修改状态之前，要先把原始的状态信息克隆一份，在进行单个的属性修改 state = reducer(state,action); //2.容器中状态信息经过REDUCER修改后，通知事件池中的方法依次执行 for(let i=0;i &lt; listenAry.length; i++)&#123; let item = listenAry[i]; if (typeof item === 'function') &#123; item(); &#125; else &#123; listenAry.splice(i, 1); i--; &#125; &#125; &#125; //=&gt;GET-STATE：获取容器中的状态信息 function getState()&#123; //1.我们需要保证返回的状态信息不能和容器中的STATE是同一个堆内存（否则外面获取状态信息后，直接就可以修改容器中的状态了，这不符合DISPATCH-&gt;REDUCER才能改状态的规范） /*//[浅克隆] AAAFFF111:&#123;vote:BBBFFF111&#125; &#123;...state&#125; =&gt; AAAFFF222:&#123;vote:BBBFFF111&#125;*/ return JSON.parse(JSON.stringify(state));//=&gt;深度克隆对象 &#125; dispatch(&#123;type: '$$INIT_DEFAULT_STATE'&#125;);//=&gt;创建容器的时候执行一次DISPATCH，目的是把REDUCER中的默认状态信息赋值给REDUX容器中的状态 //=&gt;SUBSCRIBE：向事件池中追加方法 function subscribe(fn)&#123; //1.向容器中追加方法（重复验证） let isExit = listenAry.includes(fn); !isExit ? listenAry.push(fn) : null; //2.返回一个方法:执行返回的方法会把当前绑定的方法在事件池中移除掉 return function unsubscribe()&#123; let index = listenAry.indexOf(fn) // listenAry.splice(index, 1);//=&gt;可能会引发数组塌陷 listenAry[index] = null; &#125; &#125; return &#123; dispatch, getState, subscribe &#125;&#125; combineReducers：REDUCER合并的方法 @PARAMS 对象，对象中包含了每一个版块对象的&gt;REDUCER =&gt;{xxx:function reducer…} @RETURN 返回的是一个新的REDUCER函数（把这个&gt;值赋值给CREATE-STORE） 特殊处理：合并REDUCER之后，REDUX容器中的&gt;STATE也变为以对应对象管理的模式 =&gt;{xxx:{}&gt;…} 123456789101112131415161718192021222324function combineReducers(reducers)&#123; //=&gt;REDUCERS:传递进来的REDUCER对象集合 /* * &#123; * vote:function vote(state=&#123;n:0,m:0&#125;,action)&#123;... return state;&#125;, * personal:function personal(state=&#123;baseInfo:''&#125;,action)&#123;... return state;&#125; * ... * &#125; */ return function reducer(state = &#123;&#125;,action)&#123; //=&gt;DISPATCH派发执行的时候，执行的是返回的REDUCER，这里也要返回一个最终的STATE对象替换原有的STATE，而且这个STATE中包含每个模块的状态信息 =&gt;&#123;vote:...,personal:...&#125; //=&gt;我们所谓的REDUCER合并，其实就是DISPATCH派发的时候，把每一个模块的REDUCER都单独执行一遍，把每个模块返回的状态最后汇总在一起，替换容器中的状态信息 let newState = &#123;&#125;; for(let key in reducers)&#123; if(!reducers.hasOwnProperty(key)) break; //=&gt;reducers[key]：每个模块单独的REDUCER //=&gt;state[key]：当前模块在REDUX容器中存储的状态信息 //=&gt;返回值是当前模块最新的状态，把它在放到NEW-STATE中 new[key] = reducers[key](state,action) &#125; return newState; &#125;&#125;]]></content>
      <categories>
        <category>redux</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux02]]></title>
    <url>%2F2019%2F05%2F04%2Fredux02%2F</url>
    <content type="text"><![CDATA[REACT-REDUX REACT-REDUX 是把redux进一步封装，适配react项目，让redux操作更简洁 STORE文件夹中的内容和REDUX一模一样 在组件调取使用的时候可以优化一些步骤 与传统的react相比 导出的不在是我们创建的组件，而是基于CONNECT构造后的高阶组件 1export default connect([mapStateToProps], [mapDispatchToProps])([自己创建的组件]) 以前我们基于SUBSCRIBE向事件池追加方法，如果容器状态信息发生改变，就会执行事件池里面的方法，达到组件重新渲染的目的； REACT-REDUX帮我们优化redux的使用：“所有用到REDUX容器状态信息的组件，都会向事件池中追加一个方法，当状态信息改变，通知方法执行，把最新的状态信息作为属性传递给组件，组件的属性值改变了，组件也会重新渲染” Provider 根组件 作用就是把创建的STORE可以供内部任何后代组件使用（基于上下文完成的） provider 组件中只允许出现一个子元素 把项目的store基于属性传递给Provider（这样后代组件中都可以方便简洁的使用这个store） connect 高阶组件1234567891011121314151617181920212223export default connect([mapStateToProps], [mapDispatchToProps])([自己创建的组件])/*//=&gt;把REDUX容器中的状态信息遍历，赋值给当前组件的属性（state）let mapStateToProps = state =&gt; &#123; //=&gt;state:就是REDUX容器中的状态信息 //=&gt;我们返回的是啥，就把它挂载到当前组件的属性上（REDUX存储很多信息，我们想用啥就返回啥即可） return &#123; ...state.vote &#125;;&#125;;*//*//=&gt;把REDUX中的DISPATCH派发行为遍历，也赋值给组件的属性（ActionCreator）let mapDispatchToProps = dispatch =&gt; &#123; //=&gt;dispatch:STORE中存储的DISPATCH方法 //=&gt;返回的是啥，就相当于把啥挂载到组件的属性上（一般我们挂载一些方法，这些方法中完成了DISPATCH派发任务操作） return &#123; init(initData) &#123; dispatch(action.vote.init(initData)); &#125; &#125;;&#125;;export default connect(mapStateToProps, mapDispatchToProps)(VoteBase);*/ VoteBase12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import React from 'react';import &#123;connect&#125; from 'react-redux';import action from '../../store/action'/* * 相对于传统的REDUX，我们做的步骤优化 * 1. 导出的不在是我们创建的组件，而是基于CONNECT构造后的高阶组件 * export default connect([mapStateToProps], [mapDispatchToProps])([自己创建的组件]); * * 2. REACT-REDUX帮我们做了一件非常重要的事情：以前我们需要自己基于SUBSCRIBE向事件池追加方法，以达到容器状态信息改变，执行我们追加的方法，重新渲染组件的目的，但是现在不用了，REACT-REDUX帮我们做了这件事：“所有用到REDUX容器状态信息的组件，都会向事件池中追加一个方法，当状态信息改变，通知方法执行，把最新的状态信息作为属性传递给组件，组件的属性值改变了，组件也会重新渲染” */class VoteBase extends React.Component &#123; /*constructor(props) &#123; super(props); /!* * 真实项目中我们会把REDUX容器中的状态信息获取到，赋值给组件的状态或者是属性(REACT-REDUX)，这么做的目的是：当REDUX中的状态改变，我们可以修改组件内部的状态，从而达到重新渲染组件的目的 *!/ let reduxState = this.props.store.getState().vote; this.state = &#123; ...reduxState //=&gt;包含title/n/m所有管理的属性 &#125;; &#125; //=&gt;在第一次加载执行，通过行为派发(VOTE_INIT)把REDUX中的信息赋值初始值 componentWillMount() &#123; this.props.store.dispatch(action.vote.init(&#123; title: '我长的帅不帅！', n: 0, m: 100 &#125;)); let reduxState = this.props.store.getState().vote; this.setState(&#123;...reduxState&#125;); &#125; //=&gt;向发布订阅事件池中追加一个方法：监听REDUX容器中状态改变，状态改变重新渲染组件 componentDidMount() &#123; this.props.store.subscribe(() =&gt; &#123; let reduxState = this.props.store.getState().vote; this.setState(&#123;...reduxState&#125;); &#125;); &#125;*/ constructor(props) &#123; super(props); console.log(this.props); &#125; componentWillMount() &#123; this.props.init(&#123; title: '我长的帅不帅?', n: 0, m: 100 &#125;); &#125; render() &#123; let &#123;title, n, m&#125; = this.props; return &lt;div className='panel panel-default'&gt; &lt;div className='panel-heading'&gt; &lt;h3 className='panel-title'&gt; &#123;title&#125; &lt;/h3&gt; &lt;/div&gt; &lt;div className='panel-body'&gt; 支持人数：&lt;span&gt;&#123;n&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt; 反对人数：&lt;span&gt;&#123;m&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;; &#125;&#125;export default connect(state =&gt; (&#123;...state.vote&#125;), action.vote)(VoteBase);//=&gt;REACT-REDUX帮我们做了一件事情，把ACTION-CREATOR中编写的方法（返回ACTION对象的方法），自动构建成DISPATCH派发任务的方法，也就是mapDispatchToProps这种格式 VoteHandle12345678910111213141516171819202122import React from 'react';import &#123;connect&#125; from 'react-redux';import action from '../../store/action';class VoteHandle extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; let &#123;support, against&#125; = this.props; return &lt;div className='panel-footer'&gt; &lt;button className='btn btn-success' onClick=&#123;support&#125;&gt;支持 &lt;/button&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;button className='btn btn-danger' onClick=&#123;against&#125;&gt;反对 &lt;/button&gt; &lt;/div&gt;; &#125;&#125;export default connect(state =&gt; (&#123;...state.vote&#125;), action.vote)(VoteHandle); action ACTION中处理的事情暂时感觉很无聊：就是封装几个方法（都是需要DISPATCH派发任务修改状态时候执行的方法），方法返回的是当前派发任务时候传递的ACTION对象REACT-REDUX中才会体验到这个封装的乐趣 action-types123456//=&gt;VOTEexport const VOTE_INIT = 'VOTE_INIT';//=&gt;数据初始化export const VOTE_SUPPORT = 'VOTE_SUPPORT';//=&gt;支持export const VOTE_AGAINST = 'VOTE_AGAINST';//=&gt;反对//=&gt;PERSONAL index.js12345678import vote from './vote';// import personal from './personal';let action = &#123; vote // personal&#125;;export default action; vote.js123456789101112131415161718192021import * as TYPE from '../action-types';let vote = &#123; support()&#123; return &#123; type: TYPE.TYPE.VOTE_SUPPORT &#125; &#125;, against() &#123; return &#123; type: TYPE.VOTE_AGAINST &#125;; &#125;, init(initData = &#123;&#125;) &#123; return &#123; type: TYPE.VOTE_INIT, ...initData &#125;; &#125;&#125;export default vote; reducerindex.js 合并REDUCER,为了保证每一个版块管理的状态信息不冲突,在REDUX中按照指定的名称单独划分版块的状态12345678910&#123; vote:&#123; title:'', n:0, m:0 &#125;, personal:&#123; //=&gt;以合并时候指定的属性名为主，作为最后划分管理的名字 &#125;&#125; 12345678import &#123; combineReducers &#125; from 'react';import vote from './vote';// import personal from './personal';let reducer = combineReducers(&#123; vote&#125;)export default reducer; vote12345678910111213141516171819202122232425262728293031import * as TYPE from '../action-types';/* * 1. 如果REDUX中原有的状态不存在,我们会设置一个初始值 */ export default function vote(state=&#123; title: '', n: 0, m: 0 &#125;,action)&#123; switch(action.type)&#123; case TYPE.VOTE_SUPPORT: state = &#123;...state,n:state.n + 1&#125; break; case TYPE.VOTE_AGAINST: state = &#123;...state, m: state.m + 1&#125;; break; case TYPE.VOTE_INIT: //=&gt;初始化的时候ACTION行为对象中可能不仅有TYPE,而且还有其它需要初始化的信息值，例如：&#123;TYPE:...,TITLE:xxx,N:xx,M:xx...&#125; /*state = &#123;...state&#125;; for (let attr in action) &#123; if (action.hasOwnProperty(attr)) &#123; if (attr === 'type') continue; state[attr] = action[attr]; &#125; &#125;*/ let &#123;title = '', n = 0, m = 0&#125; = action; state = &#123;...state, title, n, m&#125;; break; &#125; &#125;]]></content>
      <categories>
        <category>redux</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router]]></title>
    <url>%2F2019%2F04%2F29%2Freact-router%2F</url>
    <content type="text"><![CDATA[HashRouter 当前项目一旦使用HASH-ROUTER，则默认在页面的地址后面加上“#/”，也就是HASH默认值是一个斜杠，我们一般让其显示首页组件信息内容 HASH-ROUTER中只能出现一个子元素 HASH-ROUTER机制中，我们需要根据哈希地址不同，展示不同的组件内容，此时需要使用ROUTE ROUTE PATH：设置匹配地址，但是默认不是严格匹配，当前页面哈希地址只要包含完整的它（内容是不变的），都能被匹配上 PATH=’/‘ ：和它匹配的地址只有要斜杠即可（都能和它匹配） PATH=’/user’：“#/user/login”也可以匹配，但是“#/user2”这个无法匹配 COMPONENT：一但哈希值和当前ROUTE的PATH相同了，则渲染COMPONENT指定的组件 EXACT：让PATH的匹配严谨和严格一些（只有URL哈希值和PATH设定的值相等才可以匹配到） PATH=’/‘：“#/”匹配，但是“#/user”就不再匹配了 STRICT RENDER：当页面的哈希地址和PATH匹配，会把RENDER规划的方法执行，在方法中一般做“权限校验”（渲染组件之前验证是否存在权限，不存在做一些特殊处理） 默认情况下，会和每一个ROUTE都做校验（哪怕之前已经有校验成功的），SWITCH组件可以解决这个问题，和SWITCH CASE一样，只要有一种情况校验成功，就不在向后校验了 使用REACT路由实现SPA 安装路由 $ yarn add react-router-dom 3及以前版本称为react-router 4及最新版本称为react-router-dom 学习REACT路由 http://reacttraining.cn/web/api/ BrowserRouter VS HashRouter它是两种常用的路由实现思想。 BrowserRouter浏览器路由 HashRouter哈希路由 BrowserRouter 它是基于H5中history API(pushState, replaceState , popstate)来保持UI和URL的同步，真实项目中应用的不多，一般只有当前项目是基于服务器端渲染的，我们才会使用浏览器路由,如： http://www.demo.com/ http://www.demo.com/peraonal/ http://www.demo.com/peraonal/login/ HashRouter 哈希路由是依据相同的页面地址，不同的哈希值，来规划当前页面中的哪一个组件呈现渲染，它基于原生JS构造了一套类似于history API的机制，每一次路由切换都是基于 history stack 完成的！ http://www.demo.com/#/ http://www.demo.com/#/peraonal http://www.demo.com/#/peraonal/login12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 import React from 'react';import ReactDom, &#123; render &#125; from 'react-dom';import &#123;HashRouter,Route,Redirect,Switch&#125; from 'react-router-dom'import A from './component/A';import B from './component/B';import C from './component/C';class App extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return( &lt;HashRouter&gt; &lt;switch&gt; &lt;Route path="/" exact component = &#123;A&#125;/&gt; &lt;Route path="/user" component=&#123;B&#125;/&gt; &lt;Route path="/pay" render=&#123;()=&gt;&#123; let flag = localStorage.getItem('FLAG');; if (flag &amp;&amp; flag === 'SAFE') &#123; return &lt;C/&gt;; &#125; return '当前环境不安全，不利于支付'; &#125; &#125;/&gt; &#123;/*上述都设置完成后，会在末尾设置一个匹配：以上都不符合的情况下，我们认为路由地址是非法的地址，我们做一些特殊处理（ROTUE不设置PATH是匹配所有地址规则的）*/&#125; &#123;/*&lt;Route render=&#123;() =&gt; &#123; return &lt;div&gt;404&lt;/div&gt;; &#125;&#125;/&gt;*/&#125; &#123;/* * 也可以基于REDIRCT进行重定向 * TO [STRING]：重新定向到新的地址 * TO [OBJECT]：重新定向到新的地址，只不过指定了更多的信息 * &#123; * PATHNAME：定向的地址 * SEARCH：给定向的地址问号传参（结合当前案例，真实项目中，我们有时候会根据是否存在问号参数值来统计是正常进入首页还是非正常跳转过来的，也有可能根据问号传参值做不同的事情） * STATE：给定向后的组件传递一些信息 * &#125; * * PUSH：如果设置了这个属性，当前跳转的地址会加入到HISTORY STACK中一条记录 * FROM：设定当前来源的页面地址 * &lt;Redirect from='/custom' to='/custom/list'/&gt; * 如果当前请求的HASH地址是“/custom”，我们让其重定向到“/custom/list” */&#125; &#123;/*&lt;Redirect to='/?lx=404'/&gt;*/&#125; &lt;Redirect to=&#123;&#123; pathname: '/', search: '?lx=404' &#125;&#125;/&gt; &lt;/switch&gt; &lt;/HashRouter&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>路由</category>
      </categories>
      <tags>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux01]]></title>
    <url>%2F2019%2F04%2F27%2Fredux01%2F</url>
    <content type="text"><![CDATA[redux基本概念createStore 创建容器：需要把REDUCER传递进来 reducer作用 记录所有状态修改的信息（根据标识action.type 设置修改状态） 修改容器中的状态信息 参数 state: 容器中原有的状态信息（如果第一次使用，没有原有状态，我们需要赋予一个默认值） action：dispatch任务派发时传递的行为对象（这个对象必有一个type属性，是操作的行为标识，REDUCER就是根据这个行为标识来识别该如何修改状态信息）1234567891011121314import &#123;createStore&#125; from 'redux';let reducer = (state = &#123;n: 0, m: 0&#125;, action) =&gt; &#123; switch (action.type) &#123; case 'VOTE_SUPPORT': state = &#123;...state, n: state.n + 1&#125;; break; case 'VOTE_AGAINST': state = &#123;...state, m: state.m + 1&#125;; break; &#125; return state;//=&gt;只有把最新的STATE返回，原有的状态才会被修改&#125;;let store = createStore(reducer); store createStore(reducer)返回的store提供了三个方法 dispatch：派发行为（传递一个对象，对象中有一个TYPE属性） 通知reducer修改状态信息 subscribe：事件监听，当reducer 容器状态变化 触发事件 getState：获取最新管理的状态信息。 redux简单应用Vote123456789101112131415161718192021222324252627import React from 'react';import PropTypes from 'prop-types';import VoteBody from "./VoteBody";import VoteFooter from "./VoteFooter";export default class Vote extends React.Component&#123; // 默认props static defaultProps = &#123; title:'', count:&#123; m:0, n:0 &#125; &#125; constructor(props)&#123; super(props) &#125; render()&#123; let &#123;store&#125; = this.props return &lt;section className=&#123;'panel panel-default'&#125; style=&#123;&#123;width: '50%', margin: '20px auto'&#125;&#125;&gt; &lt;VoteBody store=&#123;store&#125;/&gt; &lt;VoteFooter store=&#123;store&#125;/&gt; &lt;/section&gt; &#125;&#125; VoteBody1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';import PropTypes from 'prop-types';import React from 'react';import PropTypes from 'prop-types';export default class VoteBody extends React.Component&#123; constructor(props)&#123; super(props) // 初始化状态 let &#123;store:&#123;getState&#125;&#125; = this.props, &#123;n,m&#125; = getState(); this.state = &#123; n, m &#125; &#125; componentDidMount()&#123; let &#123;store : &#123;getState,subscribe&#125;&#125; = this.props; let unsubscribe = subscribe(()=&gt;&#123; // 当reducer接收到 dispatch 传来的action对象，改变状态时，函数执行，刷新组件状态 let &#123;n, m&#125; = getState(); this.setState(&#123; n, m &#125;); &#125;) //unsubscribe(); 把当前追加的方法移除，解除绑定的方式 &#125; render()&#123; let &#123;n,m&#125; = this.state; let rate = (n / (n+m)) * 100; isNaN(rate) ? rate = 0 : null; return &lt;div className=&#123;'panel-body'&#125;&gt; 支持人数：&lt;span&gt;&#123;n&#125;&lt;/span&gt; &lt;br/&gt; 反对人数：&lt;span&gt;&#123;m&#125;&lt;/span&gt; &lt;br/&gt; 支持比率：&lt;span&gt;&#123;rate.toFixed(2) + '%'&#125;&lt;/span&gt; &lt;/div&gt; &#125; &#125; VoteFooter12345678910111213141516171819202122232425import React from 'react';import PropTypes from 'prop-types';export default class VoteFooter extends React.Component&#123; constructor(props)&#123; super(props) &#125; render()&#123; let &#123;store: &#123;dispatch&#125;&#125; = this.props; return &lt;div className=&#123;'panel-footer'&#125;&gt; &lt;button className=&#123;'btn btn-success'&#125; onClick = &#123;()=&gt;&#123; dispatch(&#123; type: 'VOTE_SUPPORT' &#125;) &#125;&#125;&gt;支持&lt;/button&gt; &amp;nbsp;&amp;nbsp; &lt;button className=&#123;'btn btn-danger'&#125; onClick=&#123;() =&gt; &#123; dispatch(&#123; type: 'VOTE_AGAINST' &#125;); &#125;&#125;&gt;反对 &lt;/button&gt; &lt;/div&gt; &#125;&#125;]]></content>
      <categories>
        <category>redux</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js调试console]]></title>
    <url>%2F2019%2F04%2F24%2Fjs%E8%B0%83%E8%AF%95console%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Web开发最常用的高度就是 console.log ，虽然 console.log 占有一席之地，但很多人并没有意识到 console 本身除了基本 log 方法之外还有很多其他方法。 适当使用这些方法可以使调试更容易，更快速，更直观。 console.log()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在console.log中除了常用的打印功能，如console.log(object)用来查看对象，也可以console.log(object,otherObject,string)这样对象和字符串都会整齐的记录下来。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格式化功能cosnole.log(msg,values)，有点像java中的println。123console.log('I like %s but I do not like %s','Skittles',;pus)// 会得到下面结果I like Skittles but I do not like pus. 这里面用到了占位符，常见的占位符有： %o（字母o） 接收对象 %s 接收字符串 %d 小数或整数 %c css首位占位符，后面的参数必须是css语句，用来对输出的内容进行css渲染，常见的方式有：文字样式，图片输出。12console.log('I am a %cbutton', 'color: white; background-color: orange; padding: 2px 5px; border-radius: 2px');// 后面的css样式 会应用在 字符串 ‘button’上，即占位符 %c 后面的内容 console.dir()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在大多数情况下，console.dir() 的函数非常类似于 log()，尽管它看起来略有不同。对于对象console.log()和console.dir()都可以清晰的打印对象的结构。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当查看dom元素、节点元素时，console.log()会打印出html的结构，而console.dir()则可以清晰地展示d元素的层级结构1const element = document.getElementById('#2x-container') console.log console.dir这是一种更客观地看待元素的方式。有时候，这可能是您真正想要的，更像是检查元素。 console.warn()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warn()是可以与log()相互替换，我们可以以log相同的用法使用warn()。唯一的区别就是打印的内容在控制台的颜色不同。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，还有一个优势，因为输出是警告而不是信息，所以你可以过滤掉所有console.log并仅保留console.warn。 这对于偶尔会在浏览器中输出大量无用废话的应用程序尤其有用。 console.table()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.table()函数旨在以一种比仅仅转出原始对象数组更整洁的方式显示表格数据。列如：123456789101112131415161718192021const data = [&#123; id: "7cb1-e041b126-f3b8", seller: "WAL0412", buyer: "WAL3023", price: 203450, time: 1539688433&#125;,&#123; id: "1d4c-31f8f14b-1571", seller: "WAL0452", buyer: "WAL3023", price: 348299, time: 1539688433&#125;,&#123; id: "b12c-b3adf58f-809f", seller: "WAL0012", buyer: "WAL2025", price: 59240, time: 1539688433&#125;]; 用console.table()输出： 第二个可选参数是所需列的列表。显然，所有列都是默认值，但我们也可以这样做:1console.table(data, ["id", "price"]); console.table()只能处理最多1000行，因此它可能不适合所有数据集。 console.assert()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert() 与 log() 是相同的函数，assert()是对输入的表达式进行断言，只有表达式为false时，才输出相应的信息到控制台，示例如下：12var arr = [1, 2, 3];console.assert(arr.length === 4); 条件必须为false，断言才会执行， console.count()count()只是作为一个计数器，或者作为一个命名计数器，可以统计代码被执行的次数。12345678910111213141516171819for(let i = 0; i &lt; 10000; i++) &#123; if(i % 2) &#123; console.count('odds'); &#125; if(!(i % 5)) &#123; console.count('multiplesOfFive'); &#125;&#125;/* multiplesOfFive: 1VM228:3 odds: 1VM228:3 odds: 2VM228:3 odds: 3VM228:6 multiplesOfFive: 2VM228:3 odds: 4VM228:3 odds: 5VM228:6 multiplesOfFive: 3... */ console.trace()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trace() 在简单的数据中很难演示。当您试图在类或库中找出是哪个实际调用者导致了这个问题时，它的优势就显现出来了。 例如，可能有 12 个不同的组件调用一个服务，但是其中一个组件没有正确地设置依赖项1234567891011export default class CupcakeService &#123; constructor(dataLib) &#123; this.dataLib = dataLib; if(typeof dataLib !== 'object') &#123; console.log(dataLib); console.trace(); &#125; &#125; ...&#125; 这里使用 console.log() 仅告诉我们传递数据dataLib是什么 ，而没有具体的传递的路径。不过，console.trace() 会非常清楚地告诉我们问题出在 Dashboard.js，我们可以看到是 new CupcakeService(false) 导致错误。 console.time()console.time()是一个用于跟踪操作时间的专用函数，它是跟踪 JavaScript执行时间的好方法。12345678var sum = 0;console.time('hello')for(let i=0;i&lt;10000;i++)&#123; sum += i;&#125;console.timeEnd('hello')// hello: 0.982177734375ms console.group()12345678910111213// this is the global scopelet number = 1;console.group('OutsideLoop');console.log(number);console.group('Loop');for (let i = 0; i &lt; 5; i++) &#123; number = i + number; console.log(number);&#125;console.groupEnd();console.log(number);console.groupEnd();console.log('All done now'); 将浏览器转换为编辑器将浏览器转换为文本编辑器。我们可以在 DOM 中的任何位置添加文本和从中删除文本。开发人员控制台并输入以下内容：1document.body.contentEditable=true 这将使内容可编辑。我们可以编辑DOM中的任何内容。 查找与DOM中的元素关联的事件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调试时，需要查找 DOM 中某个元素的事件侦听器感时，谷歌控制台了 getEventListeners使找到这些事件更加容易且直观。例如：getEventListeners($(‘selector’)) 返回一个对象数组，其中包含绑定到该元素的所有事件。要找到特定事件的侦听器，可以这样做:12getEventListeners($(‘selector’)).eventName[0].listener // 这里 eventName[0] 是一个数组，它列出了特定事件的所有事件。 监控事件 monitorEvents($(‘selector’)) 将监视与选择器的元素关联的所有事件，然后在它们被触发时将它们打印到控制台。例如，monitore($(#firstName)) 将打印 ID 为 firstName元素的所有事件。 monitorEvents($(‘selector’),’eventName’) 将打印与元素绑定的特定事件。 你可以将事件名称作为参数传递给函数。 这将仅记录绑定到特定元素的特定事件。 例如，monitorEvents($(‘#firstName’),’click’) 将打印绑定到ID为’firstName’的元素的所有 click 事件。 monitore($(selector)，[eventName1, eventName3’， .])将根据您自己的需求记录多个事件。与其传递单个事件名作为参数，不如传递包含所有事件的字符串数组。例如monitore($(#firstName)，[click, focus])将记录与ID firstName元素绑定的 click事件和focus事件。 unmonitorevent ($(selector)):这将停止监视和打印控制台中的事件。]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端渲染机制]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[引言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是JS引擎。不同的浏览器有不同的内核，Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的可能就是 Webkit 内核了，Webkit 内核是当下浏览器世界真正的霸主。 页面加载过程浏览器加载网页时，要经过以下几个要点： 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个IP的服务器发送HTTP请求 服务器收到后 处理并返回HTTP请求 浏览器得到返回的内容 例如：在浏览器输入 https://juejin.im/timeline，然后经过 DNS 解析， juejin.im对应的 IP 是 36.248.217.149（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。服务端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。 浏览器渲染过程浏览器渲染过程大体分为如下三部分： 1. 浏览器会解析三个东西： 一是HTML/SVG/XHTML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构。 二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像。 三是Javascript脚本，等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。 2. 解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。 Rendering Tree 渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。 CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element（也就是每个Frame）。 计算每个Frame 的位置，这又叫layout和reflow过程。最后通过调用操作系统Native GUI的API绘制。 构建DOM浏览器会遵守一套步骤将HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤： 浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。 将字符串转换成Token，例如： 、 等。Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。 生成节点对象并构建DOM 构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。注意：带有结束标签标识的Token不会创建节点对象。 构建CSSOM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。 构建渲染树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当浏览器构建完 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display:none 的，那么就不会在渲染树中显示。渲染过程中，如果遇到script标签就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作。JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。因为，JS还可以更改样式，所以必须等到完整的CSSOM渲染完成 布局与绘制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。 补充 async和defer的作用是什么？有什么区别? 情况1 &lt;scriptsrc=&quot;script.js&quot;&gt;&lt;/script&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。 情况2 &lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt; (异步下载)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行 情况3 &lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;(延迟执行)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后；在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。 为什么操作 DOM 慢 把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”,即渲染引擎和JS引擎之间的协作。因此，我们要尽量减少dom操作 你真的了解回流和重绘吗 渲染的流程基本上是这样（如下图黄色的四个步骤）：1.计算CSS样式 2.构建Render Tree 3.Layout – 定位坐标和大小 4.正式开画 Reflow和Repaint 重绘: DOM 的样式修改（修改了颜色或背景色）,浏览器不会重新计算元素的几何属性而重新布局，而是直接为该元素绘制新的样式 回流：对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）回流必定会发生重绘，重绘不一定会引发回流 常见引起回流属性和方法(改变元素的位置和尺寸大小) 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 如何减少回流、重绘 使用 transform 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量。 1234for(let i = 0; i&lt; 1000 ; i++)&#123; //获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop)&#125; 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。 性能优化策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。 js优化：&lt;script&gt;标签加上 defer属性 和 async属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。 defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。 async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。 css优化：&lt;link&gt;标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能 总结 浏览器工作流程：构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。 CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能监控]]></title>
    <url>%2F2019%2F04%2F19%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W3C性能小组引入的新的API window.performance，目前IE9以上的浏览器都支持。它是一个浏览器中用于记录页面加载和解析过程中关键时间点的对象。放置在global环境下，通过JavaScript可以访问到它。 使用性能API探测和兼容performance：1234var performance = window.performance || window.msPerformance || window.webkitPerformance;if(performance)&#123; // 支持性能 API&#125; performance api结构 performance.memory 显示内存的占用情况，是一个动态值： usedJSHeapSize：表示：JS 对象（包括V8引擎内部对象）占用的内存数 totalJSHeapSize： 可使用的内存 jsHeapSizeLimit： 内存大小限制 performance.navigation 显示页面的来源信息 redirectCount：重定向的话，页面通过几次重定向跳转而来，默认为0； type：表示页面打开的方式 0 表示 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等） 1 表示 TYPE_RELOAD 通过 window.location.reload() 刷新的页面 2 表示 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录） 255 表示 TYPE_UNDEFINED 非以上方式进入的页面 performance.onresourcetimingbufferfull属性是一个在resourcetimingbufferfull事件触发时会被调用的 event handler 。它的值是一个手动设置的回调函数，这个回调函数会在浏览器的资源时间性能缓冲区满时执行。 performance.timeOrigin 是一系列时间点的基准点，可以精确到万分之一毫秒 performance.timing:是一系列关键时间点，它包含了网络、解析等一系列的时间数据 12345678910111213141516171819202122232425262728293031323334353637383940414243// timing 下属性详情timing:&#123; // 同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同。 navigationStart: 1543806782096, // 上一个页面unload事件抛出时的时间戳。如果没有上一个页面，这个值会返回0。 uploadEventStart: 1543806782523, // 第一个HTTP重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0。 redirectStart: 0, redirectEnd: 0, // 浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前。 fetchStart: 1543806782096, // DNS 域名查询开始的UNIX时间戳。 // 如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和fetchStart一致。 domainLookupStart: 1543806782096, // DNS 域名查询完成的时间,如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 domainLookUpEnd: 1543806782096, // HTTP（TCP） 返回浏览器与服务器之间的连接建立时的时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart一致。 connectStart: 1543806782099, // HTTP（TCP） 域名查询结束的时间戳。 connectEnd: 1543806782227, // HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。 secureConnectionStart: 1543806782162, // 返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。 requestStart: 1543806782241, // 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。 responseStart: 1543806782516, // 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时 responseEnd: 1543806782537, // 当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间戳。 domLoading: 1543806782573, // 当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳。 domInteractive: 1543806783203, // 当解析器发送DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。 domContentLoadedEventStart: 1543806783203, // 当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。 domContentLoadedEventEnd: 1543806783216, // 当前文档解析完成，即Document.readyState 变为 'complete'且相对应的readystatechange 被触发时的时间戳 domComplete: 1543806783796, // load事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0。 loadEventStart: 1543806783796, // 当load事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0. loadEventEnd: 1543806783802&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以帮助我们获取页面的Domready时间、onload时间、白屏时间等，以及单个页面资源在从发送请求到获取到rsponse各阶段的性能参数。 对我们比较有用的页面性能数据大概包括如下几个，这些参数是通过上面的performance.timing各个属性的差值组成的，它是精确到毫秒的一个值，计算方法如下： 重定向耗时：redirectEnd - redirectStart DNS查询耗时 ：domainLookupEnd - domainLookupStart TCP链接耗时 ：connectEnd - connectStart HTTP请求耗时 ：responseEnd - responseStart 解析dom树耗时 ： domComplete - domInteractive 白屏时间 ：responseStart - navigationStart DOMready时间 ：domContentLoadedEventEnd - navigationStart onload时间：loadEventEnd - navigationStart，也即是onload回调函数执行的时间。 优化 重定向优化：重定向的类型分三种，301（永久重定向），302（临时重定向），304（Not Modified）。304是用来优化缓存，非常有用，而前两种应该尽可能的避免。 DNS优化: 一个是减少DNS的请求次数，另一个就是进行DNS预获取（Prefetching ） ;下面是DNS Prefetch的方法： 12345678&lt;html&gt;&lt;head&gt; &lt;title&gt;腾讯网&lt;/title&gt; &lt;link rel="dns-prefetch" href="//mat1.gtimg.com" /&gt; &lt;link rel="dns-prefetch" href="//inews.gtimg.com" /&gt; &lt;link rel="dns-prefetch" href="//wx.qlogo.cn" /&gt; &lt;link rel="dns-prefetch" href="//coral.qq.com" /&gt; &lt;link rel="dns-prefetch" href="//pingjs.qq.com" /&gt; TCP请求优化:TCP的优化大都在服务器端，前端能做的就是尽量减少TCP的请求数，也就是减少HTTP的请求数量。减少TCP请求的方式有两种，一种是资源合并，对于页面内的图片、css和js进行合并，减少请求量。另一种使用长链接，使用http1.1，在HTTP的响应头会加上 Connection:keep-alive。 使用Websocket进行通信，全程只需要建立一次TCP链接。 HTTP请求优化:使用内容分发网络（CDN）和减少请求。也可以使用本地缓存策略，尽量减少对服务器数据的重复获取。 渲染优化:在浏览器端的渲染过程，如大型框架，vue和react，它的模板其实都是在浏览器端进行渲染的，不是直出的html。这会导致白屏时间增加，在必要的情况下可以在服务端进行整个html的渲染，从而将整个html直出到我们的浏览器端，而非在浏览器端进行渲染。 script 外链加入到页面底部，也可以使用 defer 或 async 延迟执行。defer 和 async 的区别就是 defer 是有序的，代码的执行按在html中的先后顺序，而 async 是无序的，只要下载完毕就会立即执行。或者使用异步的编程方法，比如settimeout，也可以使用多线webworker，它们不会阻碍 DOM 的渲染。 12&lt;script async type="text/javascript" src="app1.js"&gt;&lt;/script&gt;&lt;script defer type="text/javascript" src="app2.js"&gt;&lt;/script&gt; 方法集合 performance.now() 返回一个当前页面执行的时间的时间戳，用来精确计算程序执行时间,比Date.now()精准；performance.now() 的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）。performance.timing.navigationStart + performance.now() 约等于 Date.now()。 12345//某一段代码执行了多少时间。let t0 = window.performance.now();doSomething();let t1 = window.performance.now();console.log("doSomething函数执行了" + (t1 - t0) + "毫秒.") performance.mark() mark方法用来自定义添加标记时间。使用方法如下 12345678910111213var nameStart = 'markStart';var nameEnd = 'markEnd';// 函数执行前做个标记window.performance.mark(nameStart);for (var i = 0; i &lt; n; i++) &#123; doSomething&#125;// 函数执行后再做个标记window.performance.mark(nameEnd);// 然后测量这个两个标记间的时间距离，并保存起来var name = 'myMeasure';window.performance.measure(name, nameStart, nameEnd);//保存后的值可以通过 performance.getEntriesByname( 'myMeasure' )或者 performance.getEntriesByType（'measure'）查询。 Performance.clearMeasures():从浏览器的性能输入缓冲区中移除自定义添加的 measure Performance.getEntriesByName():返回一个 PerformanceEntry 对象的列表，基于给定的 name 和 entry type Performance.getEntriesByType():返回一个 PerformanceEntry 对象的列表，基于给定的 entry type Performance.measure():在浏览器的指定 start mark 和 end mark 间的性能输入缓冲区中创建一个指定名称的时间戳 Performance.toJSON():是一个 JSON 格式转化器，返回 Performance 对象的 JSON 对象]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[跨域解决方案： jsonp （常用） cors （常用） window.name document.domain （特定场景） postMessage (H5) webpack proxy （webScoket） （常用） 什么是跨域？ 拿当前HTML页面的地址和在页面中AJAX请求的API地址做比较： 如果两个地址的协议域名端口号都相同，相当于HTML页面从同一个源下根据某个地址获取数据，属于“同源策略请求”，基于AJAX是可以直接请求到数据的！ 如果三者（协议域名端口号）只要有一个不一样，那么就是“非同源策略请求（跨域请求）”，使用AJAX不能直接获取数据了！ HTML页面的地址：http://localhost:8000/A.html AJAX请求的地址：http://localhost:8000/queryInfo HTML页面地址：http://localhost:63342/201802LESSON/%E5%85%AC%E5%BC%80%E8%AF%BE/%E8%B7%A8%E5%9F%9F/static/A.html AJAX请求接口地址：http://localhost:8000/queryInfo [报错] Failed to load http://localhost:8000/queryInfo: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:63342&#39; is therefore not allowed access. 跨域的普遍性？ 现在的项目一般都是前后端分离的，大部分公司都会把后台的程序用一个新的服务管理，把客户端程序也用一个新的服务管理，两个服务不是同一个源；这样就导致客户端是向其他源发送AJAX请求，跨域成为请求的阻碍问题； 同源：把客户端程序和服务器程序在一个服务中发布！ ======================================= JSONP 在客户端AJAX不允许直接的跨域请求，但是很多东西都可以直接的跨域，例如：script、link、img、iframe等（这些标签的SRC或者HREF设置任何一个资源请求地址，哪怕是其它源下的，也都没有跨域的限制，直接可以把内容获取到 [除非服务器做特殊处理了] =&gt;针对这个特点，真实项目中某些JS文件加载的都是CDN地址） CORS 跨域资源共享 主要是服务器设置：配置允许跨域的相关头部信息 1234567891011app.use((req, res, next) =&gt; &#123; res.header("Access-Control-Allow-Origin", "http://localhost:8000"); res.header("Access-Control-Allow-Credentials", true); res.header("Access-Control-Allow-Headers", "Content-Type,Content-Length,Authorization, Accept,X-Requested-With"); res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,HEAD,OPTIONS"); if (req.method === 'OPTIONS') &#123; res.send('OK!'); return; &#125; next();&#125;); 客户端 1234axios.defaults.withCredentials = true;//=&gt;xhr.withCredentials=true// axios在某些特定场景下，在发送真实请求之前都会发送一个预请求（OPTIONS）格式的，来验证是否允许跨域 弊端：只能指定一个允许源（不能用通配符和指定多个源），所以目前真实项目中基于CORS实现跨域资源共享是主流方案 WEBPACK代理（webpack proxy） 安装webpack-dev-server 配置代理： 1234567891011121314proxy: &#123; '/api': &#123; target: 'https://other-server.example.com', changeOrigin: true, secure: false, pathRewrite: &#123; '^/api' : '' &#125; &#125;, '/getInfo':&#123; target: 'https://other-server.example.com', changeOrigin: true &#125;&#125; 在CREATE-REACT-APP脚手架中，我们只需要在package.json中设置porxy代理属性，属性值是目标服务器的地址；在客户端发送请求的时候，请求的接口先保证是同源，如果当前源下没有这个接口，没关系，基于dev-server使用webscoket已经把目标代理服务器上的对应接口数据获取到了，所以直接请求同源下没有的接口，也可以获取数据! =============== 基于IFRAME实现跨域 iframe可以实现父页面嵌入子页面(父页面中可以基于js获取子页面中的内容) window.namename是window天生自带的属性，而且有一个特点，同源下，早X页面中设置name的值，页面关掉或者刷新，上次设置的值不消失，能够一直存储最后一次修改的值信息 document.domain只能处理主域相同，但是子域不同的情况v.qq.coms.qq.com postMessage]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node02]]></title>
    <url>%2F2019%2F04%2F14%2Fnode02%2F</url>
    <content type="text"><![CDATA[1.在本地项目中基于NPM/YARN安装第三方模块12345678910111213141516171819202122232425第一步：在本地项目中创建一个“package.json”的文件 作用：把当前项目所有依赖的第三方模块信息（包含：模块名称以及版本号等信息）都记录下来；可以在这里配置一些可执行的命令脚本等； 基于YARN会默认生成一个“配置清单”，只是信息没有手动创建的全面 npm init -y 或者 yarn init -y 创建配置清单的时候，项目目录中不应该出现中文和特殊符号，这样有可能识别不了第二步：安装 开发依赖：只有在项目开发阶段依赖的第三方模块 生产依赖：项目部署实施的时候，也需要依赖的第三方模块 [npm] npm install xxx --save 保存到配置清单的生产依赖中 --save-dev 保存到开发依赖中 [yarn] yarn add xxx 默认就是保存到生产依赖中 --dev / -D 保存到开发依赖中第三步：部署的时候“跑环境” 不要自己一个个的安装，只需要执行 npm install 或者 yarn install 即可，npm会自己先检测目录中是否有package.json文件，如果有的话，会按照文件中的配置清单依次安装=&gt;开发一个项目，我们生成一个配置清单“package.json”，当我们安装第三方模块使用的时候，把安装的模块信息记录到配置清单中，这样以后不管是团队协作开发还是项目部署上线，我们都没有必要把node_modules发文件发送给别人，只需要把配置清单传递给其它人即可，其他人拿到配置清单后，按照清单中依赖项及版本号，重新安装即可（重新安装：“跑环境”） package.json123456789101112131415161718&#123; &quot;name&quot;: &quot;0609DAY1&quot;, //=&gt;模块名称 &quot;version&quot;: &quot;1.0.0&quot;, //=&gt;版本号 &quot;description&quot;: &quot;&quot;, //=&gt;模块的描述 &quot;main&quot;: &quot;index.js&quot;, //=&gt;当前模块的主入口文件 &quot;dependencies&quot;: &#123; //=&gt;生产依赖 &quot;zepto&quot;: &quot;^1.2.0&quot; &#125;, &quot;devDependencies&quot;: &#123; //=&gt;开发依赖 &#125;, &quot;scripts&quot;: &#123; //=&gt;可执行脚本 &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 2.安装在本地和全局的区别123456789101112131415161718192021222324252627282930313233343536373839[安装在全局的特点] 1.所有的项目都可以使用这个模块 -&gt;容易导致版本冲突 -&gt;安装在全局的模块，不能基于CommonJS模块规范调取使用（也就是不能在JS中通过REQUIRE调取使用）[安装在本地的特点] 1.只能当前项目使用这个模块 -&gt;不能直接的使用命令操作（安装在全局可以使用命令）为啥安装在全局下可以使用命令? npm root / -g 查看本地项目或者全局环境下,NPM的安装目录 安装在全局目录下的模块，大部分都会生成一个xxx.cmd的文件，只要有这个文件，那么xxx就是一个可执行的命令（例如：yarn.cmd =&gt; yarn就是命令） @IF EXIST &quot;%~dp0\node.exe&quot; ( &quot;%~dp0\node.exe&quot; &quot;%~dp0\node_modules\yarn\bin\yarn.js&quot; %* ) ELSE ( @SETLOCAL @SET PATHEXT=%PATHEXT:;.JS;=;% node &quot;%~dp0\node_modules\yarn\bin\yarn.js&quot; %* )能否即安装在本地，也可以使用命令操作？ 可以，但是需要配置package.json中的scripts 1.把模块安装在本地，如果是支持命令操作的（会在node_modules的bin中生成xxx.cmd的命令文件，只不过这个文件无法在全局下执行 =&gt;不能直接用命令） 2.在package.json的scripts中配置需要执行的命令脚本 &quot;scripts&quot;: &#123; &quot;zxt&quot;: &quot;lessc -v&quot; 属性名自己设置即可，属性值是需要执行的命令脚本，根据需要自己编写(可以配置很多命令的) &#125; 3.npm run zxt / yarn zxt 这样的操作就是把配置的脚本执行 -&gt;首先到配置清单的scripts中查找 -&gt;找到把后面对应的属性值（执行脚本）执行 -&gt;执行脚本的时候，会到本地node_modules中的bin文件加查找，没有的话，在向NPM安装的全局目录下查找 3.NODE入门 NODE本身是基于CommonJS模块规范设计的，所以模块是NODE的组成 内置模块：NODE天生提供给JS调取使用的 第三方模块：别人写好的，我们可以基于NPM安装使用 自定义模块：自己创建一些模块 CommonJS模块化设计的思想（AMD/CMD/ES6 MODULE都是模块设计思想） 12345678910111213141516171819202122231.CommonJS规定，每一个JS都是一个单独的模块（模块是私有的：里面涉及的值和变量以及函数等都是私有的，和其它JS文件中的内容是不冲突的）2.CommonJS中可以允许模块中的方法互相的调用 B模块中想要调取A模块中的方法 =&gt;A导出 =&gt;B导入[导出] CommonJS给每一个模块（每个JS）中都设置了内置的变量/属性/方法 module：代表当前这个模块[object] module.exports：模块的这个“属性”是用来导出当前模块的属性和方法的 [object] exports：是内置的一个“变量”，也是用来导出当前模块属性方法的，虽然和module.exports不就是一个东西，但是对应的值是同一个(module.exports=exports 值都是对象)[导入] require：CommonJS提供的内置变量，用来导入模块的（其实导入的就是module.exports暴露出来的东西）；导入的值也是[object]类型的；CommonJS特点： 1. 所有代码都运行在模块作用域，不会污染全局作用域（每一个模块都是私有的，包括里面所有的东西也都是私有的，不会和其它模块产生干扰） 2. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。（为了保证性能，减少模块代码重复执行的次数） 3. 模块加载的顺序，按照其在代码中出现的顺序。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 案例：A/B/C三个模块A中有一个sum方法：实现任意数求和B中有一个avg方法：实现任意数求平均（先求和再求平均：B中用到A）C中调取B中的avg，实现 12,23,34,45,56,67,78,89 求平均数 1234require导入规则 require(&apos;./xxx&apos;) 或者 ../xxx 再或者 /xxx，这种自己制定路径的模式，都是为了导入自定义的模块，换句话说，想要导入自定义的模块，必须加路径 require(&apos;xxx&apos;) 首先到当前项目的node_modules中查找是否存在这个模块，不存在找node提供的内置模块（导入第三方或者内置的） __dirname：模块中这个内置变量是当前模块所在的绝对路径（具体到盘符：物理路径 例如：E:\201802LESSON\WEEK9\0609DAY1； 相对路径：WEEK9\0609DAY1 相对于根目录的路径；） filename：相对于dirname来讲，多了模块名称，例如：E:\201802LESSON\WEEK9\0609DAY1\C.js 4.NODE中的内置模块 http://nodejs.cn/api/ 【fs内置模块：实现I/O操作】 12345678910111213141516171819let fs = require(&apos;fs&apos;);1. fs.mkdir / fs.mkdirSync：创建文件夹，有Sync的是同步创建，反之没有是异步，想要实现无阻塞的I/O操作，我们一般都是用异步操作完成要处理的事情2. fs.readdir / fs.readdirSync：读取文件目录中的内容3. fs.rmdir ：删除文件夹4. fs.readFile：读取文件中的内容5. fs.writeFile：向文件中写入内容（覆盖写入：写入的新内容会替换原有的内容）6. fs.appendFile：追加写入新内容，原有的内容还在7. fs.copyFile：拷贝文件到新的位置8. fs.unlink：删除文件... URL内置模块url.parse(url[,flag])：把一个URL地址进行解析，把地址中的每一部分按照对象键值对的方式存储起来 HTTP内置模块let server = http.createServer(); //=&gt;创建WEB服务server.listen(); //=&gt;监听端口 注意：基于NODE创建后台程序，我们一般都创建一个server模块，在模块中实现创建WEB服务，和对于请求的处理（并且我们一般都会把server模块放到当前项目的根目录下） 服务器上有一堆项目代码，这堆项目代码中既可能有服务器端的程序代码，也有可能有客户端的程序代码，而客户端程序代码我们一般都放到static这个文件夹中 12345static 都是服务器端需要返回给客户端，由客户端浏览器渲染和解析的（前端项目：包括页面、CSS、JS、图片等）server.js 都是需要在服务器端基于NODE执行的（后端项目：一般只有JS） 我们创建的WEB服务需要处理两类请求： 1.静态资源文件的请求处理：想要文件 2.API接口的请求处理：想要数据 区别：第一类请求的地址中有后缀名，第二类没有后缀]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react05]]></title>
    <url>%2F2019%2F04%2F10%2Freact05%2F</url>
    <content type="text"><![CDATA[复合组件：父组件嵌套子组件传递信息的方式 父组件需要把信息传递给子组件“属性传递”：调取子组件的时候，把信息基于属性的方式传递给子组件（子组件PROPS中存储传递的信息）;这种方式只能父组件把信息传递子组件，子组件无法直接的把信息传递给父组件，也就是属性传递信息是单向传递的； 123456789export default class Vote extends React.Component &#123; render() &#123; let &#123;title, count&#125; = this.props; return &lt;section className=&#123;'panel panel-default'&#125; style=&#123;&#123;width: '50%', margin: '20px auto'&#125;&#125;&gt; &lt;VoteHead title=&#123;title&#125;/&gt; ... &lt;/section&gt;; &#125;&#125; 上下文传递 父组件先把需要给后代元素（包括孙子元素）使用的信息都设置好（设置在上下文中），后代组件需要用到父组件中的信息，主动去父组件中调取使用即可 12345678910111213141516171819202122232425262728293031323334353637 /* * 在父组件中 * 需要安装:prop-types * * 1. 设置子组件上下文属性值类型 * static childContextTypes = &#123;&#125;; * * 2. 获取子组件的上下文（设置子组件的上下文属性信息） * getChildContext()&#123;return &#123;&#125;&#125; */ //=&gt;父组件设置信息 static childContextTypes = &#123; //=&gt;设置上下文中信息值的类型 n: PropTypes.number, m: PropTypes.number &#125;; getChildContext() &#123; //-&gt;RETURN的是啥，相当相当于往上下文中放了啥 let &#123;count: &#123;n = 0, m = 0&#125;&#125; = this.props; return &#123; n, m &#125;; &#125;-------------------------------------------------------------------------- //=&gt;子组件主动获取需要的信息 static contextTypes = &#123; //=&gt;首先类型需要和设置时候类型一样，否则报错；并且你需要用啥，就写啥即可； n: PropTypes.number, m: PropTypes.number &#125;; constructor(props, context) &#123; super(props, context); &#125; render()&#123; let &#123;m,n&#125; = this.context; &#125; `属性 VS 上下文 属性操作起来简单，子组件是被动接收传递的值（组件内的属性是只读的），只能父传子（子传父不行，父传孙也需要处理：父传子，子再传孙）； 上下文操作起来相对复杂一些，子组件是主动获取信息使用的（子组件是可以修改获取到的上下文信息的，但是不会影响到父组件中的信息，其它组件不受影响）,一旦父组件设置了上下文信息，它后代组件都可以直接拿来用，不需要一层层的传递； 其实子组件也能修改父组件中的信息 利用回调函数机制：父组件把一个函数通过属性或者上下文的方式传递给子组件，子组件中只要把这个方法执行即可（也就是子组件中执行了父组件方法，还可以传递一些值过去），这样父组件在这个方法中，想把自己的信息改成啥就改成啥 平行组件 兄弟组件或者毫无关系的两个组件 方案一：让两个平行组件拥一个共同的父组件 父：Parent 子：A / B 父组件中有一些信息，父组件把一个方法传递给A，A中把方法执行（方法执行修改父组件信息值），父组件再把最新的信息传递给B即可，等价于A操作，影响了B 方案二：基于REDUX来进行状态管理，实现组件之间的信息传输（常用方案） REDUX可以应用在任何的项目中（VUE/JQ/RERACT的都可以），REACT-REDUX才是专门给REACT项目提供的方案]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2F2019%2F04%2F07%2F%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为一名前端开发者，我们经常会处理各种事件，比如常见的click、scroll、 resize等等。仔细一想，会发现像scroll、scroll、onchange这类事件会频繁触发，如果我们在回调中计算元素位置、做一些跟DOM相关的操作，引起浏览器回流和重绘，频繁触发回调，很可能会造成浏览器掉帧，甚至会使浏览器崩溃，影响用户体验。针对这种现象，目前有两种常用的解决方案：防抖和节流。 防抖（debounce） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓防抖，就是指触发事件后，就是把触发非常频繁的事件合并成一次去执行。即在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算。 例如：以我们生活中乘车刷卡的情景举例，只要乘客不断地在刷卡，司机师傅就不能开车，乘客刷卡完毕之后，司机会等待几分钟，确定乘客坐稳再开车。如果司机在最后等待的时间内又有新的乘客上车，那么司机等乘客刷卡完毕之后，还要再等待一会，等待所有乘客坐稳再开车。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体应该怎么去实现这样的功能呢？第一时间肯定会想到使用setTimeout方法，那我们就尝试写一个简单的函数来实现这个功能吧~ 1234567891011var debounce = function(fn,delaytime)&#123; var timeId; return function()&#123; var context = this, args = arguments; timeId &amp;&amp; clearTimeout(timeId); timeId = setTimeout(() =&gt; &#123; fn.apply(context,args) &#125;, delaytime); &#125;&#125; 思路解析 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行debounce函数之后会返回一个新的函数，通过闭包的形式，维护一个变量timeId，每次执行该函数的时候会结束之前的延迟操作，重新执行setTimeout方法，也就实现了上面所说的指定的时间内多次触发同一个事件，会合并执行一次。 上述代码中arguments只会保存事件回调函数中的参数，譬如：事件对象等，并不会保存fn、delayTime 使用apply改变传入的fn方法中的this指向，指向绑定事件的DOM元素。 节流（throttle） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓节流，是指频繁触发事件时，只会在指定的时间段内执行事件回调，即触发事件间隔大于等于指定的时间才会执行回调函数。 类比到生活中的水龙头，拧紧水龙头到某种程度会发现，每隔一段时间，就会有水滴流出。 说到时间间隔，大家肯定会想到使用setTimeout来实现，在这里，我们使用两种方法来简单实现这种功能：时间戳和setTimeout定时器。 时间戳123456789101112var throttle = function(fn,delaytime)&#123; var _start = Date.now(); return function()&#123; var _now = Date.now(), context = this, args = arguments; if(_now - _start &gt;= delaytime)&#123; fn.apply(context,args) _start = Date.now(); &#125; &#125;&#125; 通过比较两次时间戳的间隔是否大于等于我们事先指定的时间来决定是否执行事件回调。 定时器1234567891011121314var throttle = function(fn,delaytime)&#123; var flag; return function()&#123; var context = this, args = arguments; if(!flag)&#123; flag = setTimeout(()=&gt;&#123; fn.apply(context,args); // clearTimeout(timer) flag = false; &#125;,delaytime) &#125; &#125;&#125; 对比上述两种实现: 使用时间戳方式，页面加载的时候就会开始计时，如果页面加载时间大于我们设定的delayTime，第一次触发事件回调的时候便会立即fn，并不会延迟。如果最后一次触发回调与前一次触发回调的时间差小于delayTime，则最后一次触发事件并不会执行fn； 使用定时器方式，我们第一次触发回调的时候才会开始计时，如果最后一次触发回调事件与前一次时间间隔小于delayTime，delayTime之后仍会执行fn。 我们考虑把这两种方式结合起来，便会在第一次触发事件时执行fn，最后一次与前一次间隔比较短，delayTime之后再次执行fn。 最终节流实现123456789101112131415161718var throttle = function(fn,delaytime)&#123; var timer,_start = Date.now(); return function()&#123; var context = this, args = arguments, _now = Date.now(), remainTime = delaytime - (_now - _start); timer &amp;&amp; clearTimeout(timer); if(remainTime &lt;= 0)&#123; fn.apply(context,args) _start = Date.now(); &#125;else&#123; timer = setTimeout(function()&#123; fn.apply(context,args) &#125;,remainTime) &#125; &#125;&#125; 通过上面的分析，可以很明显的看出函数防抖和函数节流的区别： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;频繁触发事件时，函数防抖只会在最后一次触发事件只会才会执行回调内容，其他情况下会重新计算延迟事件，而函数节流便会很有规律的每隔一定时间执行一次回调函数。 requestAnimationFrame如果我们不考虑兼容性，追求精度比较高的页面效果，可以考虑试试html5提供的API requestAnimationFrame实现防抖和节流功能 与setTimeout相比，requestAnimationFrame的时间间隔是有系统来决定，保证屏幕刷新一次，回调函数只会执行一次，比如屏幕的刷新频率是60HZ，即间隔1000ms/60会执行一次回调。 12345678910111213var throttle = function(fn,delaytime)&#123; var flag; return function()&#123; if(!flag)&#123; requestAnimationFrame(function()&#123; fn(); flag = false; &#125;) &#125;else&#123; flag = true; &#125; &#125;&#125; 注意： 防抖和节流只是减少了事件回调函数的执行次数，并不会减少事件的触发频率。 防抖和节流并没有从本质上解决性能问题，我们还应该注意优化我们事件回调函数的逻辑功能，避免在回调中执行比较复杂的DOM操作，减少浏览器reflow和repaint。]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react04]]></title>
    <url>%2F2019%2F04%2F02%2Freact04%2F</url>
    <content type="text"><![CDATA[REACT基础知识复习（一）： REACT是FACE-BOOK公司开发的一款MVC版JS框架MVC：Model（数据层）、VIEW（视图层）、CONTROLLER（控制层）核心思想：通过数据的改变来影响视图的渲染（数据驱动） 基于脚手架 CREATE-REACT-APP 快速构建一个REACT工程项目结构自动安装REACT的核心组件：REACT/REACT-DOM自动安装WEBPACK，并且完成相关的配置： 区分了开发环境和生产环境 安装BABEL以及对应的语言解析包，可以把REACT和ES6进行编译处理 安装CSS/STYLE/FILE等加载器，处理CSS等合并压缩的问题 安装了ES-LINT，可以进行代码检测 安装了很多的插件，可以实现JS和CSS以及HTML的分离，打包，压缩等 安装了WEBPACK-DEV-SERVER，可以在开发环境下，编译后自动创建服务，打开浏览器，当代码修改后，自动保存编译，页面自动刷新渲染等 使用脚手架12345678把脚手架安装到全局环境下，以后应用命令操作，完成项目结构的搭建 $ npm install create-react-app -g创建项目结构目录 项目名遵循NPM发包命名规范：名字只能是/^[a-z0-9_-]$/ $ create-react-app 项目名特点：如果当前电脑安装了YARN，创建工程目录的时候，走的是YARN安装，YARN和NPM主体相同，但是处理起来还有一定的区别，所以我们以后继续向工程中安装模块以及执行配置脚本打包编译的时候，尽可能使用YARN，不建议和NPM混用 工程化目录 node_modules .bin 所有在本地可执行的命令脚本(react-scripts.cmd) … package.json 当前项目的配置清单 public 存放的是当前项目的HTML页面（有可能放一部分静态资源） index.html src 存放的是项目需要的所有JS或者静态资源等（包括组件、STORE、路由、数据模型、AJAX请求等等内容 “我们开发的内容基本上所有东西都在SRC中写”） index.js 当前项目的入口文件 暴露WEBPACK配置项 脚手架构建项目的时候，为了结构的美化，把所有的WEBPACK配置等都隐藏到了NODE_MODULES中（REACT-SCRIPTS中），真实项目中，我们经常会基于脚手架构建的结构自己在安装配置一些信息（例如：LESS处理的配置），此时我们需要把配置项暴露出来 $ yarn eject 此操作是不可逆转的（而且操作之前需要把所有修改的文件提交到GIT仓库中） config webpack.config.dev.js 开发环境下的WP配置 webpack.config.prod.js 生产环境下的WP配置 paths.js 基本配置项（包含项目的入口信息） scripts start.js / build.js / test.js 当我们执行yarn start/build/test的时候，执行的就是这三个JS文件 可执行的本地脚本命令$ yarn start 创建一个端口号为3000，协议为HTTP的WEB服务 按照webpack.config.dev.js把项目编译 打开浏览器，预览我们正在开发的项目 当项目文件修改的时候，自动重新编译，浏览器页面自动刷新，展示最新的效果 WINDOWS $ set HTTPS=true&amp;&amp;yarn start $ set PORT=1234&amp;&amp;yarn start MAC/LINUX $ HTTPS=true yarn start $ PORT=1234 yarn start $ yarn build 生成一个build文件夹，存放最后打包的文件 基于webpack.config.prod.js，把项目进行编译打包 部署上线的时候，只需要把buid中的内容发布即可 基于脚手架配置LESS 安装LESS和对应的加载器 $ yarn add less less-loader 修改开发和生产环境下的WEBPACK配置项 12345678910111213141516171819202122232425262728293031323334353637383940414243[DEV:159~193行]&#123; test: /\.(css|less)$/, use: [ require.resolve(&apos;style-loader&apos;), &#123; loader: require.resolve(&apos;css-loader&apos;), ... &#125;, ... &#123; loader: require.resolve(&apos;less-loader&apos;) &#125;, ],&#125;,[PROD:169~212行]&#123; test: /\.(css|less)$/, loader: ExtractTextPlugin.extract( Object.assign( &#123; fallback: &#123; loader: require.resolve(&apos;style-loader&apos;), options: &#123; hmr: false, &#125;, &#125;, use: [ &#123; loader: require.resolve(&apos;css-loader&apos;), ... &#125;, ... &#123; loader: require.resolve(&apos;less-loader&apos;), &#125; ], &#125;, extractTextPluginOptions ) ),&#125;, REACT基础知识复习（二）： REACT是基于独有的JSX语法实现视图（数据和HTML）渲染的 JSX语法A：JSX语法的渲染使用的是ReactDOM.render 1ReactDOM.render([JSX元素]，[指定的容器]，[回调函数：当我们把JSX放到指定容器内，触发执行的函数]); B：JSX = JAVASCRIPT + XML（HTML） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521. 不推荐存放JSX的容器是BODY（写BODY会报错），一般都是使用我么自己创建的一个元素（例如：创建#ROOT的DIV容器等）ReactDOM.render(&lt;h2&gt;hello world&lt;/h2&gt;, root);2. 不允许出现两个“根”元素，如果需要绑定复杂的结构，最外层嵌套一个容器做为根元素即可ReactDOM.render(&lt;h2&gt;hello world&lt;/h2&gt;&lt;h3&gt;哈哈&lt;/h3&gt;, root); =&gt;错误的ReactDOM.render(&lt;div&gt; &lt;h2&gt;hello world&lt;/h2&gt; &lt;h3&gt;哈哈&lt;/h3&gt;&lt;/div&gt;, root); =&gt;正确的3. 把数据嵌入到JSX中（不是嵌入到元素的属性中，而是正常的内容中） =&gt; 可以嵌入变量或者直接的数据值 let name=&apos;xxx&apos;; ReactDOM.render(&lt;div&gt; &lt;h2&gt;&#123;name&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&apos;哈哈&apos;&#125;&lt;/h3&gt; &lt;/div&gt;, root); =&gt; 不能嵌入对象（代指：&#123;&#125;、/^$/、日期对象、函数、或者数组中的某一项是前面的也不行 [一维简单的数据是可以的]） ReactDOM.render(&lt;div&gt; &lt;h2&gt;&#123;&#123;name:&apos;xxx&apos;&#125;&#125;&lt;/h2&gt; NO &lt;h3&gt;&#123;new Date()&#125;&lt;/h3&gt; NO &lt;h3&gt;&#123;[12,23,34]&#125;&lt;/h3&gt; OK &lt;h4&gt;&#123;(() =&gt; &#123; return &apos;呵呵&apos;; OK:把自执行函数的结果嵌入进来 &#125;)()&#125;&lt;/h4&gt; &lt;/div&gt;, root); =&gt; 可以嵌入基本类型值（null/undefined/布尔值都是空元素，也就是不显示任何的内容） =&gt; 大括号中可以嵌入JS表达式（执行JS代码需要有返回结果的） 循环创建的JSX元素需要设置标识KEY，并且在当前循环的时候，这个KEY需要唯一；而使用MAP是因为它有返回值，返回的是替换后的数组； ReactDOM.render(&lt;ul&gt; &#123; data.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt; &#123;item.id&#125;&amp;nbsp;&amp;nbsp;&#123;item.title&#125; &lt;/li&gt;; &#125;) &#125; &lt;/ul&gt;, root); 使用三元运算符解决判断操作，（IF和SWITCH都不可以） ReactDOM.render(&lt;ul&gt; &#123;name ? &apos;哈哈&apos; : &apos;呵呵&apos;&#125; &lt;/ul&gt;, root);4. 可以给JSX元素设置属性 =&gt;属性值对应大括号中 对象、函数 都可以放（也可以放JS表达式） =&gt;STYLE属性值必须是对象（不能是字符串） =&gt;CLASS 用 CLASS-NAME 代替 =&gt;... REACT基础知识复习（三）： 生命周期函数 调取组件 constructor componentWillMount 第一次渲染之前 render 渲染 componentDidMount 第一次渲染之后 组件重新渲染：内部状态改变、传递给组件的属性改变 shouldComponentUpdate=&gt;是否允许组件更新：返回TRUE是允许，返回FALSE则不再继续向下走 componentWillUpdate=&gt;更新之前：和SHOULD一样，方法中通过this.state.xxx获取的还是更新前的状态信息，方法有两个参数：nextProps/nextState存储的是最新的属性和状态信息 render 更新 componentDidUpdate 更新之后 componentWillReceiveProps(nextProps/nextState) =&gt;接收最新属性之前，基于this.props.xxx获取的是原有的属性信息，nextProps存储的是最新传递的属性信息 shouldComponentUpdate 是否允许组件更新 componentWillUpdate 更新之前 render 更新 componentDidUpdate 更新之后 组件销毁 componentWillUnmount 组件销毁之前 总结 组件的属性是只读的：只能调取组件时候传递进来，不能自己在组件内部修改（但是可以设置默认值和规则） 组件的状态是可读写的：状态改变会引发组件的重新更新（状态是基于setState改变） 组件实例上可以放一些信息：这些信息只是为了方便在组件内任意方法中获取和使用的 实例上挂载的REFS：就是用来操作DOM的 实例上挂载的context：是用来实现组件之间信息传递的]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react03]]></title>
    <url>%2F2019%2F03%2F31%2Freact03%2F</url>
    <content type="text"><![CDATA[JSX中的事件绑定：12345678910render()&#123; return &lt;button className='btn btn-success' onClick=&#123;this.support&#125;&gt; 支持&lt;/button&gt;;&#125;support(ev)&#123; //=&gt;THIS:undefined（不是我们理解的当前操作的元素） //=&gt;ev.target：通过事件源可以获取当前操作的元素（一般很少操作，因为框架主要是数据驱动所有DOM的改变）&#125; 如果能让方法中的THIS变成当前类的实例就好了，这样可以操作属性和状态等信息12345678910render()&#123; //=&gt;THIS:实例 return &lt;button className=&apos;btn btn-success&apos; onClick=&#123;this.support.bind(this)&#125;&gt; 支持&lt;/button&gt;;&#125;support(ev)&#123; //=&gt;THIS:实例&#125; 12345678910render()&#123; //=&gt;THIS:实例 return &lt;button className=&apos;btn btn-success&apos; onClick=&#123;this.support&#125;&gt; 支持&lt;/button&gt;;&#125;support=ev=&gt;&#123; //=&gt;THIS:继承上下文中的THIS（实例）, 真实项目中，给JSX元素绑定的事件方法一般都是箭头函数，目的是为了保证函数中的THIS还是实例&#125; REACT组件 基于数据驱动（修改状态数据，REACT帮助我们重新渲染视图）完成的组件叫做“受控组件（受数据控制的组件）” 基于REF操作DOM实现视图更新的，叫做“非受控组件”=&gt;真实项目中，建议大家多使用“受控组件” VUE：[MVVM] 数据更改视图跟着更改，视图更改数据也跟着更改（双向数据绑定） REACT：[MVC] 数据更改视图跟着更改（原本是单向数据绑定，但是我们可以自己构建出双向的效果） react的DOM12345/* ref='spanLeft' * 是在当前实例上挂载一个属性refs（对象），存储所有的ref元素 * * x =&gt; this.spanLeft = x * x代表当前元素，它的意思是，把当前元素直接挂载到实例上，后期需要用到元素，直接this.spanLeft获取即可 */ 生命周期函数（钩子函数）： 描述一个组件或者程序从创建到销毁的过程，我们可以在过程中间基于钩子函数完成一些自己的操作（例如：在第一次渲染完成做什么，或者在二次即将重新渲染之前做什么等…） 基本流程 constructor 创建一个组件 componentWillMount 第一次渲染之前 render 第一次渲染 componentDidMount 第一次渲染之后 修改流程 当组件的状态数据发生改变(SET-STATE)或者传递给组件的属性发生改变(重新调用组件传递不同的属性)都会引发RENDER重新执行渲染(渲染也是差异渲染)] shouldComponentUpdate 是否允许组件重新渲染(允许则执行后面函数，不允许直接结束即可) componentWillUpdate 重现渲染之前 render 第二次及以后重新渲染 componentDidUpdate 重现渲染之后 componentWillReceiveProps：父组件把传递给子组件的属性发生改变后触发的钩子函数 卸载 原有渲染的内容是不消失的，只不过以后不能基于数据改变视图了 componentWillUnmount：卸载组件之前（一般不用）]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react02]]></title>
    <url>%2F2019%2F03%2F29%2Freact02%2F</url>
    <content type="text"><![CDATA[JSX渲染机制 基于BABEL中的语法解析模块（BABEL-PRESET-REACT）把JSX语法编译为 React.createElement(…) 结构 12345React.createElement( 'h1', &#123;id: 'titleBox',className: 'title',style: styleObj&#125;, '\u73E0\u5CF0\u57F9\u8BAD' //转义字符 ); 执行React.createElement(type, props, children)，创建一个对象（虚拟DOM）12345678910111213&#123; type:'h1' props:&#123; id:'titleBox', className:'title', style:..., children:'珠峰培训' //存放的是素中的内容 &#125; ref:null, key:null, ... __proto__:Object.prototype&#125; ReactDOM.render(JSX语法最后生成的对象,容器)，基于RENDER方法把生成的对象动态创建为DOM圆度，插入到指定的容器中 React.createElement模拟 创建一个对象（默认有四个属性：TYPE/PROPS/REF/KEY），最后要把这个对象返回 根据传递的值修改这个对象 TYPE =&gt;传递的TYPE PROPS 需要做一些处理：大部分传递PROPS中的属性都赋值给对象的PROPS，有一些比较特殊 如果是REF或者KEY，我们需要把传递的PROPS中的这两个属性值，给创建对象的两个属性，而传递的PROPS中把这两个值删除掉 把传递的CHILDREN作为新创建对象的PROPS中的一个属性123456789101112131415161718192021222324 /* * CREATE-ELEMENT：创建JSX对象 * 参数：至少两个 TYPE/PROPS，CHILDREN这个部分可能没有可能有多个 */function createElement(type, props, ...childrens) &#123; let ref, key; if ('ref' in props) &#123; ref = props['ref']; props['ref'] = undefined; &#125; if ('key' in props) &#123; key = props['key']; props['key'] = undefined; &#125; return &#123; type, props: &#123; ...props, children: childrens.length &lt;= 1 ? (childrens[0] || '') : childrens &#125;, ref, key &#125;;&#125; RENDER：把创建的对象生成对应的DOM元素，最后插入到页面中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function render(objJSX, container, callBack) &#123; let &#123;type, props&#125; = objJSX, &#123;children&#125; = props; let newElement = document.createElement(type); for (let attr in props) &#123; if (!props.hasOwnProperty(attr)) break; let value = props[attr]; if (value == undefined) continue;//=&gt;NULL OR UNDEFINED switch (attr.toUpperCase()) &#123; case 'CLASSNAME': newElement.setAttribute('class', value); break; case 'STYLE': for (let styleAttr in value) &#123; if (value.hasOwnProperty(styleAttr)) &#123; newElement['style'][styleAttr] = value[styleAttr]; &#125; &#125; break; case 'CHILDREN': /* * 可能是一个值：可能是字符串也可能是一个JSX对象 * 可能是一个数组：数组中的每一项可能是字符串也可能是JSX对象 */ //-&gt;首先把一个值也变为数组，这样后期统一操作数组即可 !(value instanceof Array) ? value = [value] : null; value.forEach((item, index) =&gt; &#123; //-&gt;验证ITEM是什么类型的：如果是字符串就是创建文本节点，如果是对象，我们需要再次执行RENDER方法，把创建的元素放到最开始创建的大盒子中 if (typeof item === 'string') &#123; let text = document.createTextNode(item); newElement.appendChild(text); &#125; else &#123; render(item, newElement); &#125; &#125;); break; default: newElement.setAttribute(attr, value); &#125; &#125; container.appendChild(newElement); callBack &amp;&amp; callBack();&#125;render(objJSX, root, () =&gt; &#123; console.log('ok');&#125;); REACT组件 不管是VUE还是REACT框架，设计之初都是期望我们按照“组件/模块管理”的方式来构建程序的，也就是把一个程序划分为一个个的组件来单独处理 优势 有助于多人协作开发 我们开发的组件可以被复用 REACT中创建组件有两种方式： 函数声明式组件 基于继承COMPONENT类来创建组件 SRC -&gt; COMPONENT ：这个文件夹中存放的就是开发的组件 基于继承COMPONENT类来创建组件基于CREATE-ELEMENT把JSX转换为一个对象，当RENDER渲染这个对象的时候，遇到TYPE是一个函数或者类，不是直接创建元素，而是先把方法执行： 如果是函数式声明的组件，就把它当做普通方法执行（方法中的THIS是UNDEFINED），把函数返回的JSX元素（也是解析后的对象）进行渲染 如果是类声明式的组件，会把当前类NEW它执行，创建类的一个实例（当前本次调取的组件就是它的实例），执行CONSTRUCTOR之后，会执行THIS.RENDER()，把RENDER中返回的JSX拿过来渲染，所以“类声明式组件，必须有一个RENDER的方法，方法中需要返回一个JSX元素” 但是不管是哪一种方式，最后都会把解析的出来的PROPS属性对象作为实参传递给对应的函数或者类 知识点：CREATE-ELEMENT在处理的时候，遇到一个组件，返回的对象中：TYPE就不在是字符串标签名了，而是一个函数（类），但是属性还是存在PROPS中12345678&#123; type:Dialog, props:&#123; lx:1, con:&apos;xxx&apos;, children:一个值或者一个数组 &#125;&#125; RENDER渲染的时候，我们需要做处理，首先判断TYPE的类型，如果是字符串，就创建一个元素标签，如果函数或者类，就把函数执行，把PROPS中的每一项（包含CHILDREN）传递给函数在执行函数的时候，把函数中RERURN的JSX转换为新的对象（通过CREATE-ELEMENT），把这个对象返回；紧接着RENDER按照以往的渲染方式，创建DOM元素，插入到指定的容器中即可 =================================== 总结：创建组件有两种方式 “函数式”、“创建类式” 函数式 操作非常简单 能实现的功能也很简单，只是简单的调取和返回JSX而已 创建类式 操作相对复杂一些，但是也可以实现更为复杂的业务功能 能够使用生命周期函数操作业务 函数式可以理解为静态组件（组件中的内容调取的时候就已经固定了，很难在修改），而类这种方式，可以基于组件内部的状态来动态更新渲染的内容]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react01]]></title>
    <url>%2F2019%2F03%2F26%2Freact01%2F</url>
    <content type="text"><![CDATA[React是FaceBook（脸书）公司研发的一款JS框架（MVC） React的脚手架 React是一款框架：具备自己开发的独立思想(MVC：Model View Controller) 划分组件开发 基于路由的SPA单页面开发 基于ES6来编写代码(最后部署上线的时候，我们需要把ES6编译成ES5 =&gt;基于Babel来完成编译) 可能用到Less/Sass等，我们也需要使用对应的插件把他们进行预编译 最后为了优化性能（减少HTTP请求次数），我们需要把JS或者CSS进行合并压缩 … webpack来完成以上页面组件合并、JS/CSS编译加合并等工作 前端工程化开发 基于框架的组件化/模块化开发 基于WEBPACK的自动部署 但是配置WEBPACK是一个相对复杂的工作，我们需要自己安装很多的包，还需要自己写相对复杂的配置文件…如果我们有一个插件，基于它可以快速构建一套完整的自动化工程项目结构，那么有助于提高开发的效率 =&gt;“脚手架”VUE：VUE-CLIREACT：CREATE-REACT-APP create-react-app 的使用 $ npm install create-react-app -g 把模块安装在全局环境下（目的：可以使用命令），MAC电脑安装的时候，前面需要加SUDO，否则没有权限 $ create-react-app [项目名称] 基于脚手架命令，创建出一个基于React的自动化/工程化项目目录，和npm发包时候的命名规范一样，项目名称中不能出现：大写字母、中文汉字、特殊符号（-或者_是可以的）等 脚手架生成目录中的一些内容node_modules 当前项目中依赖的包都安装在这里 .bin 本地项目中可执行命令，在package.json的scripts中配置对应的脚本即可（其中有一个就是：react-scripts命令） public 存放的是当前项目的HTML页面（单页面应用放一个index.html即可，多页面根据自己需求放置需要的页面） &lt;!-- 在REACT框架中，所有的逻辑都是在JS中完成的（包括页面结构的创建），如果想给当前的页面导入一些CSS样式或者IMG图片等内容，我们有两种方式： 1.在JS中基于ES6 Module模块规范，使用import导入，这样webpack在编译合并JS的时候，会把导入的资源文件等插入到页面的结构中（绝对不能在JS管控的结构中通过相对目录./或者../，导入资源，因为在webpack编译的时候，地址就不在是之前的相对地址了） 2.如果不想在JS中导入（JS中导入的资源最后都会基于WEBPACK编译），我们也可以把资源手动的在HTML中导入，但是HTML最后也要基于WEBPACK编译，导入的地址也不建议写相对地址，而是使用 %PUBLIC_URL% 写成绝对地址 &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;&gt; --&gt; src 项目结构中最主要的目录，因为后期所有的JS、路由、组件等都是放到这里面（包括需要编写的CSS或者图片等） index.js 是当前项目的入口文件 .gitignore Git提交时候的忽略提交文件配置项 package.json 当前项目的配置清单 &quot;dependencies&quot;: { &quot;react&quot;: &quot;^16.4.1&quot;, &quot;react-dom&quot;: &quot;^16.4.1&quot;, &quot;react-scripts&quot;: &quot;1.1.4&quot; } 基于脚手架生成工程目录，自动帮我们安装了三个模块：react/react-dom/react-scripts react-scripts集成了webpack需要的内容 -&gt;Babel一套 -&gt;CSS处理的一套 -&gt;eslint一套 -&gt;webpack一套 -&gt;其它的 没有less/sass的处理内容（项目中使用less，我们需要自己额外的安装） ---- &quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; } 可执行的脚本“$ npm run start / $ yarn start” start：开发环境下，基于webpack编译处理，最后可以预览当前开发的项目成果（在webpack中安装了webpack-dev-server插件，基于这个插件会自动创建一个WEB服务[端口号默认是3000]，webpack会帮我们自动打开浏览器，并且展示我们的页面，并且能够监听我们代码的改变，如果代码改变了，webpack会自动重新编译，并且刷新浏览器来完成重新渲染） build：项目需要部署到服务器上，我们先执行 yarn build，把项目整体编译打包（完成后会在项目中生成一个build文件夹，这个文件夹中包含了所有编译后的内容，我们把它上传到服务器即可）;而且在服务上进行部署的时候，不需要安装任何模块了（因为webpack已经把需要的内容都打包到一个JS中了） React脚手架的深入剖析 create-react-app脚手架为了让结构目录清晰，把安装的webpack及配置文件都集成在了react-scripts模块中，放到了node_modules中 但是真实项目中，我们需要在脚手架默认安装的基础上，额外安装一些我们需要的模块，例如：react-router-dom/axios… 再比如：less/less-loader… 情况一：如果我们安装其它的组件，但是安装成功后不需要修改webpack的配置项，此时我们直接的安装，并且调取使用即可 情况二：我们安装的插件是基于webpack处理的，也就是需要把安装的模块配置到webpack中（重新修改webpack配置项了） =&gt;首先需要把隐藏到node_modules中的配置项暴露到项目中 &gt; $ yarn eject 首先会提示确认是否执行eject操作，这个操作是不可逆转的，一但暴露出来配置项，就无法在隐藏回去了 如果当前的项目基于GIT管理，在执行eject的时候，如果还有没有提交到历史的区的内容，需要先提交到历史区，然后在eject才可以，否则报错：This git repository has untracked files or uncommitted changes... =&gt;再去修改对应的配置项即可 一但暴露后，项目目录中多了两个文件夹： config 存放的是webpack的配置文件 webpack.config.dev.js 开发环境下的配置项（yarn start） webpack.config.prod.js 生产环境下的配置项（yarn build） scripts 存放的是可执行脚本的JS文件 start.js yarn start执行的就是这个JS build.js yarn build执行的就是这个JS package.json中的内容也改了 【举个栗子：需要配置LESS】 $ yarn add less less-loader less是开发和成产环境下都需要配置的 12345678910&#123; test: /\.(css|less)$/, use: [ require.resolve(&apos;style-loader&apos;), ... &#123; loader: require.resolve(&apos;less-loader&apos;) &#125; ],&#125;, 我们预览项目的时候，也是先基于webpack编译，把编译后的内容放到浏览器中运行，所以如果项目中使用了less，我们需要修改webpack配置项，在配置项中加入less的编译工作，这样后期预览项目，首先基于webpack把less编译为css，然后在呈现在页面中. $ set HTTPS=true&amp;&amp;npm start 开启HTTPS协议模式（设置环境变量HTTPS的值） $ set PORT=63341 修改端口号 ==================================== react &amp; react-dom 渐进式框架 一种最流行的框架设计思想，一般框架中都包含很多内容，这样导致框架的体积过于臃肿，拖慢加载的速度。真实项目中，我们使用一个框架，不一定用到所有的功能，此时我们应该把框架的功能进行拆分，用户想用什么，让其自己自由组合即可。 全家桶：渐进式框架N多部分的组合 VUE全家桶：vue-cli/vue/vue-router/vuex/axios(fetch)/vue element(vant) REACT全家桶：create-react-app/react/react-dom/react-router/redux/react-redux/axios/ant/dva/saga/mobx... react：REACT框架的核心部分，提供了Component类可以供我们进行组件开发，提供了钩子函数（生命周期函数：所有的生命周期函数都是基于回调函数完成的） react-dom：把JSX语法（REACT独有的语法）渲染为真实DOM（能够放到页面中展示的结构都叫做真实的DOM）的组件 ReactDOM.render([JSX],[CONTAINER],[CALLBACK])：把JSX元素渲染到页面中 JSX：REACT虚拟元素 CONTAINER：容器，我们想把元素放到页面中的哪个容器中 CALLBACK：当把内容放到页面中呈现触发的回调函数 JSX：REACT独有的语法 JAVASCRIPT+XML(HTML) 和我们之前自己拼接的HTML字符串类似,都是把HTML结构代码和JS代码或者数据混合在一起了,但是它不是字符串 不建议我们把JSX直接渲染到BODY中，而是放在自己创建一个容器中，一般我们都放在一个ID为ROOT的DIV中即可 在JSX中出现的{}是存放JS的，但是要求JS代码指执行完成有返回结果（JS表达式） 不能直接放一个对象数据类型的值(对象（除了给style赋值）、数组（数组中如有没有对象，都是基本值或者是JSX元素，这样是可以的）、函数都不行) 可以是基本类型的值（布尔类型什么都不显示、null、undefined也是JSX元素，代表的是空） 循环判断的语句都不支持，但是支持三元运算符 循环数组创建JSX元素（一般都基于数组的MAP方法完成迭代），需要给创建的元素设置唯一的KEY值（当前本次循环内唯一即可） 只能出现一个根元素 给元素设置样式类用的是className而不是class style中不能直接的写样式字符串，需要基于一个样式对象来遍历赋值1234567891011121314151617181920212223242526272829303132333435/*let root = document.querySelector('#root');ReactDOM.render(&lt;div id='box' className="box" style=&#123;&#123;color: 'red'&#125;&#125;&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &lt;ul&gt; &lt;/ul&gt;&lt;/div&gt;, root);*//*let data = [&#123; name: '张三', age: 22&#125;, &#123; name: '李四', age: 23&#125;];ReactDOM.render(&lt;div id="box"&gt; HELLO WORLD! &lt;ul&gt; &#123;data.map((item, index) =&gt; &#123; let &#123;name, age&#125; = item; return &lt;li key=&#123;index&#125;&gt; &lt;span&gt;&#123;name&#125;&lt;/span&gt; &lt;span&gt;&#123;age&#125;&lt;/span&gt; &lt;/li&gt;; &#125;)&#125; &lt;/ul&gt;&lt;/div&gt;, root);*//*let data = '珠峰培训';ReactDOM.render(&lt;div id="box"&gt;HELLO WORLD! &#123;data&#125;&lt;/div&gt;, root, () =&gt; &#123; let oBox = document.querySelector('#box'); console.log(oBox.innerHTML);&#125;);*/]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理十五]]></title>
    <url>%2F2019%2F03%2F24%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%8D%81%E4%BA%94%2F</url>
    <content type="text"><![CDATA[知识点：AJAXasync javascript and xml 异步的JS和XML 在AJAX中的异步不是我们理解的同步异步编程，而是泛指“局部刷新”，但是我们在以后的AJAX请求中尽可能使用异步获取数据（因为异步数据获取不会阻塞下面代码的执行） XML是一种文件格式（我们可以把HTML理解为XML的一种）：可扩展的标记语言，它的作用是用自己扩展的一些语义标签来存储一些数据和内容，这样存储的好处是清晰的展示出数据的结构 1很久以前，AJAX刚刚兴起的时候，客户端从服务器端获取数据，服务器为了清晰的表达数据结构，都是返回XML格式的内容，当下，我们获取的数据一般都是JSON格式的内容，JSON相对于XML来说，也能清晰表达数据结构，而且访问里面数据的时候操作起来比XML更简便（但是现在某些项目中，服务器返回给客户端的数据不单纯是数据，而是数据和需要展示的结构拼接好的结果(类似于我们自己做的字符串拼接)，换句话说，是服务器端把数据和结构拼接好返回给我们，此时返回的数据格式一般都是XML格式的字符串） AJAX操作123456789101112131415161718192021//=&gt;创建AJAX实例：IE6中是不兼容的，使用的是new ActiveXObject来实现的let xhr = new XMLHttpRequest();//=&gt;打开请求：发送请求之前的一些配置项//1.HTTP METHOD 请求方式// GET/DELETE/HEAD/OPTIONS/TRACE/CONNECT// POST/PUT//2.URL 向服务器端发送请求的API（Application Programming Interface）接口地址//3.ASYNC 设置AJAX请求的同步异步，默认是异步（写TRUE也是异步），FALSE是同步，项目中都使用异步编程，防止阻塞后续代码执行//4.USER-NAME/USER-PASS：用户名密码，一般不用xhr.open([HTTP METHOD],[URL],[ASYNC],[USER-NAME],[USER-PASS]);//=&gt;3.事件监听：一般监听的都是 READY-STATE-CHANGE 事件（AJAX状态改变事件），基于这个事件可以获取服务器返回的响应头响应主体内容xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState===4 &amp;&amp; xhr.status===200)&#123; xhr.responseText; &#125;&#125;;//=&gt;4.发送AJAX请求：从这步开始，当前AJAX任务开始，如果AJAX是同步的，后续代码不会执行，要等到AJAX状态成功后在执行，反之异步不会xhr.send([请求主体内容]); 关于HTTP请求方式的一点学习 所有的请求都可以给服务器端传递内容，也都可以从服务器端获取内容123456GET：从服务器端获取数据(给的少拿的多)POST：向服务器端推送数据(给的多拿的少)DELETE：删除服务器端的某些内容（一般是删除一些文件）PUT：向服务器上存放一些内容（一般也是存放文件）HEAD：只想获取服务器返回的响应头信息，不要响应主体中的内容OPTIONS：一般使用它向服务器发送一个探测性请求，如果服务器端返回的信息了，说明当前客户端和服务器端建立了连接，我们可以继续执行其它请求了（TRACE是干这件事的，但是axios这个AJAX类库在基于cross domain进行跨域请求的时候，就是先发送OPTIONS请求进行探测尝试，如果能连通服务器，才会继续发送其它的请求） GET VS POST [传递给服务器信息的方式不一样] GET是基于URL地址“问号传参”的方式把信息传递给服务器，POST是基于“请求主体”把信息传递给服务器 12345[GET]xhr.open(&apos;GET&apos;,&apos;/temp/list?xxx=xxx&amp;xxx=xxx&apos;)[POST]xhr.send(&apos;xxx=xxx&amp;xxx=xxx&apos;) GET一般应用于拿（给服务器的会少一些），而POST给服务器的很多，如果POST是基于问号传参方式来搞会出现一些问题：URL会拼接很长，浏览器对于URL的长度有有最大限度（谷歌8KB 火狐7KB IE2KB …），超过的部分浏览器就把它截掉了 所以GET请求可以基于URL传参，而POST都是使用请求主体传递（请求主体理论上是没有限制的，真实项目中我们会自己做大小限制，防止上传过大信息导致请求迟迟完不成）12345678[GET不安全，POST相对安全] 因为GET是基于“问号传参”把信息传递给服务器的，容易被骇客进行URL劫持，POST是基于请求主体传递的，相对来说不好被劫持；所以登录、注册等涉及安全性的交互操作，我们都应该用POST请求；[GET会产生不可控制的缓存,POST不会] 不可控：不是想要就要，想不要就不要的，这是浏览器自主记忆的缓存，我们无法基于JS控制，真实项目中我们都会把这个缓存干掉 GET请求产生缓存是因为：连续多次向相同的地址（并且传递的参数信息也是相同的）发送请求，浏览器会把之前获取的数据从缓存中拿到返回，导致无法获取服务器最新的数据（POST不会） 解决方案： xhr.open(&apos;GET&apos;,`/temp/list?lx=1000&amp;_=${Math.random()}`); //=&gt;保证每次请求的地址不完全一致：在每一次请求的末尾追加一个随机数即可(使用_作为属性名就是不想和其它的属性名冲突) 12345675.AJAX状态(READY-STATE)0 =&gt;UNSENT 刚开始创建XHR，还没有发送1 =&gt;OPENED 已经执行了OPEN这个操作2 =&gt;HEADERS_RECEIVED 已经发送AJAX请求（AJAX任务开始），响应头信息已经被客户端接收了（响应头中包含了：服务器的时间、返回的HTTP状态码...）3 =&gt;LOADING 响应主体内容正在返回4 =&gt;DONE 响应主体内容已经被客户端接收 HTTP网络状态码(STATUS) 根据状态码能够清楚的反映出当前交互的结果及原因 200 OK 成功(只能证明服务器成功返回信息了，但是信息不一定是你业务需要的) 301 Moved Permanently 永久转移（永久重定向） =&gt;域名更改，访问原始域名重定向到新的域名 302 Move temporarily 临时转移（临时重定向 =&gt;307） =&gt;网站现在是基于HTTPS协议运作的，如果访问的是HTTP协议，会基于307重定向到HTTPS协议上 =&gt;302一般用作服务器负载均衡：当一台服务器达到最大并发数的时候，会把后续访问的用户临时转移到其它的服务器机组上处理 =&gt;偶尔真实项目中会把所有的图片放到单独的服务器上“图片处理服务器”，这样减少主服务器的压力，当用户向主服务器访问图片的时候，主服务器都把它转移到图片服务器上处理 304 Not Modified 设置缓存 =&gt;对于不经常更新的资源文件，例如：CSS/JS/HTML/IMG等，服务器会结合客户端设置304缓存，第一次加载过这些资源就缓存到客户端了，下次再获取的时候，是从缓存中获取；如果资源更新了，服务器端会通过最后修改时间来强制让客户端从服务器重新拉取；基于CTRL+F5强制刷新页面，304做的缓存就没有用了。 400 Bad Request 请求参数错误 401 Unauthorized 无权限访问 404 Not Found 找不到资源(地址不存在) 413 Request Entity Too Large 和服务器交互的内容资源超过服务器最大限制 500 Internal Server Error 未知的服务器错误503 Service Unavailable 服务器超负荷 关于XHR的属性和方法 xhr.response 响应主体内容 xhr.responseText 响应主体的内容是字符串（JSON或者XML格式字符串都可以） xhr.responseXML 响应主体的内容是XML文档 xhr.status 返回的HTTP状态码 xhr.statusText 状态码的描述 xhr.timeout 设置请求超时的时间 xhr.withCredentials 是否允许跨域（FALSE） xhr.abort() 强制中断AJAX请求 xhr.getAllResponseHeaders() 获取所有响应头信息 xhr.getResponseHeader([key]) 获取KEY对应的响应头信息，例如：- - xhr.getResponseHeader(‘date’)就是在获取响应有中的服务器时间 xhr.open() 打开URL请求 xhr.overrideMimeType() 重写MIME类型 xhr.send() 发送AJAX请求 xhr.setRequestHeader() 设置请求头 –&gt; 在open操作之前设置]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>ajax</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理十四]]></title>
    <url>%2F2019%2F03%2F24%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%8D%81%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[前端开发性能优化方案一、减少HTTP请求次数和请求大小代码优化 有利于SEO 有利于扩展维护 有利于减少性能消耗[JS代码优化的108条建议] [雅虎CSS优化的36条建议]… DNS及HTTP通信方式的优化 在JS中尽量减少闭包的使用（原因：闭包会产生不释放的栈内存） 循环给元素做事件绑定的时候，尽可能的把后期需要的信息（例如索引）存储到元素的自定义属性上，而不是创建闭包存储 可以在最外层形成一个闭包，把一些后续需要的公共信息进行存储，而不是每一个方法都创建闭包(例如单例模式) 尽可能的手动释放不被占用的内存… 尽量合并CSS和JS文件（把需要引入的CSS合并为一个，JS也是合并为一个），原理是在减少HTTP请求次数，尽可能的把合并后的代码进行压缩，减小HTTP请求资源的大小 webpack这种自动化构建工具，可以帮我们实现代码的合并和压缩（工程化开发） 在移动开发(或者追求高性能的PC端开发[例如百度首页])，如果CSS或者JS不是需要很多，我们可以选择把css和js编程内嵌式（也就是代码直接写在HTML中） 尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片（因为字体图标等是矢量图(基于代码编写出来的)，放大不会变形，而且渲染速度快，相对比位图要小一些） 减少对DOM的操作（主要是减少DOM的重绘和回流(重排)） 关于重排的分离读写 使用文档碎片或者字符串拼接做数据绑定(DOM的动态创建) 在JS中避免“嵌套循环”（这种会额外增加很多循环次数）和“死循环”（一旦遇到死循环浏览器就卡壳了） 采用图片的“懒加载”（延迟加载） 目的是为了减少页面“第一次加载”过程中HTTP的请求次数，让页面打开速度变快 步骤：开始加载页面的时候，所有的真实图片都不去发送HTTP请求加载，而是给一张占位的背景图，当页面加载完，并且图片在可视区域内我们再去做图片加载 利用浏览器和服务器端的缓存技术(304缓存) 把一些不经常更新的静态资源文件做缓存处理（例如：JS、CSS、静态图片等都可以做缓存） 原理是为了减少HTTP请求大小，让获取速度更快 尽可能使用事件委托(事件代理) 处理事件绑定的操作，减少DOM的频繁操作，其中包括给每一个DOM元素做事件绑定 尽量减少CSS表达式的使用(expression) 12345678#myDiv &#123; position: absolute; width: 100px; height: 100px; left: expression(document.body.offsetWidth - 110 + &quot;px&quot;); top: expression(document.body.offsetHeight - 110 + &quot;px&quot;); background: red;&#125; CSS选择器解析规则是从右向左解析123.container .link a&#123; 先找到所有的A，再筛选是在.link样式类中的，再次筛选是在.container样式类中的... 先找到的是所有的A，操作起来是消耗性能的，我们在使用CSS选择器的时候尽可能减少对标签选择器的使用&#125; CSS雪碧图技术(css sprite / css 图片精灵) 把所有相对较小资源图片汇总到一张大图上，后期我们只需要把大图加载下来，用背景定位的方式展示对应的小图即可 1234567891011.bg&#123; background:url(&apos;xxx.png&apos;);&#125;.box1&#123; background-position:xx xx;&#125;.box2&#123; background-position:xx xx;&#125;&lt;div class=&apos;bg box1&apos;&gt;&lt;/div&gt; 减少对于COOKIE的使用（最主要的是减少本地COOKIE存储内容的大小） 因为客户端操作COOKIE的时候，这些信息总是在客户端和服务器端传来传去 页面中的数据获取采用异步编程和延迟分批加载 使用异步获取数据，是为了降低HTTP通道的堵塞，不会因为数据没有请求回来耽误下面信息的渲染，提高页面的打开速度（我们可以这样处理：需要动态绑定数据的区域先隐藏，等数据返回并且绑定完成后在让其显示） 延迟分批加载类似于图片懒加载，是为了减少第一次页面加载时候的HTTP请求次数 音视频标签 页面中出现音视频标签，我们不让页面加载的时候就去加载这些资源（要不然页面加载速度会变慢）（方案：只需要设置 preload=’none’ 即可），等待页面加载完成，音视频播放的时候我们在去加载音视频资源 JSON在客户端和服务器端进行信息交互的时候，对于多项数据我们尽可能基于JSON格式来进行传送（JSON格式的数据处理方便，资源偏小） ==&gt;相对于XML格式的传输才会有这个优势 代码封装尽可能实现JS的封装（低耦合高内聚），减少页面中的冗余代码（减少HTTP请求资源的大小） 减少css重绘 CSS中设置定位后，最好使用Z-INDEX改变盒子的层级，让所有的盒子不在相同的平面上，这样后续处理的时候，性能有那么一丢丢的提高 尽量减少对于filter滤镜属性的使用(这个属性消耗性能较大一些) 在CSS导入的时候尽量减少使用@import导入式，因为@import是同步操作，只有把这个对应的CSS导入，才会向下加载，而link是异步操作 相同访问地址缓存在基于AJAX的GET请求进行数据交互的时候，根据需求可以让其产生缓存（这个缓存不是304缓存），这样下一次从相同地址获取的数据是上一次缓存的数据（但是很少用，项目中一般刻意清除这个缓存的时候偏多） 配置ETag 有点类似于304缓存 使用window.requestAnimationFrame（JS中的帧动画）代替传统的定时器动画 减少递归的使用，避免死递归，避免由于递归导致的栈内存嵌套（建议使用尾递归） 避免使用iframe（不仅不好管控样式，而且相当于在A页面中加载了其它页面，消耗较大） 利用H5中提供的localstorage本地存储或者是manifest离线缓存，做一些信息的本地存储，下一次加载页面的时候直接从本地获取，减少HTTP请求次数 基于SCRIPT调取JS的时候，可已使用 defer或者async 来异步加载 重量级优化 做CDN加速（烧钱机器） ===额外技巧=== 我们一般都把CSS放到BODY上，把JS放到BODY下面（原因：让其先加载CSS在加载JS，先加载CSS是为了保证页面渲染的过程中，元素是带着样式渲染的，而JS一般都是用来操作DOM元素的，需要等到元素加载完再操作） 能用CSS搞定的绝对不用JS，能用原生JS搞定的绝对不用插件，绝对不使用FLASH（除了音视频的低版本浏览器播放）=&gt;CSS处理动画等功能的性能优于JS，而且CSS中的transform变形还开起了硬件加速 JS中尽量减少对EVAL的使用，因为JS合并压缩的时候，可能出现由于符号不完善，导致的代码执行优先级错乱问题，EVAL处理起来消耗的性能也是偏大一点的 使用keep-alive实现客户端和服务器端的长连接 尽量使用设计模式来管理我们的代码（单例、构造、Promise、发布订阅），方便后期的升级和维护 开启服务器端的gzip压缩（这个压缩可以有效减少请求资源文件的大小），其实客户端的图片等资源也是可以进行压缩的（但是对于24位的位图，压缩后可能会变模糊） 页面中不要出现无效的链接（利于SEO优化），还有其它技巧：提高关键字曝光率、img需要加alt、设置meta标签、标签语义化… 避免使用with语句（非常耗性能）]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基础二]]></title>
    <url>%2F2019%2F03%2F21%2Fgit%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[GIT：分布式版本控制系统 1.版本控制系统 开发中我们把每一次的修改都有效的进行记录（记录成一个版本），后期如果需要回退到原有的有个版本或者是用当前的和某一个版本进行比较等，都可以有效的进行管理 常用的版本控制系统：SVN(集中式) / GIT(分布式) 2.分布式版本管理系统的特点 3.Linux团队开发的git，所以git中的命令大部分都是linux命令 =======================后期我们更多的都是基于命令来完成GIT管理的,所以我们学一些简单的LINUX命令 WINDOWS操作系统：DOS窗口和DOS命令 LINUX服务器操作系统：LINUX命令 （MAC的终端使用的也是LINUX命令）1234567891011121314151617181920212223ls -l/-a：查看当前目录结构（-a是可以看见所有的：包含隐藏的）cd xxx[路径地址]：进入到执行的文件夹中（进入的路径地址，可以粘贴到对应的操作命令窗口中） cd /：根目录 cd ./：当前目录 cd ../：上级目录clear：清屏mkdir：创建文件夹touch：创建空的文件vi：向文件中插入或者管理一些内容 i=&gt;进入到插入模式 ESC + :WQ ，退出内容的插入模式，把刚才编辑的内容进行保存echo：向指定的文件中输入内容cat：查看文件中的内容cp：拷贝rm：删除文件 -r（递归删除）-f（强制删除），一旦删除无法还原 =======================GIT的常规流程 1.每一个GIT仓库都有三个区： 工作区：写代码 暂存区：临时存放每一次修改的代码，但是并没有生成历史版本 历史区：存放所有历史版本的地方(提交到历史区就会生成历史版本) 2.把暂存区的某一个文件删除（提交到暂存区的内容不好，我们可以删除） $ git rm –cached xxx.xx $ git rm –cached . -r 删除暂存区中所有提交的 如果在删除过程中，发现从暂存区删除的文件，在工作区已经被修改了，只有加上 -f 才能强制从暂存区把内容删除掉 3.提交到暂存区一份，把工作区内容改了，但是改的东西不好，想把暂存区上次提交的内容撤回到工作区（覆盖工作区新写的内容） $ git checkout xxx.xx 暂存区内容没有消失，只是把工作去最新修改的信息给覆盖了，让工作区和暂存区保持一致 ======================一些细节问题 1.如果是第一次使用git，生成历史版本的时候，需要提供身份认证 1234只需要在本地GIT全局环境下配置一些信息即可$ git config -l$ git config --global user.name &apos;xxx&apos;$ git config --global user.eamil &apos;xxx&apos; 2.真实项目中，并不是所有的文件都和项目有关系（例如：.idea是WS生成的配置文件夹和项目没关系），也不是所有的文件都提交 （例如：node_modules中的内容太大了，也不需要提交） .gitignore =&gt;GIT提交的忽略文件 123456789101112131415161718192021# dependencies/node_modules# testing/coverage# production/build# misc.DS_Store.env.local.env.development.local.env.test.local.env.production.localnpm-debug.log*yarn-debug.log*yarn-error.log*.idea 3.$ git log 查看历史版本信息 GIT常用命令 $ git init $ git add . $ git commit -m’’ $ git status $ git log $ git checkout . $ git reset –hard 版本号 =====================团队协作开发 1.基础流程操作 1）首先创建中央仓库:可以基于gitHub/codding来创建（最好不要创建空仓库，因为空仓库中没有任何分支，只有提交一次历史信息才会生成MASTER分支） http://github.com/ 把开发者都列入仓库的开发群组中，这样每一个开发者用自己的gitHub账号，都有权限操作这个仓库了（当然不这样做也可以，所有开发者用统一的一个账号也可以，为了防止不知道是谁提交的，我们需要让每一个客户端在本地的GIT全局配置中，设置和gitHub相同的用户名和邮箱 $ git config –global user.name ‘xxx’ …） 2）创建客户端本地仓库（一个开发者就是一个单独仓库），还需要让本地的仓库和远程仓库保持关联，这样才可以实现后续的信息同步 $ git init =&gt;创建本地仓库 $ git remote add origin “远程仓库GIT地址” =&gt;让本地仓库和远程仓库保持连接 $ git remote -v =&gt;查看连接信息（origin是连接的名称，一般都用这个名字，当然自己可以随便设置） $ git remote rm origin =&gt;移除本地仓库和远程仓库的链接 $ git remote update origin =&gt;更新链接通道 有更简单的方式：只要把远程仓库克隆到本地，就相当于创建本地仓库，而且自动建立了链接，并且把远程仓库中的内容也同步到了本地 $ git clone “远程仓库地址” “本地仓库文件夹名字（不写默认是仓库名字）” 3）各自和中央服务器同步信息 推送：$ git push origin master （每一次PUSH之前最好都PULL一下：如果有冲突在本地处理一下冲突，然后再推送） 拉取：$ git pull origin master ======================知识点： $ git clone “远程仓库地址” 把远程仓库克隆到本地（本地自动和远程建立连接，自动把远程中的信息同步到本地了，本地也是一个单独的仓库：建议远程仓库不要是空的，至少有一个master分支） $ git pull origin master 把远程仓库MASTER中的信息同步到本地仓库MASTER中 $ git push origin master 把本地仓库MASTER中的信息同步到远程仓库MASTER中（需要使用gitHub的用户密码来进行权限校验：一般都是组长在远程仓库中把组员的账号都放到小组中，这样组员用自己的账号也有权限操作仓库了，最好在本地的GIT配置中把用户名和邮箱修改为和gitHub账号相同的信息） 如果有冲突： 1.进入到了编辑框模式，i-&gt;ESC-&gt;:wq 即可 2.自己会把两份代码都保存在本地文件中，自己手动去选择要哪一个，改完后重新提交即可 $ git checkout -b xxx 创建分支并且切换到指定分支下（可以把本地master中的历史信息同步到新创建的分支中） git branch git branch xxx git checkout xxx git branch -D xxx 删除分支 $ git merge xxx 把xxx分支的历史信息合并到当前分支下 $ git stash / $ git stash pop 在切换分支的时候，有一部分信息并没有提交成为历史版本，为了防止信息的丢失，我们需要先使用stash保存，然后在基于stash pop还原]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理十三]]></title>
    <url>%2F2019%2F03%2F17%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[一：减少HTTP请求的次数及请求内容的大小 URL/URN/URIURI=URL+URNURI：统一资源标识符URL：统一资源定位符URN：统一资源名称 http://www.zhufengpeixun.cn:80/stu/index.html?name=xxx&amp;age=25#teacher 传输协议 用来传输客户端和服务器端交互的信息的（类似于快递小哥） HTTP：超文本传输协议（除了传递普通的文本，还可以传递文件流或者进制编码等信息），是目前最常用的WEB传输协议 HTTPS：基于SSL（Secure Sockets Layer 安全套接层）加密的HTTP传输协议，比HTTP更加的安全（涉及支付的网站一般都是基于HTTPS完成的） FTP：文件传输协议，一般用来实现资源文件在服务器上的上传下载 [域名] Domain Name 一级域名（顶级域名） www.qq.com 二级域名 sports.qq.com 三级域名 kbs.sports.qq.com .com 供商用的国际域名 .cn 供商用的中文域名 .net 用于网络供应服务商（系统类的经常使用NET域名） .org 用于官方组织 .edu 用于教育院校 .gov 用于政府机构 端口号 用来区分同一台服务器上不同服务的标识（基于WEB服务管理器创建服务的时候可以指定），不同服务之间一般是不能使用相同的端口号的 HTTP =&gt;默认端口号80 HTTPS =&gt;默认端口号443 FTP =&gt;默认端口号21 如果当前网站服务，采用的是协议对应的默认端口管理，那么当用户输入网址的时候可以不指定端口号，浏览器会默认把用户把默认的端口传递给服务器 一台服务器上的端口号范围：0~65535之间 WEBSTORM预览页面：WS把自己的电脑当做服务器，在服务器上创建一个服务，端口号是63342，自己电脑上的浏览器预览自己电脑上的服务，属于本机服务请求，用localhost(127.0.0.1)本地域名即可http://localhost:63342/201802LESSON/WEEK7/0522DAY1/1.html 服务器上安装一款应用都可能会作为一个服务，占用一个端口号 请求路径名称 pathpathname 例如：/stu/index.html 一般都是请求当前服务对应的项目目录中，STU文件夹中的INDEX.HTML页面。但是也有特情况，就是当前的URL是被“伪URL重写”的，我们看到的URL请求其实不是真实的请求（例如 https://item.jd.com/4679424.html 这个URL就是被重写的，它的真实URL地址很可能是 https://item.jd.com/detail.jsp?id=4679424，其实就是跳转到详情页，通过问号传递不同的产品编号，展示不同的产品详情信息，但是.jsp这种服务器渲染的动态页面不能被搜索引擎收录，不利于页面的SEO，所以我们会把动态页面静态化，这也就用到了URL重写技术） 例如：/stu/info 这种没有任何后缀信息，一般都不是用来请求资源文件的，而是用于AJAX数据请求的接口地址（如果后缀是.json类的，也是同理），但是有一种除外 /stu/info/ 这种的很可能不是接口地址，而是没有指定请求的资源名称，服务器会请求默认的资源文件，一般都是index.html/default.html… DHTML 动态页面，泛指当前页面中的内容不是写死的而是动态绑定的，例如.jsp/.php/.aspx…这些页面中的数据都是基于AJAX或者是后台编程语言处理，由服务器端渲染，最后把渲染后的结果返回给客户端呈现的 问号传参及哈希值 ?xxx=xxx&amp;…#xxx 在HTTP事务中，问号传参是客户端把信息传递给服务器的一种方式(也有可能是跳转到某一个页面，把参数值传递给页面用来标识的) 哈希值一般都跟客户端服务器交互没啥关系，主要用于页面中的锚点定位和HASH路由切换 HTTP报文12345678910起始行：请求起始行、响应起始行首部（头）：请求头、响应头、通用头主体：请求主体、响应主体General 通用头`Request URL`: http://www.zhufengpeixun.cn/ 请求地址Request Method: GET 请求方式:GET/POST/DELETE/PUT/HEAD/OPTION...Status Code: 304 Not Modified 响应的 HTTP状态码Remote Address: 125.39.174.137:80 主机地址(服务器外网IP地址)Referrer Policy: no-referrer-when-downgrade12Request Headers 请求头 [客户端设置，服务器接收] GET / HTTP/1.1 =&gt;起始行(描述当前请求的一些基本信息：用的是1.1版本传输协议进行内容传输的) Host: www.zhufengpeixun.cn Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) - Chrome/66.0.3359.139 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: … =&gt;cookie信息一般都是放到头文件中实现和服务器端的数据通信的 If-Modified-Since: Sun, 06 May 2018 10:02:42 GMT Response Headers 响应头 [服务器端设置，客户端获取]1234567HTTP/1.1 304 Not Modified =&gt;响应起始行（HTTP状态码）Date: Tue, 22 May 2018 09:18:56 GMT =&gt;服务器响应内容时候的“服务器端时间”（客户端获取这个时间的时候已经和真实的时间产生误差了，因为服务器返回内容到客户端接收到，也是需要时间的），并且这个时间是格林尼治时间（比北京时间慢8小时，北京时间是GMT+0800）Connection: keep-aliveETag: &quot;700a6f-17f43-56b86a77513d3&quot;Vary: Accept-Encoding,User-AgentServer: yunjiasu-nginx //=&gt;管理WEB服务的工具CF-RAY: 41ee32c192db66b8-TSN Response [响应主体]1服务器返回的是啥就是啥 Request Payload / Form Data [请求主体]1客户端传递给服务器的内容 HTTP报文开发和BUG调试至关重要 以后涉及到交互功能（前端&lt;=&gt;后台）出现问题，都按照如下方式查找问题原因 打开控制台，在NET-WORK中找到当前交互的请求地址，点击进去看详情 如果是传递给服务器的参数或者方式错误 [前端问题] 如果服务器返回的信息有错误或者和API接口文档规定的内容不一样 [后台问题] 如果返回数据是对的，但是展示有问题 [前端问题] 确定是自己前端的问题后，基于断点(或者代码中的debugger)或者控制台输出等方式，开始逐步调试即可 客户端和服务器端信息交互的方式 [客户端传递给服务器] A:问号传参 请求的URL地址末尾通过问号传参方式，把一些信息传递给服务器 /stu/info?id=12&amp;lx=man B:设置请求头 客户端把需要传递给服务器的内容设置到请求头信息中（自定义请求头）,服务器可以通过接收请求头信息把内容得到 C:设置请求主体 xhr.send([AJAX SEND中传递的内容，就是客户端设置的请求主体内容，服务器端可以接收到这些信息的]); [服务器返回给客户端] A:设置响应头信息 例如把服务时间通过响应头返回给客户端，客户端通过获取响应头信息得到这个时间（响应头返回的速度是优先于响应主体的） B:设置响应主体 主要的返回信息都在响应主体中]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础01]]></title>
    <url>%2F2019%2F03%2F14%2Fnode01%2F</url>
    <content type="text"><![CDATA[什么是NODE？基于V8引擎（谷歌浏览器的引擎）渲染JS的工具或者环境-&gt;安装NODE-&gt;把JS代码放到NODE环境中执行 安装NODEhttps://nodejs.org/en/ node安装完成后 当前电脑上自动安装了npm(Node Package Manager)：一个JS模块（所有封装好可以供其它人调取使用的都可以称之为模块或者包）管理的工具，基于npm可以安装下载JS模块 它会生成一个node执行的命令（可以在DOS窗口或者终端命令中执行）：node xxx.js 如果不成功，可以找相同电脑配置的人员，把安装成功的NODE文件夹拷贝到自己的电脑上，通过配置环境变量，来实现NODE安装 如何在NODE中渲染和解析JS REPL模式 (Read-Evaluate-Print-Loop，输入-求值-输出-循环) 直接基于NODE来执行JS文件1）在命令窗口中执行（DOS窗口 &amp; 终端窗口）2）WB中的Terminal中也可以执行node命令3）直接在WB中执行（右键=&gt;RUN xxx.js），这种方式可能会产生缓存（尤其是文件的目录改动后） 之所以把NODE作为后台编程语言，是因为： 我们可以把NODE安装在服务器上 我们可以把编写的JS代码放到服务器上，通过NODE来执行它（我们可以使用JS来操作服务器，换句话说，使用JS来实现服务器端的一些功能操作 =&gt;其实说NODE是后台语言，想要表达的是JS是后台语言 “JS是一门全栈编程语言”） NODE做后台的优势和特点传统后台语言：JAVA/Python/PHP/C#(.NET)…=&gt;单线程的=&gt;基于V8引擎渲染：快=&gt;异步无阻塞的I/O操作：I/O (INPUT/OUTPUT) 对文件的读写=&gt;event-driven事件驱动：类似于发布订阅或者回调函数 在WB中开启NODE内置方法的代码提示File -&gt; settings -&gt; languages &amp; frameworks -&gt; node.js and npm -&gt; 开起代码提示只要点击“Enable”按钮即可（Disable是取消代码提示） ============================ NPM的应用 目前“工程化/自动化”开发（不一定是写后台），都是基于NODE环境，基于NPM管理模块，基于WEBPACK实现模块之间的依赖打包，部署上线等 NPM常规操作 12345678npm install xxx 把模块安装到当前目录（在哪个目录下执行的命令，这个目录就是当前目录）下npm install xxx -g 把模块安装在全局目录下npm uninstall xxx / npm uninstall xxx -g 卸载模块npm install xxx@xxx 安装指定版本号的模块npm view xxx &gt; xxx.version.txt 查看模块的历史版本信息 NPM的默认安装源都是在 https://www.npmjs.com/ 网站中查找的，在国内安装，下载速度较慢，想要下载速度快一些，我们可以如下处理： 使用淘宝镜像-&gt;安装cnpm，后期都是基于cnpm安装管理 12npm install cnpm -gcnpm install zepto -&gt;安装nrm切源工具，基于nrm把源切换到淘宝源上 123456npm install nrm -gnrm ls 查看当前可用的源nrm use xxx 使用某个源这样处理完成后，后期模块的管理依然基于npm即可 基于YARN安装：它也是模块管理器，类似于NPM，但是安装管理的速度比NPM快很多 123456npm install yarn -gyarn add xxxyarn remove xxx使用yarn只能把模块安装到当前目录下，不能安装到全局环境下 bower也是类似于npm的包管理器，只不过它是从gitHub下载安装 1234npm install bower -gbower install xxx... 常见文件操作promise封装let fs = require('fs'), path = require('path'); //=&gt;存储的是当前模块执行所在的绝对路径(!==__dirname) let dirname = path.resolve(); //=&gt;MKDIR &amp;&amp; RMDIR &amp;&amp; READ-DIR &amp;&amp; READ-FILE &amp;&amp; COPY-FILE ['mkdir', 'rmdir', 'readdir', 'readFile', 'copyFile', 'unlink'].forEach(item =&gt; { exports[item] = function (pathname, copypath = '') { pathname = path.resolve(dirname, pathname); copypath = path.resolve(dirname, copypath); return new Promise((resolve, reject) =&gt; { let arg = [(err, result) =&gt; { if (err) { reject(err); return; } resolve(result || ''); }]; item === 'readFile' ? arg.unshift('utf8') : null; item === 'copyFile' ? arg.unshift(copypath) : null; fs[item](pathname, ...arg); }); }; }); //=&gt;WRITE &amp;&amp; APPEND ['writeFile', 'appendFile'].forEach(item =&gt; { exports[item] = function (pathname, content) { pathname = path.resolve(dirname, pathname); if (typeof content !== 'string') { //=&gt;写入的内容我们规定必须是字符串才可以 content = JSON.stringify(content); } return new Promise((resolve, reject) =&gt; { fs[item](pathname, content, 'utf8', (err, result) =&gt; { if (err) { reject(err); return; } resolve(result || ''); }); }); }; });]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promiseA+02]]></title>
    <url>%2F2019%2F03%2F12%2FpromiseA%2B02%2F</url>
    <content type="text"><![CDATA[promise代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Promise 实现 遵循promise/A+规范 * Promise/A+规范译文: */// promise 三个状态const PENDING = "pending";const FULFILLED = "fulfilled";const REJECTED = "rejected";function Promise(excutor)&#123; let that = this; // 缓存当前promise实例对象 this.status = PENDING; // 初始状态 this.value = undefined; // fulfilled状态时 返回的信息 this.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value)&#123; // value成功态时接收的终值 if(value instanceof promise)&#123; return value.then(resolve,reject) &#125; // 为什么resolve 加setTimeout? // 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行. // 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(()=&gt;&#123; // 调用resolve 回调对应onFulfilled函数 if(that.status == PENDING)&#123; // 只能由pending状态 =&gt; fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb=&gt;cb(that.value)) &#125; &#125;,0) &#125; function reject(reason)&#123;// reason失败态时接收的拒因 setTimeout(()=&gt;&#123; // 调用reject 回调对应onRejected函数 if(that.status == PENDING)&#123; // 只能由pending状态 =&gt; rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.value = reason; that.onRejectedCallbacks.ForEach(cb=&gt;cb(that.reason)) &#125; &#125;) &#125; // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) =&gt; &#123; // throw new Error('error in excutor') // &#125;) try&#123; excutor(resolve,reject) &#125;catch(e)&#123; reject(e) &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230/** * resolve中的值几种情况： * 1.普通值 * 2.promise对象 * 3.thenable对象/函数 */ /** * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理 * @param &#123;promise&#125; promise2 promise1.then方法返回的新的promise对象 * @param &#123;[type]&#125; x promise1中onFulfilled的返回值 * @param &#123;[type]&#125; resolve promise2的resolve方法 * @param &#123;[type]&#125; reject promise2的reject方法 */function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; // 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错 return reject(new TypeError(&apos;循环引用&apos;)); &#125; let called = false; // 避免多次调用 // 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无） if (x instanceof Promise) &#123; // 获得它的终值 继续resolve if (x.status === PENDING) &#123; // 如果为等待态需等待直至 x 被执行或拒绝 并解析y值 x.then(y =&gt; &#123; resolvePromise(promise2, y, resolve, reject); &#125;, reason =&gt; &#123; reject(reason); &#125;); &#125; else &#123; // 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise x.then(resolve, reject); &#125; // 如果 x 为对象或者函数 &#125; else if (x != null &amp;&amp; ((typeof x === &apos;object&apos;) || (typeof x === &apos;function&apos;))) &#123; try &#123; // 是否是thenable对象（具有then方法的对象/函数） let then = x.then; if (typeof then === &apos;function&apos;) &#123; then.call(x, y =&gt; &#123; if(called) return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, reason =&gt; &#123; if(called) return; called = true; reject(reason); &#125;) &#125; else &#123; // 说明是一个普通对象/函数 resolve(x); &#125; &#125; catch(e) &#123; if(called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125; /** * [注册fulfilled状态/rejected状态对应的回调函数] * @param &#123;function&#125; onFulfilled fulfilled状态时 执行的函数 * @param &#123;function&#125; onRejected rejected状态时 执行的函数 * @return &#123;function&#125; newPromsie 返回一个新的promise对象 */Promise.prototype.then = function(onFulfilled, onRejected)&#123; const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled == &apos;function&apos; ? onFulfilled : value=&gt;value; onRejected = typeof onRejected == &apos;function&apos; ? onRejected : reason=&gt;&#123;throw reason&#125;; // then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ? // 原因: // 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout // 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected // 其二 2.2.6规范 也是resolve函数里加setTimeout的原因 // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行 // 如下面这种情景 多次调用p1.then // p1.then((value) =&gt; &#123; // 此时p1.status 由pedding状态 =&gt; fulfilled状态 // console.log(value); // resolve // // console.log(p1.status); // fulfilled // p1.then(value =&gt; &#123; // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行 // console.log(value); // &apos;resolve&apos; // &#125;); // console.log(&apos;当前执行栈中同步代码&apos;); // &#125;) // console.log(&apos;全局执行栈中同步代码&apos;); if(that.status == FULFILLED)&#123; // 成功态 return newPromise = new Promise((resolve,reject)=&gt;&#123; // 和等待状态时候，保持一致 要异步执行 setTimeout(()=&gt;&#123; try&#123; let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 &#125;catch(e)&#123; reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); &#125; &#125;,0) &#125;) &#125; if (that.status === REJECTED) &#123; // 失败态 return newPromise = new Promise((resolve, reject) =&gt; &#123; // 和等待状态时候，保持一致 要异步执行 setTimeout(() =&gt; &#123; try &#123; let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if(that.status == PENDING)&#123; // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve,reject)=&gt;&#123; that.onFulfilledCallbacks.push((value)=&gt;&#123; try&#123; let x = onFulfilled(value); resolvePromise(newPromise,x,resolve,reject) &#125;catch(e)&#123; reject(e) &#125; &#125;) that.onRejectedCallbacks.push((reason)=&gt;&#123; try&#123; let x = onRejected(reason) resolvePromise(newPromise,x,resolve,reject) &#125;catch(e)&#123; reject(e) &#125; &#125;) &#125;) &#125;&#125;/** * Promise.all Promise进行并行处理 * 参数: promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。 */Promise.all = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let done = gen(promises.length, resolve); promises.forEach((promise, index) =&gt; &#123; promise.then((value) =&gt; &#123; done(index, value) &#125;, reject) &#125;) &#125;)&#125;function gen(length, resolve) &#123; let count = 0; let values = []; return function(i, value) &#123; values[i] = value; if (++count === length) &#123; console.log(values); resolve(values); &#125; &#125;&#125;/*** Promise.race* 参数: 接收 promise对象组成的数组作为参数* 返回值: 返回一个Promise实例* 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快)*/Promise.race = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; promises.forEach((promise, index) =&gt; &#123; promise.then(resolve, reject); &#125;); &#125;);&#125;// 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected);&#125;Promise.resolve = function (value) &#123; return new Promise(resolve =&gt; &#123; resolve(value); &#125;);&#125;Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125;/*** 基于Promise实现Deferred的* Deferred和Promise的关系* - Deferred 拥有 Promise* - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject）**参考jQuery.Deferred*url: http://api.jquery.com/category/deferred-object/*/Promise.deferred = function() &#123; // 延迟对象 let defer = &#123;&#125;; defer.promise = new Promise((resolve, reject) =&gt; &#123; defer.resolve = resolve; defer.reject = reject; &#125;); return defer;&#125;/*** Promise/A+规范测试* npm i -g promises-aplus-tests* promises-aplus-tests Promise.js*/try &#123;module.exports = Promise&#125; catch (e) &#123;&#125;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promiseA+01]]></title>
    <url>%2F2019%2F03%2F12%2FpromiseA%2B01%2F</url>
    <content type="text"><![CDATA[JS中的同步异步编程 浏览器是多线程的，JS是单线程的（浏览器只分配一个线程来执行JS）进程大线程小：一个进程中包含多个线程，例如在浏览器中打开一个HTML页面就占用了一个进程，加载页面的时候，浏览器分配一个线程去计算DOM树，分配其它的线程去加载对应的资源文件…再分配一个线程去自上而下执行JS 同步：在一个线程上（主栈/主任务队列）同一个时间只能做一件事情，当前事情完成才能进行下一个事情（先把一个任务进栈执行，执行完成，在把下一个任务进栈，上一个任务出栈…） 异步：在主栈中执行一个任务，但是发现这个任务是一个异步的操作，我们会把它移除主栈，放到等待任务队列中（此时浏览器会分配其它线程监听异步任务是否到达指定的执行时间）,如果主栈执行完成，监听者会把到达时间的异步任务重新放到主栈中执行… 宏任务：macro task 定时器 事件绑定 ajax 回调函数 Node中fs可以进行异步的I/O操作 微任务：micro task Promise(async/await) =&gt; Promise并不是完全的同步，当在Excutor中执行resolve或者reject的时候，此时是异步操作，会先执行then/catch等，当主栈完成后，才会再去调用resolve/reject把存放的方法执行 process.nextTick 执行顺序优先级：SYNC =&gt; MICRO =&gt; MACRO 所有JS中的异步编程仅仅是根据某些机制来管控任务的执行顺序，不存在同时执行两个任务这一说法 Promise A+Promise 处理多个相互关联的异步请求1234567891011121314151617181920212223const request = url=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; $.get(url,data=&gt;&#123; // jquery中的ajax请求 resolve(data); &#125;) &#125;)&#125;request(url).then(data1=&gt;&#123; return request(data1.url)&#125;).then(data2=&gt;&#123; return request(data2.url)&#125;).then(data3=&gt;&#123; return request(data3)&#125;).catch(err=&gt;&#123; throw new Error(err.message)&#125;)-------------------------------------------------------// vue/react 都是用axios fetch 请求数据 也都支持 Promise APIimport axios from 'axios';axios.get(url).then(data =&gt; &#123; console.log(data)&#125;) promise使用 Promise 是一个构造函数，new Promise 返回一个 promise对象 接收一个excutor执行函数作为参数, excutor有两个函数类型形参resolve reject12345const promise = new Promise((resolve, reject) =&gt; &#123; // 异步处理 // 处理结束后、调用resolve 或 reject&#125;);// promise相当于一个状态机 promise的三种状态 pending fulfilled rejected promise 对象初始化状态为 pending 当调用resolve(成功)，会由pending =&gt; fulfilled 当调用reject(失败)，会由pending =&gt; rejected 注意promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变 promise对象方法 then方法注册 当resolve(成功)/reject(失败)的回调函数 1234// onFulfilled 是用来接收promise成功的值// onRejected 是用来接收promise失败的原因promise.then(onFulfilled, onRejected);// then方法是异步执行的 resolve(成功) onFulfilled会被调用 12345678const promise = new Promise((resolve, reject) =&gt; &#123; resolve('fulfilled'); // 状态由 pending =&gt; fulfilled&#125;);promise.then(result =&gt; &#123; // onFulfilled console.log(result); // 'fulfilled' &#125;, reason =&gt; &#123; // onRejected 不会被调用&#125;) reject(失败) onRejected会被调用 12345678const promise = new Promise((resolve, reject) =&gt; &#123; reject('rejected'); // 状态由 pending =&gt; rejected&#125;);promise.then(result =&gt; &#123; // onFulfilled 不会被调用&#125;, reason =&gt; &#123; // onRejected console.log(reason); // 'rejected'&#125;) promise.catch 在链式写法中可以捕获前面then中发送的异常1234567891011promise.catch(onRejected)// 相当于promise.then(null, onRrejected);// 注意// onRejected 不能捕获当前onFulfilled中的异常promise.then(onFulfilled, onRrejected); // 可以写成：promise.then(onFulfilled) .catch(onRrejected); Promise chain链式调用 promise.then方法每次调用 都返回一个新的promise对象 所以可以链式写法123456789101112131415function taskA() &#123; console.log("Task A");&#125;function taskB() &#123; console.log("Task B");&#125;function onRejected(error) &#123; console.log("Catch Error: A or B", error);&#125;var promise = Promise.resolve();promise .then(taskA) .then(taskB) .catch(onRejected) // 捕获前面then方法中的异常 Promise的静态方法 Promise.resolve 返回一个fulfilled状态的promise对象 123456789Promise.resolve('hello').then(function(value)&#123; console.log(value);&#125;);Promise.resolve('hello');// 相当于const promise = new Promise(resolve =&gt; &#123; resolve('hello');&#125;); Promise.reject 返回一个rejected状态的promise对象 1234Promise.reject(24);new Promise((resolve, reject) =&gt; &#123; reject(24);&#125;); Promise.all 接收一个promise对象数组为参数 只有全部为resolve才会调用 通常会用来处理 多个并行异步操作1234567891011121314151617const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;);const p2 = new Promise((resolve, reject) =&gt; &#123; resolve(2);&#125;);const p3 = new Promise((resolve, reject) =&gt; &#123; reject(3);&#125;);Promise.all([p1, p2, p3]).then(data =&gt; &#123; console.log(data); // [1, 2, 3] 结果顺序和promise实例数组顺序是一致的&#125;, err =&gt; &#123; console.log(err);&#125;); Promise.race 接收一个promise对象数组为参数 Promise.race 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。12345678910111213141516unction timerPromisefy(delay) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(delay); &#125;, delay); &#125;);&#125;var startDate = Date.now();Promise.race([ timerPromisefy(10), timerPromisefy(20), timerPromisefy(30)]).then(function (values) &#123; console.log(values); // 10&#125;); Promise的finally1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理十二]]></title>
    <url>%2F2019%2F03%2F12%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[viewport 视口 在PC端，我们开发的HTML页面运行在浏览器中，浏览器有多宽（一般浏览器代表设备的宽度）HTML就有多宽，也就是在浏览器宽度的视口中渲染和呈现我们的页面 移动端和PC端有区别：不管移动端设备(代指打开的浏览器)的宽度是多少，HTML页面的宽度是980(或者1024) =&gt;导致的问题：如果在设备窗口中想把整个页面完全呈现出来（小窗口中完全展示大页面），我们只能把大页面进行缩放，HTML页面缩放了，那么页面中所有内容都缩放了 解决方案 只要让H5页面的宽度和手机设备的宽度保持一致即可，就不会出现手机渲染页面的时候把页面缩放的事情了1234567891011&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;此META标签就是在设置VP(视口)的规则 width=device-width：让HTML页面的宽度等于设备的宽度 height=：设置HTML页面的高度（一般不用） initial-scale=1.0：初始缩放比例是1:1（也就是既不放大也不多小） user-scalable=no：禁止用户手动缩放 maximum-scale=1.0 minimum-scale=1.0：设置最大最小的缩放比例1:1(既不放大也不缩小 =&gt;部分安卓机中只设置user-scalable是不起作用的，需要同这两个一起使用) ... layout viewport：布局（页面）视口（和开发CSS等相关） visual viewport：手机视口 ideal viewport：理想视口 移动端项目 PC端和移动端公用一套项目的（结构相对简单的：一般都是展示类的企业站） 设计师一般只给一套设计稿 先做PC端（设计给的设计稿一般都是给PC端的）一般宽度都是自适应的（具体情况有所不同） 切换到手机端，使用@media（媒体查询）把不同设备上不合适的样式进行修改 PC端和移动端是分开的两套不同项目 设计师一般会给两套设计稿 (PC+移动) PC端单独做（做它的时候不需要考虑移动端响应式）固定布局 移动端单独做（只需要考虑移动端的响应式适配即可） 响应式布局 依然可以基于@MEDIA来处理（麻烦一些） 固定布局(viewport =&gt; width=320px)：按照设计稿把320尺寸的写好即可（所有的尺寸都可以固定，而且都是设计稿的一半 [因为设计稿是大一倍的]），在其它的设备上，让320的页面居中展示即可 SCALE等比缩放布局（严格按照设计稿的尺寸来写样式[没有啥自适应宽度，都是固定值]，在其它设备上，首先获取设备的宽度，让其除以设计稿的宽度，然后让原始写好的页面按照这个比例整体缩小即可） =&gt;会导致一些问题例如字体变模糊… REM等比缩放：它是参考SCALE，只是用的REM单位来实现的等比缩放（严格按照设计稿的尺寸编写 [但是一般宽度让他自适应]，其余的值可以写成固定值 -&gt; 在编写CSS样式的时候，我们把所有的PX单位都换算成REM单位 -&gt; 当加载页面的时候，根据当前设备的尺寸除以设计稿，根据比例动态调整REM和PX的换算比例） CSS3中提供了flex-box伸缩盒子模型，基于这个属性，可以让某些效果处理起来更加的方便 A&amp;&amp;D&amp;&amp;E是目前最常用的响应式布局方案 设计是给的移动端设计稿一般都是：6401136(980或者不定高度)、7501334… 为啥我们的设计稿都比参照的手机大一倍? 目的是保证我们切下来的素材资源图片是大图 为啥要保证是大图？ 因为很多手机都是二倍及三倍屏幕像素密度比(DPR)的 即使给的是二倍设计稿，但是部分手机的设备尺寸要大于设计稿的一半，有的手机是3倍DPR的，这样就导致一个问题：部分图片还是会变的模糊一些，此时我们找设计师单独的把模糊图片要一张大图即可 httpHTTP请求阶段：向服务器发送请求 浏览器首先向DNS域名解析服务器发送请求 DNS反解析：根据浏览器请求地址中的域名，到DNS服务器中找到对应的服务器外网IP地址 通过找到的外网IP，向对应的服务器发送请求（首先访问的是服务器的WEB站点管理工具:准确来说是我们先基于工具在服务器上创建很多服务，当有客户端访问的时候，服务器会匹配出具体是请求哪个服务） 通过URL地址中携带的端口号，找到服务器上对应的服务，以及服务所管理的项目源文件 HTTP响应阶段：服务器把客户端需要的内容准备好，并且返回给客户端 服务器端根据请求地址中的路径名称、问号传参或者哈希值，把客户端需要的内容进行准备和处理 把准备的内容响应给客户端（如果请求的是HTML或者CSS等这样的资源文件，服务器返回的是资源文件中的源代码[不是文件本身]） 浏览器渲染阶段 客户端浏览器接受到服务器返回的源代码，基于自己内部的渲染引擎（内核）开始进行页面的绘制和渲染 首先计算DOM结构，生成DOM TREE 自上而下运行代码，加载CSS等资源内容 根据获取的CSS生成带样式的RENDER TREE 开始渲染和绘制 我们把一次完整的 请求+响应 称之为 “HTTP事务”事务就是完整的一次操作，请求和响应缺一不可 一个页面完全加载完成，需要向服务器发起很多次HTTP事务操作一般来说：首先把HTML源代码拿回来，加载HTML的时候，遇到link/script/img[src]/iframe/video和audio[没有设置preload=’none’]…都会重新和服务器端建立HTTP事务交互 特殊情况：如果我们做了资源缓存处理(304)，而且即将加载的资源在之前已经加载过了，这样的操作和传统的HTTP事务有所不一样，他们是从服务器和浏览器的缓存中读取数据，比传统的读取快很多 在客户端向服务器发送请求，以及服务器把内容响应给客户端的时候，中间相互传递了很多内容(客户端把一些内容传递服务器，服务器把一些内容响应给客户端)，我们把传递的内容统称为“HTTP报文”]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理十一]]></title>
    <url>%2F2019%2F03%2F11%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[正则应用12345678let str = '54389', ary = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖'];str = str.replace(/\d/g, item =&gt; &#123; //=&gt;item =&gt;arg[0] =&gt;正则每一次捕获的内容 5/4/3/8/9 //=&gt;把捕获的数字做为索引，到ARY中找到对应的汉字，用找到的结果替换当前捕获的内容 return ary[item];&#125;);console.log(str); 12345678910//30. 在javascript对象上定义一个repeatify函数,这个函数接受一个整数参数,来明确子字符串需要重复几次,这个函数要求字符串重复指定的次数,比如:’abc’.repeatify(3); //=&gt;”abcabcabc”String.prototype.repeatify = function repeatify(n = 1) &#123; //=&gt;this:需要处理的字符串 let result = ''; for (let i = 0; i &lt; n; i++) &#123; result += this; &#125; return result;&#125;;console.log('abc'.repeatify()); 123456789101112131415161718192021222324//31. `var str='hello&lt;img src="haha.png" alt="哈哈"/&gt;world';`正确匹配输出’hello[哈哈]world’let str = 'hello&lt;img alt="哈哈" src="haha.png"/&gt;world&lt;img src="xiee.png" alt="邪恶"/&gt;', reg = /&lt;img(?:[^&lt;&gt;]*alt="([\u4e00-\u9fa5]*)")\/&gt;/g;str = str.replace(reg, (...arg) =&gt; &#123; return `[$&#123;arg[1]&#125;]`;&#125;);console.log(str);----------------------------------------------------------------------------------let str = 'hello&lt;img alt="哈哈" src="haha.png"/&gt;world&lt;img src="xiee.png" alt="邪恶"/&gt;', reg = /&lt;img([^&lt;&gt;]*)\/&gt;/g;str = str.replace(reg, (...arg) =&gt; &#123; let val = arg[1], regVal = /alt=("|')([\u4e00-\u9fa5]*)\1/, flag = regVal.test(val); if (flag) &#123; val = regVal.exec(val)[2] || ''; return `[$&#123;val&#125;]`; &#125; return '';&#125;);console.log(str); 12345678910111213// 一个url 后面好多key-value 如localhost?key=val&amp;key2=val2&amp;key3=val3 封装一个函数 getParam(‘key’) 通过key获得相应等号后面的值.let getParam = function (attr) &#123; //=&gt;先把URL问号后面的值获取到 let str = 'localhost?name=zhufeng&amp;year=9&amp;teacher=zxt', obj = &#123;&#125;, reg = /([^?&amp;=#]+)=([^?&amp;=#]+)/g; str.replace(reg, (...arg) =&gt; &#123; let [, key, value] = arg; obj[key] = value; &#125;); return obj[attr];&#125;;console.log(getParam('xxx')); 1234567/* 写出完整的验证函数 &gt; 1)长度不能小于6位 &gt; 2)首字母必须是字母 &gt; 3)合法字符只能是数字、字母、下划线 */let reg = /^[a-zA-Z]\w&#123;5,&#125;$/; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 获取字符串中出现次数最多的字符及出现的次数let str = 'zhufengpeixunzhouxiaotian';/* * 思路一：获取字符串中的每一个字母，然后以对象键值对的方式存储起来（属性名是字符，属性值是出现的次数） *///1.获取每一个字符出现的次数，以及出现的最大次数let obj = &#123;&#125;, max = 1, result = [];str.replace(/./g, char =&gt; &#123; if (obj.hasOwnProperty(char)) &#123; obj[char]++; if (obj[char] &gt; max) &#123; max = obj[char]; &#125; return; &#125; obj[char] = 1;&#125;);//2.获取和MAX相匹配次数的字符for (let char in obj) &#123; if (obj.hasOwnProperty(char)) &#123; if (obj[char] === max) &#123; result.push(char); &#125; &#125;&#125;console.log(`最多出现的次数是：$&#123;max&#125; 次，对应的字符有：$&#123;result&#125;`);/* * 思路二：先把字符串中的每一个字符变为数组中的每一项，给数组排序，在变为字符串（相同的字符挨着），在基于正则捕获替换 */let max = 1;str = str.split('').sort().join('');//=&gt;'aaeefghhiiinnnooptuuuxxzz'str = str.replace(/(.)\1*/g, (...arg) =&gt; &#123; let [value, char] = arg, len = value.length; len &gt; max ? max = len : null; return `$&#123;char&#125;&#123;$&#123;len&#125;&#125;`;&#125;);// console.log(str);//=&gt;'a&#123;2&#125;e&#123;2&#125;f&#123;1&#125;g&#123;1&#125;h&#123;2&#125;i&#123;3&#125;n&#123;3&#125;o&#123;2&#125;p&#123;1&#125;t&#123;1&#125;u&#123;3&#125;x&#123;2&#125;z&#123;2&#125;'// let reg =/([^\d&#123;&#125;])\&#123;"+max+"\&#125;/g;//=&gt;字面创建正则的方式，正则中的每一个字符都是元字符，不能实现把一个变量的值作为正则一部分的需求let reg = new RegExp('([^\\d&#123;&#125;])\\&#123;' + max + '\\&#125;', 'g');str.replace(reg, (...arg) =&gt; &#123; console.log(arg[1]);&#125;); 同步异步编程 JS中的同步编程和异步编程 同步编程：任务是按照顺序依次处理，当前这件事没有彻底做完，下一件事是执行不了的 异步编程：当前这件事没有彻底做完，需要等待一段时间才能继续处理，此时我们不等，继续执行下面的任务，当后面的任务完成后，再去把没有彻底完成的事情完成JS中的异步编程 所有的事件绑定都是异步编程 xxx.onclick=function(){} 所有的定时器都是异步编程 setTimeout(function(){},1000) AJAX中一般都使用异步编程处理 回调函数也算是异步编程 浏览器是如何规划同步异步机制的 浏览器是多线程的，JS是单线程的（浏览器只给JS执行分配一个线程）：单线程的特点就是一次只能处理一件事情 进程：每一个应用程序都可以理解为一个进程（浏览器打开一个页面，就相当于开辟一个进程），在一个程序中（进程中）我们经常会同时干很多事情，此时我们可以分配多个线程去同时完成多项任务 JS在单线程中实现异步的机制，主要依赖于浏览器的任务队列完成的。浏览器中有两个任务队列（主任务队列、等待任务队列） Promise 它是ES6中新增加的类 (new Promise)，目的是为了管理JS中的异步编程的，所以我们也把它称为“Promise设计模式” 三个状态：pending(准备:初始化成功，开始执行异步的任务)\fulfilled(成功)\rejected(失败) 12345678910111213141516171819202122new Promise(() =&gt; &#123; //=&gt;执行一个异步的任务（new Promise的时候，创建Promise的一个实例，立即会把当前函数体中的异步操作执行） =&gt;“Promise是同步的，它可以管理异步操作” setTimeout(() =&gt; &#123; &#125;, 1000); console.log(1);//=&gt;先输出1&#125;).then();console.log(2);//=&gt;再输出2------------------------------------------------new Promise((resolve, reject) =&gt; &#123; //=&gt;resolve：当异步操作执行成功，我们执行resolve方法 //=&gt;reject：当异步操作执行失败，我们执行reject方法 setTimeout(() =&gt; &#123; resolve(100); &#125;, 1000);&#125;).then((res) =&gt; &#123; //=&gt;第一个传递的函数是resolve console.log('ok', res);&#125;, () =&gt; &#123; //=&gt;第二个传递的函数是reject console.log('no');&#125;); js动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/*==ANIMATE动画库==*/~function () &#123; //=&gt;准备操作CSS样式的方法 GET-CSS/SET-CSS/SET-GROUP-CSS/CSS let utils = (function () &#123; //=&gt;获取样式 let getCss = (ele, attr) =&gt; &#123; let val = null, reg = /^-?\d+(\.\d+)?(px|rem|em)?$/; if ('getComputedStyle' in window) &#123; val = window.getComputedStyle(ele)[attr]; if (reg.test(val)) &#123; val = parseFloat(val); &#125; &#125; return val; &#125;; //=&gt;设置样式 let setCss = (ele, attr, value) =&gt; &#123; if (!isNaN(value)) &#123; if (!/^(opacity|zIndex)$/.test(attr)) &#123; value += 'px'; &#125; &#125; ele['style'][attr] = value; &#125;; //=&gt;批量设置样式 let setGroupCss = (ele, options) =&gt; &#123; for (let attr in options) &#123; if (options.hasOwnProperty(attr)) &#123; setCss(ele, attr, options[attr]); &#125; &#125; &#125;; //=&gt;合并为一个 let css = (...arg) =&gt; &#123; let len = arg.length, fn = getCss; if (len &gt;= 3) &#123; fn = setCss; &#125; if (len === 2 &amp;&amp; typeof arg[1] === 'object') &#123; fn = setGroupCss; &#125; return fn(...arg); &#125;; return &#123;css&#125; &#125;)(); //=&gt;EFFECT：准备运动的公式 let effect = &#123; Linear: (t, b, c, d) =&gt; t / d * c + b &#125;; //=&gt;封装动画库 window.animate = function (ele, target = &#123;&#125;, duration = 1000, callback = new Function()) &#123; //=&gt;不传递CALL-BACK，让其默认为一个空函数（回调函数：当动画结束后做什么事，都放到回调函数完成即可） if (typeof duration === 'function') &#123; //=&gt;我们有四个形参，但是传递的时候只传递三个，最后一个回调函数传递给duration这个参数了，我们需要改一下参数的值 callback = duration; duration = 1000; &#125; //1.基于TARGET计算出BEGIN/CHANGE let begin = &#123;&#125;, change = &#123;&#125;, time = 0; for (let attr in target) &#123; if (target.hasOwnProperty(attr)) &#123; begin[attr] = utils.css(ele, attr); change[attr] = target[attr] - begin[attr]; &#125; &#125; //2.实现动画 clearInterval(ele.animteTimer);//=&gt;在给当前元素设置新的动画之前,先清空原有正在运行的动画(防止多动画共存,把动画的返回值赋值给当前元素的自定义属性，这样只要元素不变，我们不管啥时候在哪执行都可以清除元素的动画) ele.animteTimer = setInterval(() =&gt; &#123; time += 17; //=&gt;边界判断 if (time &gt;= duration) &#123; utils.css(ele, target); clearInterval(ele.animteTimer); callback.call(ele);//=&gt;动画完成后执行CALL-BACK(并且让回调函数中的THIS是当前操作的元素本身) return; &#125; //=&gt;依托TARGET计算出每个方向的当前位置 let cur = &#123;&#125;; for (let attr in target) &#123; if (target.hasOwnProperty(attr)) &#123; cur[attr] = effect.Linear(time, begin[attr], change[attr], duration); &#125; &#125; utils.css(ele, cur); &#125;, 17); &#125;;&#125;(); 动画函数封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//=&gt;UTILS操作CSS工具库let utils = (function () &#123; //=&gt;获取样式 let getCss = (ele, attr) =&gt; &#123; let val = null, reg = /^-?\d+(\.\d+)?(px|rem|em)?$/; if ('getComputedStyle' in window) &#123; val = window.getComputedStyle(ele)[attr]; if (reg.test(val)) &#123; val = parseFloat(val); &#125; &#125; return val; &#125;; //=&gt;设置样式 let setCss = (ele, attr, value) =&gt; &#123; if (!isNaN(value)) &#123; if (!/^(opacity|zIndex)$/.test(attr)) &#123; value += 'px'; &#125; &#125; ele['style'][attr] = value; &#125;; //=&gt;批量设置样式 let setGroupCss = (ele, options) =&gt; &#123; for (let attr in options) &#123; if (options.hasOwnProperty(attr)) &#123; setCss(ele, attr, options[attr]); &#125; &#125; &#125;; //=&gt;合并为一个 let css = (...arg) =&gt; &#123; let len = arg.length, fn = getCss; if (len &gt;= 3) &#123; fn = setCss; &#125; if (len === 2 &amp;&amp; typeof arg[1] === 'object') &#123; fn = setGroupCss; &#125; return fn(...arg); &#125;; //=&gt;EACH：遍历对象、数组、类数组 let each = (obj, callback) =&gt; &#123; if ('length' in obj) &#123; for (let i = 0; i &lt; obj.length; i++) &#123; let item = obj[i], res = callback &amp;&amp; callback.call(item, i, item); if (res === false) &#123; break; &#125; &#125; return; &#125; for (let attr in obj) &#123; if (obj.hasOwnProperty(attr)) &#123; let item = obj[attr], res = callback &amp;&amp; callback.call(item, attr, item); if (res === false) &#123; break; &#125; &#125; &#125; &#125;; return &#123;css, each&#125;&#125;)();//=&gt;ANIMATE动画库~function () &#123; //=&gt;匀速运动公式 let effect = &#123; Linear: (t, b, c, d) =&gt; t / d * c + b &#125;; //=&gt;开始运动 window.animate = function animate(ele, target, duration = 1000, callback) &#123; //=&gt;参数处理(传递三个值,第三个值是函数,其实本身想要代表的意思：第三个是回调函数，总时间是默认值即可) if (typeof duration === 'function') &#123; callback = duration; duration = 1000; &#125; //=&gt;准备数据 let time = 0, begin = &#123;&#125;, change = &#123;&#125;; utils.each(target, (key, value) =&gt; &#123; begin[key] = utils.css(ele, key); change[key] = value - begin[key]; &#125;); //=&gt;设置新动画之前清除原有正在运行的动画 clearInterval(ele.animateTimer); ele.animateTimer = setInterval(() =&gt; &#123; time += 17; //-&gt;动画结束 if (time &gt;= duration) &#123; clearInterval(ele.animateTimer); utils.css(ele, target); callback &amp;&amp; callback.call(ele); return; &#125; //-&gt;获取每个方向的当前位置，并且给元素设置 utils.each(target, (key, value) =&gt; &#123; let cur = effect.Linear(time, begin[key], change[key], duration); utils.css(ele, key, cur); &#125;); &#125;, 17); &#125;;&#125;();]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理十]]></title>
    <url>%2F2019%2F03%2F10%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%8D%81%2F</url>
    <content type="text"><![CDATA[js中的thisJS中的THIS汇总 THIS:当前方法执行的主体(谁执行的这个方法,那么THIS就是谁,所以THIS和当前方法在哪创建的或者在哪执行的都没有必然的关系) 给元素的某个事件绑定方法，方法中的THIS都是当前操作的元素本身123document.body.onclick = function () &#123; //=&gt;this:body&#125;; 函数执行，看函数前面是否有点，有的话，点前面是谁THIS就是谁，没有点，THIS是WINDOW（在JS的严格模式下，没有点THIS是UNDEFINED）123456789let fn = function () &#123; console.log(this.name);&#125;;let obj = &#123; name: '哈哈', fn: fn&#125;;fn();//=&gt;this:windowobj.fn();//=&gt;this:obj 构造函数执行，方法中的this一般都是当前类的实例 1234let Fn = function () &#123; this.x = 100;//=&gt;this:f&#125;;let f = new Fn; 箭头函数中没有自己的THIS,THIS是上下文中的THIS 123456789let obj = &#123; fn: function () &#123; // this:obj setTimeout(() =&gt; &#123; //this:obj &#125;, 1000); &#125;&#125;;obj.fn(); 在小括号表达式中，会影响THIS的指向 1234567let obj = &#123; fn: function () &#123; console.log(this); &#125;&#125;;obj.fn();//=&gt;this:obj;(12, obj.fn)();//=&gt;this:window 使用call/apply/bind可以改变this指向 123fn.call(12);//=&gt;this:12fn.call();//=&gt;this:window 非严格模式下call/apply/bind第一个参数不写或者写null和undefined，this都是window，严格模式下写谁this就是谁，不写是undefinedfn.call(obj);//=&gt;this:obj 数组去重对象键值对处理（推荐）12345678910111213141516171819Array.prototype.myUnique = function () &#123; //=&gt;this:ary 我们需要操作的数组，如果不想改变原有的数组，我们需要把要操作的数组克隆一份一模一样的处理，处理的都是克隆的这个数组 let _this = [...this], obj = &#123;&#125;; for (let i = 0; i &lt; _this.length; i++) &#123; let item = _this[i]; if (typeof obj[item] !== 'undefined') &#123; //=&gt;当前迭代的这一项在数组中已经存在，我们把这一项在数组中干掉 // _this.splice(i, 1); [后面项移位，消耗性能] _this[i] = _this[_this.length - 1]; _this.length--; i--; continue; &#125; obj[item] = true; &#125; obj = null; return _this;&#125;; 双循环(不推荐)12345678910111213141516Array.prototype.myUnique = function () &#123; let _this = [...this]; for (let i = 0; i &lt; _this.length; i++) &#123; let item = _this[i]; //=&gt;每一次迭代到ITEM后,都拿其后面的内容和它进行比较（出现和当前项相同的，我们就在数组中把其干掉） for (let j = i + 1; j &lt; _this.length; j++) &#123; if (item === _this[j]) &#123; //=&gt;删除索引J这一项 _this[j] = _this[_this.length - 1]; _this.length--; j--; &#125; &#125; &#125; return _this;&#125;; 数组indexOf123456789101112131415// 获取当前项在数组中第一次出现位置的索引，也能判断是否存在这一项（不存在获取的索引是-1），这个方法是不兼容IE6~8的Array.prototype.myUnique = function () &#123; let _this = [...this]; //=&gt;依次迭代数组中的每一项，验证当前项在数组中是否存在（不是和整个数组比较是否存在，而是和当前项的后面项比较是否存在=&gt;类似于双FOR）,存在把当前项干掉 for (let i = 0; i &lt; _this.length; i++) &#123; let item = _this[i], nextAry = _this.slice(i + 1); if (nextAry.indexOf(item) &gt; -1) &#123; _this[i] = _this[_this.length - 1]; _this.length--; i--; &#125; &#125; return _this;&#125;; 排序后相邻去除法12345678910111213//先把数组进行排序，验证当前项和后一项是否相同，如果不相同，说明没有重复，我们把着于相提取出来保存即可Array.prototype.myUnique = function () &#123; let _this = [], ary = this.slice(0).sort((a, b) =&gt; a - b); for (let i = 0; i &lt; ary.length; i++) &#123; let item = ary[i], next = ary[i + 1]; if (item !== next) &#123; _this.push(item); &#125; &#125; return _this;&#125;;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理九]]></title>
    <url>%2F2019%2F03%2F08%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[正则捕获 把一个字符串中和正则匹配的部分获取到 正则 exec test 字符串 replace split match 基于EXEC可以实现正则的捕获 如果当前正则和字符串不匹配，捕获的结果是NULL 如果匹配，捕获的结果是一个数组 0:大正则捕获的内容 index:正则捕获的起始索引 input:原始操作的字符串 … 执行一次EXEC只能捕获到第一个和正则匹配的内容，其余匹配的内容还没有捕获到，而且更恶心的是，我傻傻的执行多次，然而并没啥卵用 =&gt;“正则的捕获有懒惰性”：只能捕获到第一个匹配的内容，剩余的默认捕获不到 解决正则捕获的懒惰性，我们需要加全局修饰符G（这个是唯一的方案，而且不加G不管用什么办法捕获，也都不能把全部匹配的捕获到） 123456789101112131415161718192021222324252627 let str = 'zhufeng2018peixun2019'; let reg = /\d+/; console.log(reg.exec('zhufengpeixun'));//=&gt;null console.log(reg.exec(str));//=&gt;['2018',index:7,input:...]//=&gt;LAST-INDEX不变导致了正则捕获的懒惰性 console.log(reg.lastIndex);//=&gt;0 正则捕获时候，下一次在字符串中开始查找的索引 console.log(reg.exec(str));//=&gt;['2018']--------------------------------------------------------//=&gt;即使我们手动修改了LAST-INDEX，然而还是没用 console.log(reg.exec(str));//=&gt;['2018'] reg.lastIndex = 11; console.log(reg.lastIndex); console.log(reg.exec(str));//=&gt;['2018']// 需要正则表达式加上全局匹配符 ‘g’// let str = 'zhufeng2018peixun2019';// let reg = /\d+/g;// console.log(reg.lastIndex);//=&gt;0// console.log(reg.exec(str));//=&gt;['2018']// console.log(reg.lastIndex);//=&gt;11// console.log(reg.exec(str));//=&gt;['2019']// console.log(reg.lastIndex);//=&gt;21// console.log(reg.exec(str));//=&gt;null// console.log(reg.lastIndex);//=&gt;0// console.log(reg.exec(str));//=&gt;['2018'] ?在正则中的作用 量词元字符：出现零次或者一次 /-?/ 让减号出现一次或者不出现 取消贪婪性 /\d+?/ 捕获的时候只捕获最短匹配的内容 ?: 只匹配不捕获 ?= 正向预查 ?! 负向预查 1234567891011121314151617181920212223 let str = 'zhufeng2018peixun2019'; let reg = /\d+/g; console.log(reg.test(str));//=&gt;TRUE console.log(reg.lastIndex);//=&gt;11 基于TEST进行匹配的时候，如果设置了G，TEST匹配也相当于捕获，修改了LAST-INDEX的值 console.log(reg.exec(str));//=&gt;['2019']------------------------------------------------------------------------------- let str = 'zhufeng2018'; let reg = /\d+/g; console.log(reg.exec(str));//=&gt;['2018'] 把REG.LAST-INDEX修改了 console.log(reg.exec('zhufeng2018peixun2019'));//=&gt;['2019'] 虽然捕获的不是同一个字符串，但是正则是同一个，上一次正则处理的时候修改了它的LAST-INDEX，也会对下一次匹配新的字符串产生影响 ------------------------------------------------------------------------------ let str = 'zhufeng2018peixun2019'; let reg = /(\d+)/g; console.log(reg.test(str));//=&gt;TRUE console.log(RegExp.$1);//=&gt;'2018' //=&gt;把上一次匹配(TEST/EXEC)到的结果获取到，获取的是第一个小分组匹配的内容，大正则匹配的内容无法获取，它是一个全局的值，浏览器中$1只有一个，其它的正则操作也会覆盖这个值，所以这种方式没啥用 console.log(reg.test(str));//=&gt;TRUE console.log(RegExp.$1);//=&gt;'2019' console.log(reg.test(str));//=&gt;FALSE console.log(RegExp.$1);//=&gt;'2019' console.log(reg.test(str));//=&gt;TRUE console.log(RegExp.$1);//=&gt;'2018' replace：实现正则捕获的方法（本身是字符串替换）12345678910//==============REPLACE原理let str = 'zhufeng&#123;val:2018&#125;zhufeng&#123;val:2019&#125;', reg = /\&#123;val:(\d+)\&#125;/g;str = str.replace(reg, '@');//=&gt;用REG正则和STR字符串进行匹配，匹配几次就替换几次，每一次都是把当前“大正则”匹配的结果用第二个传递的字符串替换掉了console.log(str); //=&gt;'zhufeng@zhufeng@'--------------------------------------------------------------------let str = 'zhufeng&#123;val:2018&#125;zhufeng&#123;val:2019&#125;', reg = /\&#123;val:(\d+)\&#125;/g;str = str.replace(reg, '$1');//=&gt;$1不是拿这个字符串替换掉大正则匹配的内容，此处的$1代表第一个分组匹配的内容，等价于 RegExp.$1console.log(str);//=&gt;'zhufeng2018zhufeng2019' REG 和 STR 匹配多少次，函数就被触发执行对少次，而且传递了一些参数信息值 每一次ARG中存储的信息，和执行EXEC捕获的信息相似（内置原理：每一次正则匹配到结果，都把函数执行，然后基于EXEC把本次匹配的信息捕获到，然后把捕获的信息传递给这个函数） 每一次函数中返回的是啥，就把当前大正则匹配的内容替换成啥 1234567891011121314151617 let str = "2018/4/30 17:50:23"; //1.获取时间字符串中的所有数字 (SPLIT) let ary = str.match(/\d+/g).map(item =&gt; &#123; return item &lt; 10 ? '0' + item : item; &#125;);//=&gt;MAP相对于FOR-EACH来讲多了返回值,函数中RETURN的是啥,就是把当前数组中迭代的这一项替换成啥// // console.log(ary);//=&gt;["2018", "04", "30", "17", "50", "23"]//2. 指定最后想要的时间格式，我们基于这个数组中的内容，帮你拼接好即可let template = '&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒'; //=&gt;&#123;0&#125; / 0 =&gt;'2018' ARY[0] //=&gt;&#123;1&#125; / 1 =&gt;'04' ARY[1] //=&gt;... template = template.replace(/\&#123;(\d)\&#125;/g, (...arg) =&gt; &#123; let [, index] = arg;//=&gt;index:每一次正则匹配小分组捕获的结果(也就是那个数字) return ary[index]; &#125;);// console.log(template); 时间字符串格式化1234String.prototype.myFormatTime = function myFormatTime(template = '&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒') &#123; let ary = this.match(/\d+/g).map(item =&gt; (item &lt; 10 ? '0' + item : item)); return template.replace(/\&#123;(\d)\&#125;/g, (...[, index]) =&gt; ary[index] || '00');&#125;;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理八]]></title>
    <url>%2F2019%2F03%2F07%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%85%AB%2F</url>
    <content type="text"><![CDATA[JQueryJQuery中常用的方法参考网站：[http://jquery.cuishifeng.cn/] 1.原型 $().xxx() get / eq children find filter index next / nextAll prev / prevAll siblings parent parents each css addClass / removeClass / toggleClass / hasClass attr / removeAttr prop / removeProp animate stop finish html val text append / appendTo insertBefore insertAfter width / height innerWidth / innerHeight outerWidth / outerHeight scrollTop / scrollLeft 2.对象 $.xxx() 检测数据类型的 isArray isFunction ajax toArray toJSON jquery 个人理解123456789101112131415161718192021222324252627(function(window)&#123; var jQuery = function(selector,context)&#123; //=&gt;执行jQuery方法：new jQuery.fn.init 创建INIT这个类的实例,把传递给JQ的参数原封不动的传递给了INIT这个类 return jQuery.fn.init(selector,context) &#125; jQuery.fn = jQuery.prototype = &#123; constructor:jQuery, // $() 实例的方法 。。。。 &#125; var init = jQuery.fn.init = function(selector,context)&#123; // $() / jQuery()调用此方法，避免使用new jQuery() 来创建实例对象 &#125; init.prototype = jQuery.prototype; // 执行jQuery原型，init() 方法new 出来的就是 jquery实例对象 window.jQuery = window.$ = jQuery;&#125;)(window)// $() &lt;==&gt; jQuery() ：创建JQ这个类的一个实例// new jQuery();//=&gt;饶了一圈的目的即使把JQ像普通函数一样执行，但是返回的结果依然是这个类的一个实例// JQ即是一个类也是一个对象// $()创建它的一个实例，可以调取jQuery.fn/jQuery.prototype上的属性和方法：$().xxx()// jQuery.xxx=xxx，这些是作为对象给JQ加的私有属性和访问，使用的时候：$.xxx()//=&gt;extend在对象和原型上都存在，但是是一个方法// $.extend()// $.fn.extend() $.prototype.extend()// $().extend() 关于JQ中的EACH JQ中的原型和对象上都提供了EACH方法，但是最后用的还是JQ对象上的EACH，JQ中的EACH本质上只有一个（对象中的EACH） $.each([obj],[function]) 遍历对象、数组、类数组中的每一项的，有点类似于数组内置方法forEach1234567891011121314151617 jQuery.prototype.each = function (callback, args) &#123; return jQuery.each(this, callback, args); &#125;; jQuery.extend(&#123; each: function (obj, callback, args) &#123; //... &#125; &#125;); // let $boxList = $('div');//=&gt;基于JQ选择器获取的是一个类数组集合// $boxList.each(function()&#123;&#125;); //=&gt; jQuery.each($boxList, function()&#123;&#125;); 遍历$boxList// $.each($boxList, function (index, item) &#123;// //=&gt;当前类数组中有多少项，函数就被执行多少次// //index:当前这一次循环的索引// //item:当前循环这一次对应项的内容// //this:item// &#125;);]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理七]]></title>
    <url>%2F2019%2F03%2F06%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E4%B8%83%2F</url>
    <content type="text"><![CDATA[DOM的属性和方法获取元素或者元素集合getElementById 上下文只能是document（只有document这个实例的原型链上才能找到这个方法，其它实例都找不到）ID重复了获取第一个IE6~7中会把表单元素的name当做id使用 getElementsByTagName 获取当前上下文中，所有子子孙孙中标签名叫做XXX的元素 getElementsByClassName IE6~8中不兼容 getElementsByName 在IE浏览器中只对表单元素的name起作用上下文也只能是document querySelector\querySelectorAll 不兼容IE6~8没有DOM映射 document.documentElement document.body document.head … offset系列 offsetParent 当前盒子的父级参照物 offsetTop / offsetLeft &nbsp;&nbsp;&nbsp;&nbsp;获取当前盒子距离其父级参照物的偏移量(上偏移/左偏移) 当前盒子的外边框开始~父级参照物的内边框&nbsp;&nbsp;&nbsp;&nbsp;“参照物”：同一个平面中，元素的父级参照物和结构没有必然联系，默认他们的父级参照物都是BODY（当前平面最外层的盒子） BODY的父级参照物是NULL center.offsetParent //=&gt;BODY inner.offsetParent //=&gt;BODY outer.offsetParent //=&gt;BODY&nbsp;&nbsp;&nbsp;&nbsp;“参照物可以改变”：构建出不同的平面即可（使用zIndex，但是这个属性只对定位有作用），所以改变元素的定位(position:relative/absolute/fixed)可以改变其父级参照物 scrollTop / scrollLeft 滚动条卷去的宽度或者高度 最小卷去值：0 最大卷去值：真实页面的高度 - 一屏幕的高度 document.documentElement.scrollHeight-document.documentElement.clientHeight 在JS盒子模型13个属性中，只有scrollTop/scrollLeft是“可读写”属性，其余都是“只读”属性 js常见操作dom的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//=&gt;公共方法库:项目中常用的一些方法封装let utils = (function () &#123; //=&gt;获取元素的样式 let getCss = function (curEle, attr) &#123; if (typeof window.getComputedStyle === 'undefined') &#123; return; &#125; let val = window.getComputedStyle(curEle, null)[attr], reg = /^-?\d+(\.\d+)?(px|rem|em|pt)?$/i; reg.test(val) ? val = parseFloat(val) : null; return val; &#125;; //=&gt;设置元素样式 let setCss = function (curEle, attr, value) &#123; if (attr === 'opacity') &#123; curEle.style.opacity = value; curEle.style.filter = `alpha(opacity=$&#123;value * 100&#125;)`; return; &#125; if (!isNaN(value)) &#123; let reg = /^(width|height|fontSize|((margin|padding)?(top|left|right|bottom)?))$/i; reg.test(attr) ? value += 'px' : null; &#125; curEle['style'][attr] = value; &#125;; //=&gt;批量设置元素样式 let setGroupCss = function (curEle, options = &#123;&#125;) &#123; for (let attr in options) &#123; if (!options.hasOwnProperty(attr)) break; setCss(curEle, attr, options[attr]); &#125; &#125;; //=&gt;CSS操作汇总 let css = function (...arg) &#123; let len = arg.length, fn = getCss; len &gt;= 3 ? fn = setCss : null; len === 2 &amp;&amp; (arg[1] instanceof Object) ? fn = setGroupCss : null; return fn(...arg); &#125;; //=&gt;offset：获取当前元素距离BODY的偏移(左偏移和上偏移) let offset = function (curEle) &#123; //1.先获取当前元素本身的左/上偏移 let curLeft = curEle.offsetLeft, curTop = curEle.offsetTop, p = curEle.offsetParent; //2.累加父参照物的边框和偏移(一直向上找,找到BODY为止,每当找到一个父参照物都把它的边框和偏移累加起来,根据元素不一样,具体找几次也不知道) //TAG-NAME获取当前元素的标签名(大写的) while (p.tagName !== 'BODY') &#123;//=&gt;当找到的父参照物是BODY结束查找和累加操作 //3.把找到的父参照物的边框和偏移值累加起来 curLeft += p.clientLeft; curLeft += p.offsetLeft; curTop += p.clientTop; curTop += p.offsetTop; p = p.offsetParent;//=&gt;基于当前找到的父参照物继续向上查找 &#125; return &#123; top: curTop, left: curLeft &#125;; &#125;; //=&gt;操作浏览器盒子模型属性的 let winHandle = function (attr, value) &#123; if (typeof value !== 'undefined') &#123; //=&gt;设置盒子模型属性值:SCROLL-TOP/LEFT document.documentElement[attr] = value; document.body[attr] = value; return; &#125; return document.documentElement[attr] || document.body[attr]; &#125;; return &#123; css, //=&gt;在ES6中直接这样写相当于 css:css offset, winHandle &#125;&#125;)(); CSS中的盒子模型 一个盒子的WIDTH/HEIGHT/PADDING/BORDER/MARGIN…样式属性构成一个盒子模型 传统 WIDTH/HEIGHT: 内容的宽度和高度（盒子的宽度高度是内容+填充+边框） CSS3 BOX-SIZING:BORDER-BOX WIDTH/HEIGHT:一个盒子的最终宽高，我们调整PADDING/BORDER，盒子大小不变，会自动的缩减内容的宽度和高度 JS中的盒子模型 基于一些属性和方法获取到当前元素的相关样式 CLIENT(WIDTH/HEIGHT/TOP/LEFT) OFFSET(WIDTH/HEIGHT/TOP/LEFT/PARENT) SCROLL(WIDTH/HEIGHT/TOP/LEFT) CLIENT系列 CLIENT(WIDTH/HEIGHT) 内容的宽高+PADDING，代表当前盒子可视区域的宽高 “对于浏览器来说，可视区域其实就是一屏幕的宽度和高度”12345//获取当前浏览器一屏幕的宽度高度（兼容所有浏览器） document.documentElement.clientWidth || document.body.clientWidthdocument.documentElement.clientHeight || document.body.clientHeight//2.CLIENT(TOP/LEFT) 盒子边框的宽度(上/左) OFFSET系列 OFFSET(WIDTH/HEIGHT)：在CLIENT的基础上加上BORDER（内容宽高+PADDING+BORDER） 注意：当我们设置了固定的宽高，不管内容是否溢出，对宽高都不会有影响，所以CLIENT \ OFFSET 获取的结果不受内容是否溢出的影响 SCROLL(WIDTH/HEIGHT) 真实内容的宽高(包含溢出部分的内容)+左或者上PADDING，当内容没有溢出的情况下和CLIENT相同 基于这个属性获取的值每个浏览器都不太一样，而且同一个浏览器设置了OVERFLOW：HIDDEN也会对结果产生影响（这个值是一个参考值）12//=&gt;获取当前页面真实的高度 document.documentElement.scrollHeight||document.body.scrollHeight 以上8个属性具备一些特点 获取的结果是一个数字(没有单位) 获取的结果是几个样式组合到一起的值（局限性：我只想获取宽高或者PADDING就不能基于这几个属性完成了） 获取的结果都是整数（一般情况下会自己进行小数的四舍五入） 需求：只想获取WIDTH（获取当前元素具体的某个样式属性的值） getComputedStyle 在IE6~8中没有这个方法，需要使用 xxx.currentStyle 这个属性获取 window.getComputedStyle([元素],[元素伪类，一般都是不写或者写NULL]) 结果是一个对象，包含当前元素所有经过浏览器计算的样式属性和值（只要当前元素可以在页面中呈现，都是被浏览器计算过的），有些样式属性是我们自己设定的，还有很多都是浏览器的默认样式值 GET-CSS1234567891011121314151617//获取某一个元素对象指定的样式属性值//ELE:元素对象//ATTR:元素的样式属性名(字符串格式)let getCss = function (ele, attr) &#123; let val = null; //=&gt;验证是否兼容:不兼容WIN中没有这个属性(属性值是UNDEFINED) //if(typeof window.getComputedStyle !== 'undefined') //if(window.getComputedStyle) if ('getComputedStyle' in window) &#123; val = window.getComputedStyle(ele)[attr]; //=&gt;把获取的结果去除单位（只有符合 纯数字或者数字加单位的 两种字符串我们再基于PARSE-FLOAT去掉单位即可） let reg = /^-?\d+(\.\d+)?(px|pt|em|rem)?$/i; reg.test(val) ? val = parseFloat(val) : null; &#125; return val;&#125;; SET-CSS12345678910111213141516171819//设置当前元素某一个样式属性的具体值//ELE:元素对象//ATTR:元素的样式属性名(字符串格式)//VALUE:设置的值let setCss = function (ele, attr, value) &#123; //=&gt;对于某些样式属性，如果传递的值没有单位，我们手动增加PX单位 //1.传递的需要是数字才有可能加单位 //2.对于Z-INDEX/OPACITY等样式属性，属性值就是数字，不须要加单位 // if (!isNaN(value)) &#123;//=&gt;传递的是有效数字(纯数字字符串) // if (!/^(zIndex|opacity)$/i.test(attr)) &#123;//=&gt;操作的样式或属性不是层级和透明度两个 // value += 'px'; // &#125; // &#125; !isNaN(value) &amp;&amp; !/^(zIndex|opacity)$/i.test(attr) ? value += 'px' : null; ele['style'][attr] = value; //=&gt;在JS中给元素设置样式只有两种 //1.xxx.className=xxx 设置样式类(前提已经把样式写在样式类中了) //2.xxx.style.xxx=xxx 给元素设置行内样式值&#125;; SET-GROUP-CSS1234567891011121314151617181920212223242526272829//给当前元素批量设置样式//ELE:元素对象//OPTIONS:给当前元素需要设置的样式对象//批量设置也是迭代样式对象，有几个样式属性我们就分别调取SET-CSS几次，给其设置样式let setGroupCss = function (ele, options) &#123; //=&gt;迭代对象使用FOR-IN循环 for (let key in options) &#123; //=&gt;OPTIONS对象中有多少组键值对，循环就执行几次，每一次KEY是当前迭代的属性名，OPTIONS[KEY]就是每一次迭代的属性值 // KEY:background / opacity // OPTIONS[KEY]:'lightblue' / 0.2 if (options.hasOwnProperty(key)) &#123; setCss(ele, key, options[key]); &#125; &#125;&#125;;/*Object.prototype.AA = 100;let obj = &#123;name: 'xxx', 1: 1, age: 25, 0: 0&#125;;//=&gt;obj.__proto__===Object.prototypefor (let key in obj) &#123; /!* * 1.有多少组键值对就迭代多少次(可以使用BREAK/CONTINUE) * 2.迭代的时候，先把数字属性名按照由小到大依次迭代，完成后在迭代字符串属性名（数字优先迭代） * 3.FOR-IN在迭代的时候，会把当前实例原型链上自己扩展的属性和方法也迭代到（迭代公有属性），内置的不能迭代（因为他们是不可枚举的） * *!/ if (obj.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;*/]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理六]]></title>
    <url>%2F2019%2F03%2F05%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%85%AD%2F</url>
    <content type="text"><![CDATA[正则特殊元字符 \d 0~9之间的一个数字 \D 非0~9之间的任意字符 \w “数字、字母、下划线”中的任意一个 =&gt;/[0-9a-zA-Z_]/等价于\w \s 匹配任意一个空白字符（包括\t制表符[TAB键四个空格]） \b 匹配边界符 ‘zhu’(z左边和u右边就是边界) ‘zhu-feng’(z左边、u右边、f左边、g右边是边界) \n 匹配一个换行符 \ 转义字符(把一个普通字符转义为特殊的字符,例如:\d，把有特殊含义的转换为普通意思，例如：. 此处的点就不是任意字符，而是一个小数点) . 不仅仅是小数点，代表除了\n以外的任意字符 ^ 以某个元字符开头 $ 以某个元字符结尾 x|y x或者y中的任意一个(a|z…) [xyz] x或者y或者z中的任意一个 [^xyz] 除了x\y\z以外的任意字符 [a-z] 获取a-z中的任意一个字符([0-9] 等价于\d …) [^a-z] 除了a-z的任意字符 () 正则分组 (?:) 当前分组只匹配不捕获 (?=) 正向预查 (?!) 负向预查 量词元字符 让其左边的元字符出现多少次] 出现零到多次 ? 出现零到一次 出现一到多次 {n} 出现N次 {n,} 出现N到多次 {n,m} 出现N到M次 普通元字符 只要在正则中出现的元字符（在基于字面方式创建），除了特殊和有量词意义的以外，其余的都是普通元字符 中括号的一些细节 [xyz]&nbsp;&nbsp;&nbsp;[^xyz]&nbsp;&nbsp; [a-z]&nbsp;&nbsp; [^a-z] 1.中括号中出现的元字符一般都是代表本身含义的 2.中括号中出现的两位数，不是两位数，而是两个数字中的任意一个123456789101112let reg = /^.+$/;//=&gt;一个正则设置了^和$，那么代表的含义其实就是只能是xxxconsole.log(reg.test('n'));//=&gt;trueconsole.log(reg.test('1'));//=&gt;trueconsole.log(reg.test('nn'));//=&gt;trueconsole.log(reg.test('\n'));//=&gt;falselet reg = /^[.]+$/;console.log(reg.test('n'));//=&gt;falseconsole.log(reg.test('1'));//=&gt;falseconsole.log(reg.test('nn'));//=&gt;falseconsole.log(reg.test('\n'));//=&gt;falseconsole.log(reg.test('...'));//=&gt;true 分组的作用 1.改变的默认的优先级 2.分组捕获 3.分组引用1234567891011121314151617181920212223242526272829303132 let reg = /^18|19$/; console.log(reg.test('18'));//=&gt;true console.log(reg.test('19'));//=&gt;true console.log(reg.test('1819'));//=&gt;true console.log(reg.test('189'));//=&gt;true console.log(reg.test('181'));//=&gt;true console.log(reg.test('819'));//=&gt;true console.log(reg.test('119'));//=&gt;true-----------------------------------------// 改变的默认的优先级 reg = /^(18|19)$/; console.log(reg.test('18'));//=&gt;true console.log(reg.test('19'));//=&gt;true console.log(reg.test('1819'));//=&gt;false console.log(reg.test('189'));//=&gt;false console.log(reg.test('181'));//=&gt;false console.log(reg.test('819'));//=&gt;false console.log(reg.test('119'));//=&gt;false----------------------------------------- let reg = /^([a-z])([a-z])\2\1$/;//=&gt;正则中出现的\1代表和第一个分组出现一模一样的内容... console.log(reg.test('oppo')); console.log(reg.test('poop'));------------------------------------------------//=&gt;编写一个正则匹配身份证号码// let reg = /^\d&#123;17&#125;(\d|X)$/;//=&gt;简单：只能匹配是否符合格式，不能提取出身份证中的一些信息// '130828199012040617'//=&gt;130828 地域//=&gt;19901204 出生年月//=&gt;0617 倒数第二位：奇数=男 偶数=女let reg = /^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(?:\d|X)$/;console.log(reg.exec('130828199012040617'));//=&gt;EXEC实现的是正则捕获，获取的结果是一个数组，如果不匹配获取的结果是null，捕获的时候不仅把大正则匹配的信息捕获到，而且每一个小分组中的内容也捕获到了(分组捕获) : ["130828199012040617", "130828", "1990", "12", "04", "1", index: 0, input: "130828199012040617"] 正则捕获使用的是正则中的EXEC方法 1.如果可以匹配获取的结果是一个数组，如果不能匹配获取的结果是NULL 2.如果我们只在匹配的时候，想要获取大正则中部分信息，我们可以把这部分使用小括号包起来，形成一个分组，这样在捕获的时候，不仅可以把大正匹配的信息捕获到，而且还单独的把小分组匹配的部分信息也捕获到了(分组捕获) 3.有时候写小分组不是为了捕获信息，只是为了改变优先级或者进行分组引用，此时我们可以在分组的前面加上“?:”，代表只去匹配，但是不把这个分组内容捕获 常用正则表达式 有效数字 1234567/*分析规则：* 1.可以出现+/-号：可以没有，也可以有一个* 2.整数 0 12 9 : 一位或者多位数字，一位0~9，多位数字不能以0开头* 3.小数部分：可能有可能没有，有小数点后面至少要跟一位数字/^[-+]?(\d|([1-9]\d+))(\.\d+)?$/*/let reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/; 电话(手机)号码1234/* 1. 11位数字 * 2. 以1开头 */ let reg = /^1\d&#123;10&#125;$/ 中文姓名1234/* 1. 中文汉字 [\u4E00-\u9FA5] * 2. 尼古拉斯·赵四 */let reg = /^[\u4E00-\u9FA5]&#123;2,&#125;(·[\u4E00-\u9FA5]&#123;2，&#125;)?$/ 邮箱1234567 /* xxxx@xxx.xx.xx * * 第一部分：数字、字母、下划线、-、.，但是-和.不能作为开头，不能连续出现-或者. * * 第二部分：xxx.xx.xx xxx.xx xxx.xx.xx.xx xxx-xxx-xx.xx.xx///=&gt;/^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理五]]></title>
    <url>%2F2019%2F03%2F04%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E4%BA%94%2F</url>
    <content type="text"><![CDATA[js严格模式 1.在严格模式下不支持使用 “arguments.callee / arguments.callee.caller” （Uncaught TypeError: ‘caller’, ‘callee’, and ‘arguments’ properties may not be accessed on strict mode functions or the arguments objects for calls to them）2.在严格模式下ARGUMENTS和形参没有映射机制3.在严格模式下不允许给一个对象设置重复属性名的：“obj={n:10,n:20}”4.在严格模式下，函数执行，如果没有明确指定执行的主体（函数前面没有点），不再像非严格模式下一样，统一都交给window，而是让this指向undefined，代表没有执行主体：“严格模式下，有执行主体this就指向谁，没有执行主体，this就是undefined”1234567891011121314151617181920212223242526272829303132333435363738~function () &#123; /*function fn(x) &#123; arguments[0]=100; console.log(x);//=&gt;100 存在映射机制 &#125; fn(10);*/ /*var obj=&#123; n:10, n:20 &#125;; console.log(obj.n);*/ function fn() &#123; console.log(this);//=&gt;window &#125; fn();&#125;();~function () &#123; "use strict"; /*function fn(x) &#123; arguments[0]=100; console.log(x);//=&gt;10 不存在映射机制 &#125; fn(10);*/ /*var obj=&#123; n:10, n:20 &#125;; console.log(obj.n);*/ function fn() &#123; console.log(this);//=&gt;undefined &#125; fn();&#125;(); 原型设计模式 在实际项目基于面向对象开发的时候(构造原型设计模式),我们根据需要,很多时候会重定向类的原型(让类的原型指向自己开辟的堆内存 自己开辟的堆内存中没有constructor属性,导致类的原型构造函数缺失（解决：自己手动在堆内存中增加constructor属性） 当原型重定向后，浏览器默认开辟的那个原型堆内存会被释放掉，如果之前已经存储了一些方法或者属性，这些东西都会丢失（所以：内置类的原型不允许重定向到自己开辟的堆内存，因为内置类原型上自带很多属性方法，重定向后都没了，这样是不被允许的） less 它是CSS预编译语言，和它类似的还有sass/stylus… css是标记语言，不是编程语言，没有类、实例、函数、变量等东西；而less等预编译语言就是让css具备面向对象编程的思想；但是浏览器不能直接识别和渲染less代码，需要我们把less代码预先编译为正常的css后，再交给浏览器渲染解析； less的编译 在开发环境下编译(产品没有开发完，正在开发中，这个是开发环境) 导入less.js即可 12345//=&gt;rel=&quot;stylesheet/less&quot; 这块有修改&lt;link rel=&quot;stylesheet/less&quot; href=&quot;css/demo1.less&quot;&gt;//=&gt;导入JS文件即可&lt;script src=&quot;js/less-2.5.3.min.js&quot;&gt;&lt;/script&gt; 在生产环境下编译(产品开发完成了，需要部署到服务器上) 项目上线，不能把less部署，这样用户每一次打开页面都需要重新的编译，非常耗性能，我们部署到服务器上的是编译后的css 1234567891.在当前电脑的全局环境下安装less模块 $ npm install less -g 验证是否安装成功：$ lessc -v2.基于命令把我们的less编译成css $ lessc xxx/xxx.less xxx/xxx.min.css -x 把指定目录中的less编译成为css(并且实现了代码的压缩)，把编译后的css存入到具体指定路径中的文件中；上线前在HTML中导入的是css文件； 目前基于webpack和框架实现工程化开发的时候，我们都是在webpack配置文件中，配置出less的编译（需要安装less/less-loader等模块），这样不管是开发环境下的预览，还是部署到生产环境下，都是基于webpack中的less模块编译的 less语法：[http://lesscss.cn/] call、aplly、bindcall &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[fn].call([this],[param]…) fn.call：当前实例(函数FN)通过原型链的查找机制，找到Function.prototype上的call方法 =&gt;function call(){[native code]} ,当call方法执行的时候，内部处理了一些事情 1、首先把要操作函数中的THIS关键字变为CALL方法第一个传递的实参值 2、把CALL方法第二个及第二个以后的实参获取到 3、把要操作的函数执行，并且把第二个以后的传递进来的实参传给函数 1234567891011121314// call 原理Function.prototype.es3Call = function (context) &#123; var content = context || window; content.fn = this; var args = []; // arguments是类数组对象，遍历之前需要保存长度，过滤出第一个传参 for (var i = 1, len = arguments.length ; i &lt; len; i++) &#123; // 避免object之类传入 args.push('arguments[' + i + ']'); &#125; var result = eval('content.fn('+args+')'); delete content.fn; return result; &#125; call细节 非严格模式下，如果参数不传，或者第一个传递的是null/undefined，THIS都指向WINDOW 在严格模式下，第一个参数是谁，THIS就指向谁（包括null/undefined），不传THIS是undefined 12345fn.call(obj, 10, 20);//=&gt;this:obj a=10 b=20fn.call(10, 20);//=&gt;this:10 a=20 b=undefinedfn.call();//=&gt;this:window a=undefined b=undefinedfn.call(null);//=&gt;this:windowfn.call(undefined);//=&gt;this:window apply 和call基本上一模一样，唯一区别在于传参方式 fn.call(obj,10,20) fn.apply(obj,[10,20]) APPLY把需要传递给FN的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给FN一个个的传递 bind： 语法和call一模一样，唯一的区别在于立即执行还是等待执行 fn.call(obj,10,20) 改变FN中的THIS,并且把FN立即执行 fn.bind(obj,10,20) 改变FN中的THIS,此时的FN并没有执行（不兼容IE6~8） 解构赋值 对象解构赋值 12345678910111213141516171819202122232425 let obj = &#123;name: 'xxx', age: 25, sex: 0&#125;; let &#123;name, age&#125; = obj;//=&gt;对象解构赋值默认情况下要求：左侧变量名和对象中的属性名一致才可以 console.log(name, age); let &#123;sex&#125; = obj; console.log(sex);//=&gt;0 let &#123;age: ageAA&#125; = obj; console.log(age);//=&gt;Uncaught ReferenceError: age is not defined console.log(ageAA);//=&gt;25 给解构的属性名起别名作为我们使用的变量 let &#123;friend = 0&#125; = obj; console.log(friend);//=&gt;0 给不存在的属性设置默认值 let fn = function (&#123; name = '珠峰', age = 0 &#125; = &#123;&#125;) &#123;//=&gt;把传递的对象解构了(不传递值,默认赋值为空对象：现在传递对象或者不传递，形参接收到的都是对象)，解构的时候，可以把传递进来对象中，如果某个属性不存在，我们赋值默认值 console.log(name, age);&#125;;fn(&#123; name: 'xxx', age: 25&#125;); 数组解构赋值123456789101112131415161718192021222324252627282930313233343536373839 let a = 12, b = 13;//=&gt;a&amp;b互换位置 [a, b] = [b, a];//=&gt;[13,12] console.log(a, b);/*let c=a;a=b;b=c;console.log(a, b);*//*a=a+b;b=a-b;a=a-b;console.log(a, b);*/ let ary = [12]; let [a, b = 0] = ary;//=&gt;在解构的时候可以给变量设置默认值：如果当前变量对应结构中的这一项没有值，变量用默认值 console.log(a, b);//=&gt;12 0 let ary = [12, 23, 34, 45, 56];//=&gt;需求：获取第一项，把剩下的项作为一个数组返回 let [a, ...b] = ary; console.log(a, b);//=&gt;12 [23,34,45,56] “...”在此处称之为剩余运算符：除了前面以外的项，都放在一个数组中// let [a, ...b, c] = ary;//=&gt;Uncaught SyntaxError: Rest element must be last element 剩余运算符处于解构中最后的位置-------------------------------------let a=ary[0], b=ary[1], c=ary[2];let [a, b, c] = ary;//=&gt;让等号左边出现和右边相同的数据结构,左边可以创建一些变量快速获取到右侧对应位置的值(解构赋值)console.log(a, b, c);let [a] = ary;console.log(a);//=&gt;12let [a, , c] = ary;console.log(a, c);//=&gt;12 34 ‘…’运算符 “…”在ES6的语法中，三个点有三种含义 1.剩余运算符 2.拓展运算符 3.展开运算符：把数组(对象/类数组)中的每一项展开 xxx,xxx,xxx…123456789101112131415161718192021222324 let ary = [12, 23, 34]; let [...arg] = ary; //=&gt;ary.slice(0)function fn(context, ...arg) &#123; //=&gt;获取传递值中的第一个和剩下的 console.log(context, arg); //=&gt;ARG是一个数组 / ARGUMENTS是类数组&#125;function sum(...arg) &#123; //=&gt;传递几个实参,ARG中就存储多少个,此时的ARG和ARGUMENTS一样的,区别是ARG是一个数组,ARGUMENTS是一个类数组&#125;------------------------------------------------------- let ary = [12, 23, 34]; let fn = function (a, b, c) &#123; console.log(a, b, c); &#125;; // Math.max(...ary);//=&gt;Math.max(12,23,34) // fn(ary);//=&gt;a:ary b/c:undefined fn(...ary);//=&gt;fn(12, 23, 34) 把数组中的每一项分别传递给一个函数,此时我们使用展开运算符把数组展开即可 let obj = &#123;name: 'xxx', age: 20&#125;; let newObj = &#123;...obj, sex: 0&#125;;//=&gt;&#123;name: 'xxx', age: 20,sex:0&#125; 把原有对象展开(克隆)放到新对象中// let ary = [12, 23];// let newAry = [...ary, 100];//=&gt;[12, 23, 100] DOM的映射机制 页面中的HTML元素，和JS中通过相关方法获取到的元素集合或者元素对象存在映射关系(一个改另外一个会跟着自动修改)* xxx.style.color=’red’ : 把xxx元素对象对应堆内存中的style属性下的color属性值修改为’red’（本质操作的是JS堆内存） ；但是由于DOM映射关系，页面中的标签和XXX元素对象是绑在一起的，我们修改元素对象空间的值，页面中的元素会按照最新的值进行渲染；* 在元素绑定前，我们获取容器中元素，得到一个空的元素集合，元素数据绑定后，我们不需要重新获取，DOM的映射机制会帮我们把新增加的元素映射到之前获取的空集合中，让其变为有元素的集合（querySelectorAll获取的集合是静态集合(staticNodeList)，不存在上述所谓的映射机制，所以基于这种办法，数据绑定完成后需要重新的获取一次才可以）* appendChild在追加元素对象的时候，如果这个元素之前容器中已经存在，此时不是克隆一份新的追加到末尾，而是把原有的元素移动到末尾位置]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理四]]></title>
    <url>%2F2019%2F03%2F03%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[变量提升 当栈内存(作用域)形成，JS代码自上而下执行之前，浏览器首先会把所有带 “VAR”/“FUNCTION” 关键词的进行提前 “声明” 或者 “定义” ，这种预先处理机制称之为 “变量提升” 声明(declare)：var a （默认值undefined）定义(defined)：a=12 （定义其实就是赋值操作） 变量提升阶段 带“VAR”的只声明未定义 带“FUNCTION”的声明和赋值都完成了 变量提升只发生在当前作用域（例如：开始加载页面的时候只对全局作用域下的进行提升，因为此时函数中存储的都是字符串而已） 在全局作用域下声明的函数或者变量是“全局变量”，同理，在私有作用域下声明的变量是“私有变量” [带VAR/FUNCTION的才是声明] 12console.log(a);//=&gt;undefinedvar a = 12; 变量带var声明和直接声明 在全局作用域下声明一个变量，也相当于给WINDOW全局对象设置了一个属性，变量的值就是属性值（私有作用域中声明的私有变量和WINDOW没啥关系）12345678910111213141516console.log(a);//=&gt;undefinedconsole.log(window.a);//=&gt;undefinedconsole.log('a' in window); //=&gt;TRUE 在变量提升阶段，在全局作用域中声明了一个变量A，此时就已经把A当做属性赋值给WINDOW了，只不过此时还没有给A赋值，默认值UNDEFINED in：检测某个属性是否隶属于这个对象var a = 12;//=&gt;全局变量值修改，WIN的属性值也跟着修改console.log(a);//=&gt;全局变量A 12console.log(window.a);//=&gt;WINDOW的一个属性名A 12a = 13;console.log(window.a);//=&gt;13window.a = 14;console.log(a);//=&gt;14//=&gt;全局变量和WIN中的属性存在 “映射机制”//=&gt;不加VAR的本质是WIN的属性*/ 12345678910111213console.log(a, b);//=&gt;undefined undefinedvar a = 12, b = 12;function fn() &#123; console.log(a, b);//=&gt;undefined 12 var a = b = 13; /*var a=13; b=13;*/ console.log(a, b);//=&gt;13 13&#125;fn();console.log(a, b);//=&gt;12 13 在当前作用域下，不管条件是否成立都要进行变量提升 =&gt;带VAR的还是只声明 =&gt;带FUNCTION的在老版本浏览器渲染机制下，声明和定义都处理，但是为了迎合ES6中的块级作用域，新版浏览器对于函数（在条件判断中的函数），不管条件是否成立，都只是先声明，没有定义，类似于VAR 重名问题 带VAR和FUNCTION关键字声明相同的名字，这种也算是重名了（其实是一个FN，只是存储值的类型不一样 2.关于重名的处理：如果名字重复了，不会重新的声明，但是会重新的定义（重新赋值）[不管是变量提升还是代码执行阶段皆是如此] 1234567891011 fn();//=&gt;4function fn() &#123;console.log(1);&#125;fn();//=&gt;4function fn() &#123;console.log(2);&#125;fn();//=&gt;4var fn=100;//=&gt;带VAR的在提升阶段只把声明处理了,赋值操作没有处理,所以在代码执行的时候需要完成赋值 FN=100fn();//=&gt;100() Uncaught TypeError: fn is not a functionfunction fn() &#123;console.log(3);&#125;fn();function fn() &#123;console.log(4);&#125;fn(); let/const &nbsp; &nbsp;在ES6中基于LET/CONST等方式创建变量或者函数,不存在变量提升机制,这种方式声明的全局变量也不再与windo存在映射关系。&nbsp; &nbsp;在相同的作用域中，基于LET不能声明相同名字的变量（不管用什么方式在当前作用域下声明了变量，再次使用LET创建都会报错）&nbsp; &nbsp;虽然没有变量提升机制，但是在当前作用域代码自上而下执行之前，浏览器会做一个重复性检测（语法检测）：自上而下查找当前作用域下所有变量，一旦发现有重复的，直接抛出异常，代码也不会在执行了（虽然没有把变量提前声明定义，但是浏览器已经记住了，当前作用域下有哪些变量） 1234567891011121314 let a = 10, b = 10;let fn = function () &#123; console.log(a, b);//=&gt;Uncaught ReferenceError: a is not defined // =&gt;基于LET创建变量，会把大部分&#123;&#125;当做一个私有的块级作用域（类似于函数的私有作用域），在这里也是重新检测语法规范，看一下是否是基于新语法创建的变量，如果是按照新语法规范来解析 let a = b = 20; /* * let a=20; * b=20; //=&gt;把全局中的 b=20 */ console.log(a, b);&#125;;fn();console.log(a, b); 全局和私有变量 1234567891011121314151617181920212223242526272829303132333435 /* * 变量提升： * var a; var b; var c; * fn = xxx... */var a = 12, b = 13, c = 14;function fn(a) &#123; /* * 形参赋值 * a = 12 * * 变量提升 * var b; * * =&gt;在私有作用域中，只有以下两种情况是私有变量 * A:声明过的变量(带VAR/FUNCTION) * B:形参也是私有变量 * * 剩下的都不是自己私有的变量，都需要基于作用域链的机制向上查找 */ console.log(a, b, c);//=&gt;12 undefined 14(C是全局的) var b = c = a = 20; /* var b=20; c=20; =&gt;把全局的C修改为20 a=20; */ console.log(a, b, c);//=&gt;20*3&#125;fn(a);//=&gt;把FN执行(小括号中是实参:值) =&gt;执行FN把全局变量A的值12当做实参传递给函数的形参 =&gt;fn(12)console.log(a, b, c);//=&gt;12 13 20 123456789101112 var ary = [12, 23];function fn(ary) &#123; console.log(ary); // [12,23] ary[0] = 100; ary = [100]; ary[0] = 0; console.log(ary); // [0]&#125;fn(ary);console.log(ary); //[100,23] 上级作用域 &nbsp; &nbsp;&nbsp; &nbsp;当前函数执行，形成一个私有作用域A，A的上级作用域是谁，和他在哪执行的没有关系，和他在哪创建（定义）的有关系，在哪创建的，它的上级作用域就是谁 1234567891011121314151617181920// function fn() &#123;// //=&gt;arguments:实参集合// //=&gt;arguments.callee:函数本身FN// //=&gt;arguments.callee.caller:当前函数在哪执行的,CALLER就是谁(记录的是它执行的宿主环境),在全局下执行CALLER的结果是NULL// console.log(arguments.callee.caller);// &#125;var n = 10;function fn() &#123; var n = 20; function f() &#123; n++; console.log(n); &#125; f(); return f;&#125;var x = fn(); //21x(); // 22x(); // 23console.log(n); // 10 JS中的内存分为堆内存和栈内存 堆内存：存储引用数据类型值（对象：键值对 函数：代码字符串） 栈内存：提供JS代码执行的环境和存储基本类型值 堆内存释放: 让所有引用堆内存空间地址的变量赋值为null即可（没有变量占用这个堆内存了，浏览器会在空闲的时候把它释放掉） 一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉（在栈内存中存储的值也都会释放掉），但是也有特殊不销毁的情况：1、函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放，即闭包 2、全局栈内存只有在页面关闭的时候才会被释放掉12345678910111213var i = 2;function fn() &#123; i += 2; // i 为全局变量会有影响,值得注意 return function (n) &#123; console.log(n + (--i)); &#125;&#125;var f=fn();// i=4 f(2);//5 i=3f(3);//5 i= 2fn()(2);//5 i=3fn()(3);// 7 i=4f(4);//7 i=3 闭包 函数执形成一个私有的作用域，保护里面的私有变量不受外界的干扰，这种保护机制称之为“闭包”一般大家认为，形成一个不销毁的私有作用域（私有栈内存）才是闭包12345678910111213141516//=&gt;闭包：柯理化函数function fn() &#123; return function () &#123; &#125;&#125;var f = fn();*//*//=&gt;闭包：惰性函数var utils = (function () &#123; return &#123; &#125;&#125;)(); 闭包项目实战应用 真实项目中为了保证JS的性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的） 闭包具有“保护”作用：保护私有变量不受外界的干扰。 闭包具有“保存”作用：形成不销毁的栈内存，把一些值保存下来，方便后面的调取使用 基于构造函数创建自定义类 在普通函数执行的基础上“new xxx()”，这样就不是普通函数执行了，而是构造函数执行，当前的函数名称之为“类名”，接收的返回结果是当前类的一个实例 自己创建的类名，最好第一个单词首字母大写 这种构造函数设计模式执行，主要用于组件、类库、插件、框架等的封装，平时编写业务逻辑一般不这样处理12345678910111213141516171819202122232425 function Fn() &#123;&#125;// Fn();//=&gt;普通函数执行var f = new Fn();//=&gt;Fn是类 f是类的一个实例var f2 = new Fn();//=&gt;f2也是Fn的一个实例，f2和f是独立分开的，互不影响/* * JS中创建值有两种方式 * 1.字面量表达式 * 2.构造函数模式 */// var obj = &#123;&#125;;//=&gt;字面量方式// var obj = new Object();//=&gt;构造函数模式// //=&gt;不管是哪一种方式创造出来的都是Object类的实例，而实例之间是独立分开的，所以 var xxx=&#123;&#125; 这种模式就是JS中的单例模式//=&gt;基本数据类型基于两种不同的模式创建出来的值是不一样的//&gt; 基于字面量方式创建出来的值是基本类型值//&gt; 基于构造函数创建出来的值是引用类型//-&gt;NUM2是数字类的实例，NUM1也是数字类的实例，它只是JS表达数字的方式之一，都可以使用数字类提供的属性和方法// var num1 = 12;// var num2 = new Number(12);// console.log(typeof num1);//=&gt;"number"// console.log(typeof num2);//=&gt;"object"]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基础]]></title>
    <url>%2F2019%2F03%2F01%2Fgit%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[git基础管理基础命令配置 git config user-name 局部设置 git config –global user.name ‘XXX’ 全部设置 git config –global user.emial ‘xxx’ 初始化仓库 git init =&gt; .git 文件夹存取的是git仓库的版本信息 工作区到暂存区 git add ‘XXX’ =&gt; 把指定的文件提交到暂存区 git add . =&gt; 提交修改和新增的文件，但不包含删除的 git add -u =&gt; 提交修改和删除的文件，但不包含新增的 git add -A =&gt; 同时具备 . 和 -u 特征 git status =&gt; 查看文件状态 .gitignore =&gt; 忽略提交的文件 暂存区到历史区 git commit =&gt; 提交到历史区 git commit -m ‘XXXX’ =&gt; 提交到历史区 git log =&gt; 查看提交记录，版本信息 git relog =&gt; 查看所有历史记录（包括历史区回滚后） 查看每个阶段代码的区别 git diff =&gt; 工作区 VS 暂存区 git diff master =&gt; 工作区 VS 历史区的master分支 git diff –cached =&gt; 暂存区 VS 历史区 git和gitHub同步12345678910111213git remote -v 查看所有的关联信息git remote add [xxx] [远程仓库git地址]git clone [远程仓库地址] [克隆后的名字：可以不设置，默认是仓库名] 建立关联git remote remove xxx[远程仓库git地址]1、远程仓库关联在一起的名字默认是：origin 可以自行修改2、把本地的信息推送到远程仓库上，或者从远程仓库上拉取最新的信息到本地仓库，我们本地推送和拉取的信息，既有代码也有版本信息，所以说与其说是推送和拉取，不如说是和远程仓库保持信息的同步在推送之前，我们都应该先拉取 $ git pull origin（这个名字就是和远程仓库关联的这个名字，以自己设置的为主） master $ git push origin master 把自己本地信息推送到远程仓库的master分支下]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理三]]></title>
    <url>%2F2019%2F02%2F28%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E4%B8%89%2F</url>
    <content type="text"><![CDATA[数组常用方法 方法的作用 方法的参数 方法的返回值 原有数组是否改变 push12345678// 作用：向数组“末尾”追加新的内容// 参数：追加的内容（可以是一个，也可是多个）// 返回值：新增后数组的长度// 原有数组改变var ary = [12,23,34];ary.push(100); //=&gt;4 ary:[12,23,24,1000]ary.push(100,&#123;name:'xxx'&#125;); //=&gt;6ary:[12,23,34,100,100,&#123;...&#125;] pop123456// 作用：删除数组最后一项// 参数：无// 返回：被删除的那一项内容// 原有数组改变var ary = [12,23,34];ary.pop() =&gt; //34 shift123456// 作用：删除数组中的第一项// 参数：无// 返回：被删除的那一项内容// 原有数组改变var ary = [12,23,34];ary.shfit(); =&gt; 12 unshfit1234567// 作用：向数组开始位置追加新内容// 参数：要新增的内容// 返回：新增后数组的长度// 原有数组改变var ary = [12,23,34];ary.unshfit(100,true) //=&gt;5// ary =&gt; [100,true,12,23,34] splice12345678910111213141516171819202122基于 SPLICE可以对数组进行很多的操作：删除指定位置的内容、向数组指定位置增加内容、还可以修改指定位置的信息`删除：ary.splice(n,m)`// 从索引n开始，删除m个内容，把删除的部分以一个新数组返回，原有数组改变`新增：ary.splice(n,0,x,...)`// 从索引n开始删除零项（没删除），把X或者更多需要插入的内容存放到数组中索引N的“前面”`修改：ary.splice(n,m,x,...)`// 修改的原理就是把原有内容删除掉，然后用新的内容替换这部分信息即可// 1. 删除数组最后一项ary.pop()ary.splice(ary.length-1)ary.length--// 2. 向数组末尾追加新内容ary.push(100)ary.splice(ary.length,0,100)ary[ary.length]=100 slice123456789// 作用：在一个数组中，按照条件查找出其中的部分内容// 参数：两个参数（n/m），从索引n开始，找到索引m处，但是不包含m// 返回：以一个新数组存储查找的内容原有数组不会变ary.slice(2,5) // =&gt; 得到一个新数组ary.slice(2) // =&gt; 一个参数，就查找到数组末尾ary.slice(0)ary.slice()// 克隆数组ary.slice(-3,-1) // 支持负数索引 ，数组长度 + 负数索引 =&gt; ary.slice(arr.length + (-3),arr.length + (-1)) concat1234567// 作用：实现多个数组(或者值)的拼接// 参数：数组或者值// 返回：拼接后的新数组// 原有数组不变`toString`作用：把数组转换为字符串参数：无 join1234// 作用：和toString类似，也是把数组转换为字符串，但是我们可以设置变为字符串后，每一项之间的连接符// 参数：指定的链接符// 返回：字符串// 原有数组不变 reverse1234567// 作用：把数组倒过来排列// 参数：无// 返回：排列后的新数组// 原有数组改变var ary = [12,23,24,45]ary.reverse()//ary =&gt; [45,24,23,12] sort1234567891011121314// 作用：给数组排序// 参数：无/函数// 返回：排序后的新数组// 原有数组改变//=&gt;sort在不传递参数的情况下，只能处理10以内数字排序var ary=[1,3,2,4,5,6,7,9,8];ary.sort(); =&gt;[1,2,3,4,5,6,7,8,9]var ary=[18,1,23,27,2,35,3,56];ary.sort(); =&gt;[1, 18, 2, 23, 27,3, 35, 56] 没有按照我们想象中的排序//=&gt;真实项目中，基于sort排序，我们都需要传递参数ary.sort(function (a,b)&#123;return a-b;//=&gt;升序 return ba; 降序&#125;); indexOf / lastIndexOf123456789这两个方法不兼容IE低版本浏览器(IE6~8)// 作用：检测当前值在数组中第一次或者最后一次出现位置的索引// 参数：要检测的值// 返回：索引// 原有数组不变//=&gt;验证数组中是否包含某一项if(ary.indexOf(100)&gt;-1)&#123;//=&gt;ARY中包含100这一项&#125; es5/es6 every filter find forEach includes keys map reduce / reduceRight some JS中关于字符串的一些细节知识1234567891011// 在JS中所有用单引号或者双引号包起来的都是字符串，每一个字符串是由零到多个字符组成var str = 'zhufeng';str.length -&gt;字符串长度str[0] -&gt;'z'str[str.length-1] -&gt;'n'str[100] -&gt;undefined//=&gt;字符串中的每一个字符都有一个自己对应位置的索引，也有类似于数组一样的length代表自己的长度//=&gt;循环遍历字符串，输出每一项字符for(var i=0;i&lt;str.length;i++)&#123;cosole.log(str[i]);&#125; 关于字符串中常用的方 字符串是基本数据类型，字符串的每一次操作都是值直接的进行操作，不像数组一样是基于空间地址来操作的，所以不存在原有字符串是否改变这一说，肯定都是不变的 charAt/charCodeAt 作用：charAt根据索引获取指定位置的字符，charCodeAt不仅仅获取字符，它获取的是字符对应的Unicode编码值(ASC II码值)。 参数:索引 返回字符/ 对应的编码1234var str = 'hello world'str[0]str.charAt(0)str.charCodeAt(0) indexOf/lastIndexOf 基于这两个方法，可以获取字符在字符串中第一次或者最后一次出现位置的索引，有这个字符，返回大于等于零的索引，不包含这个字符，返回的结果是­1，所以可以基于这两个方法，验证当前字符串中是否包含某个字符 1234var str='zhufeng';if(str.indexOf('@')&gt;-1)&#123;//=&gt;条件成立说明包含@符号&#125; slice 作用：str.slice(n,m) 从索引n开始找到索引为m处(不包含m)，把找到的字符当做新字符串返回,和数组的slice方法用法相同 subString 和slice语法一模一样，唯一的区别在于：slice支持负数索引，而substring不支持负数索引substr也是字符串截取的方法，用法是：str.substr(n,m)，从索引n开始截取m个字符123// 支持第一个参数 为负数var str = 'hello world';str.substr(-3,3) // =&gt; 'rld' toUpperCase/toLowerCase 实现字母的大小写转换，toUpperCase小写转大写，toLowerCase大写转小写 split 和数组中的join相对应，数组中的join是把数组们一项按照指定的连接符变为字符串，而split是把字符串按照指定的分隔符，拆分成数组中每一项 replace 作用：替换字符串中的原有字符 参数：原有字符，要替换的新字符 返回：替换后的字符串 扩展 includes localeCompare search trim 时间字符串格式化 有一个时间字符串 “2018-­4-­4 16:26:8”，我们想基于这个字符串获取到 “04月04日 16时26分”1234567891011121314~function(pro)&#123; pro.formatTime = function(template)&#123; template = template || `&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒`; var ary = this.match(/\d+/g); // 获取要格式化时间字符的数字 得到一个数组 template = template.replace(/\&#123;(\d+)\&#125;/g,function()&#123; // 替换模板 var n = arguments[1], val = ary[n] || '0'; val &lt; 10 ? val = '0' + val :null; return val; &#125;) return template; &#125;&#125;(String.prototype) URL地址问号传参解析 有一个URL地址“http://www.zhufengpeixun.cn/stu/?lx=1&amp;name=AA&amp;sex=man” 地址问号后面的内容是我们需要解析出来的参数信息{lx:1,name:’AA’,sex:’man’} 12345678910111213141516~function (pro) &#123;pro.queryURLParameter = function () &#123; var obj = &#123;&#125;, reg = /([^?=&amp;#]+)(?:=([^?=&amp;#]+)?/g; this.replace(reg, function () &#123; var key = arguments[1], value = arguments[2] || null; obj[key] = value; &#125;); return obj; &#125;&#125;(String.prototype);var str = 'http://www.zhufengpeixun.cn/stu/?lx=1&amp;name=&amp;sex=#teacher';console.log(str.queryURLParameter());]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理二]]></title>
    <url>%2F2019%2F02%2F28%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[JS中数据类型转型汇总JS中的数据类型分为基本数据类型 数字 number 字符串 string 布尔 boolean 空 null 未定义 undefined 引用数据类型 对象 object 普通对象 数组对象 (Array) 正则对象 (RegExp) 日期对象 (Date) 数学函数 (Math)…-函数 function把其它数据类型转换为number类型1.发生的情况 isNaN检测的时候：当检测的值不是数字类型,浏览器会自己调用Number方法把它先转换为数字，然后再检测是否为非有效数字1234567isNaN('3') =&gt;false Number('3')-&gt;3 isNaN(3)-&gt;falseisNaN('3px') =&gt;true Number('3px')-&gt;NaN isNaN(NaN)-&gt;true 基于parseInt/parseFloat/Number手动转换为数字类型 数学运算： + - * / % ，但是“+”不仅仅是数学运算，还可能是字符串拼接 123456789101112'3'-1 =&gt;2 Number('3')-&gt;3 3-1-&gt;2'3px'-1 =&gt;NaN'3px'+1 =&gt;'3px1' 字符串拼接var i='3';i=i+1; =&gt;'31'i+=1; =&gt;'31'i++; =&gt;4 i++就是单纯的数学运算，已经摒弃掉字符串拼接的规则 在基于“==”比较的时候，有时候也会把其它值转换为数字类型 2.转换规律1234567891011121314151617181920//=&gt;转换的方法：Number（浏览器自行转换都是基于这个方法完成的）【把字符串转换为数字】只要遇到一个非有效数字字符，结果就是NaN'' -&gt;0' ' -&gt;0 空格(Space)'\n' -&gt;0 换行符(Enter)'\t' -&gt;0 制表符(Tab)【把布尔转换为数字】true -&gt;1false -&gt;0【把没有转换为数字】null -&gt;0undefined -&gt;NaN【把引用类型值转换为数字】首先都先转换为字符串（toString），然后再转换为数字（Number） 把其它类型值转换为字符串1.发生的情况 基于alert/confirm/prompt/document.write等方法输出内容的时候，会把输出的值转换为字符串，然后再输出 基于“+”进行字符串拼接的时候 把引用类型值转换为数字的时候，首先会转换为字符串，然后再转换为数字 给对象设置属性名，如果不是字符串，首先会转换为字符串，然后再当做属性存储到对象中（对象的属性只能是数字或者字符串） 手动调用toString/toFixed/join/String等方法的时候，也是为了转换为字符串 2.转换规律1234567891011121314//=&gt;调用的方法：toString【除了对象，都是我们理解的转换结果】1 -&gt;'1'NaN -&gt;'NaN'null -&gt;'null'[] -&gt;''[13] -&gt;'13'[12,23] -&gt;'12,23'...【对象】&#123;name:'xxx'&#125; -&gt;'[object Object]'&#123;&#125; -&gt;'[object Object]'不管是啥样的普通对象，最后结果都一样 把其它值转换为布尔类型1.发生的情况 基于！/!! /Boolean 等方法转换 条件判断中的条件最后都会转换为布尔值 2.转换的规律 只有“0/NaN/‘’/null/undefined”五个值转换为布尔的false,其余都是转换为true 特殊情况：数学运算和字符串拼接 “+”12345678910111213//=&gt;当表达式中出现字符串，就是字符串拼接，否则就是数学运算1+true =&gt;2 数学运算'1'+true =&gt;'1true' 字符串拼接[12]+10 =&gt;'1210' 虽然现在没看见字符串，但是引用类型转换为数字，首先会转换为字符串，所以变为了字符串拼接(&#123;&#125;)+10 =&gt;"[object Object]10"[]+10 =&gt;"10"&#123;&#125;+10 =&gt;10 这个和以上说的没有半毛钱关系，因为它根本就不是数学运算，也不是字符串拼接，它是两部分代码 &#123;&#125; 代表一个代码块（块级作用域） +10 才是我们的操作 严格写法：&#123;&#125;; +10; 特殊情况：“==”在进行比较的时候，如果左右两边的数据类型不一样，则先转换为相同的类型，再进行比较对象==对象：不一定相等，因为对象操作的是引用地址，地址不相同则不相等123456&#123;name:'xxx'&#125;==&#123;name:'xxx'&#125; =&gt;false[]==[] =&gt;falsevar obj1=&#123;&#125;;var obj2=obj1;obj1==obj2 =&gt;true ==========================&gt;上面是重点强调的 对象==数字：把对象转换为数字对象==布尔：把对象转换为数字，把布尔也转换为数字对象==字符串：把对象转换为数字，把字符串也转换为数字字符串==数字：字符串转换为数字字符串==布尔：都转换为数字布尔==数字：把布尔转换为数字===========================&gt;不同情况的比较，都是把其它值转换为数字，然后再进行比较的 null==undefined：truenull===undefined：falsenull&amp;&amp;undefined和其它值都不相等 NaN==NaN：falseNaN和谁都不相等包括自己===========================&gt;以上需要特殊记忆 123456789101==true =&gt;true1==false =&gt;false2==true =&gt;false 规律不要混淆，这里是把true变为数字1[]==true：false 都转换为数字 0==1![]==true：false[]==false：true 都转换为数字 0==0![]==false：true 先算![]，把数组转换为布尔取反=&gt;false =&gt;false==false 数组去重方法一1234567891011121314151617181920212223242526/* * 1.依次拿出数组中的每一项（排除最后一项：最后一项后面没有需要比较的内容） * 2.和当前拿出项后面的每一项依次比较 * 3.如果发现有重复的，我们把找到的这个重复项在原有数组中删除掉（splice） *///=&gt;i&lt;ary.length-1：不用拿最后一项var arr = [1,43,53,2,2,534,43,53];for(var i=0;i&lt;arr.length;i++)&#123; var curItem = arr[i]; for(var k=i+1;k&lt;arr.length;k++)&#123; if(item == arr[k])&#123; //=&gt;相等：重复了,我们拿出来的K这个比较项在原有数组中删除 // ary.splice(k, 1); /* * 这样做会导致数组塌陷问题：当我们把当前项删除后，后面每一项都要向前进一位，也就是原有数组的索引发生了改变，此时我们k继续累加1，下一次在拿出来的结果就会跳过一位 * 原数组 [1,2,3,4] * i=1 =&gt;2 我们把这一项干掉，然后i++，i=2 * 原数组 [1,3,4] * i=2这一项是4,3这一项就错过了 * ... */ ary.splice(k, 1);//=&gt;删除后不能让k累加了 k--;//=&gt;删除后先减减，在加加的时候相当于没加没减 &#125; &#125;&#125; 方法二1234567891011121314151617var ary = [1, 2, 3, 2, 2, 3, 4, 3, 4, 5];/**基于对象的属性名不能重复,我们实现高性能的数组去重 * 1.创建一个空对象 * 2.依次遍历数组中的每一项,把每一项存储的值，当做对象的属性名和属性值存储起来 * */ var obj = &#123;&#125;; for(var i =0;i&lt;arr.length;i++)&#123; var item = ary[i]; if(typeof item !='undefined')&#123; // 把数组最后一项的结果获取到，替换当前项内容,在删除最后一项 arr[i] = arr[arr.length - 1]; arr.length--; continue; &#125; // 如果没有 =&gt;把这一项作为对象的属性名和属性值存储进去 obj[item] = item; &#125;]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js知识梳理一]]></title>
    <url>%2F2019%2F02%2F28%2Fjs%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E4%B8%80%2F</url>
    <content type="text"><![CDATA[数据类型的详细剖析 number数字类型NaN：not a number 但是它是数字类型的isNaN：检测当前值是否不是有效数字，返回true代表不是有效数字，返回false是有效数字 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//=&gt;语法：isNaN([value])var num=12;isNaN(num); //-&gt;检测num变量存储的值是否为非有效数字 falseisNaN(&apos;13&apos;) =&gt;falseisNaN(&apos;珠峰&apos;) =&gt;trueisNaN(true) =&gt;falseisNaN(false) =&gt;falseisNaN(null) =&gt;falseisNaN(undefined) =&gt;trueisNaN(&#123;age:9&#125;) =&gt;trueisNaN([12,23]) =&gt;trueisNaN([12]) =&gt;falseisNaN(/^$/) =&gt;trueisNaN(function()&#123;&#125;) =&gt;true重要：isNaN检测的机制1、首先验证当前要检测的值是否为数字类型的，如果不是，浏览器会默认的把值转换为数字类型 把非数字类型的值转换为数字 - 其它基本类型转换为数字：直接使用Number这个方法转换的 [字符串转数字] Number(&apos;13&apos;) -&gt;13 Number(&apos;13px&apos;) -&gt;NaN 如果当前字符串中出现任意一个非有效数字字符，结果则为NaN Number(&apos;13.5&apos;) -&gt;13.5 可以识别小数 [布尔转数字] Number(true) -&gt;1 Number(false) -&gt;0 [其它] Number(null) -&gt;0 Number(undefined) -&gt;NaN - 把引用数据类型值转换为数字：先把引用值调取toString转换为字符串，然后再把字符串调取Number转换为数字 [对象] (&#123;&#125;).toString() -&gt;&apos;[object Object]&apos; -&gt;NaN [数组] [12,23].toString() -&gt;&apos;12,23&apos; -&gt;NaN [12].toString() -&gt;&apos;12&apos; -&gt;12 [正则] /^$/.toString() -&gt;&apos;/^$/&apos; -&gt;NaN Number(&apos;&apos;) -&gt;0 [].toString() -&gt;&apos;&apos; =&gt; isNaN([])：false2、当前检测的值已经是数字类型，是有效数字返回false，不是返回true（数字类型中只有NaN不是有效数字，其余都是有效数字） parseInt / parseFloat 等同于Number，也是为了把其它类型的值转换为数字类型 和Number的区别在于字符串转换分析上 Number：出现任意非有效数字字符，结果就是NaN parseInt：把一个字符串中的整数部分解析出来，parseFloat是把一个字符串中小数(浮点数)部分解析出来 1234parseInt(&apos;13.5px&apos;) =&gt;13parseFloat(&apos;13.5px&apos;) =&gt;13.5parseInt(&apos;width:13.5px&apos;) =&gt;NaN 从字符串最左边字符开始查找有效数字字符，并且转换为数字，但是一但遇到一个非有效数字字符，查找结束 NaN的比较1NaN==NaN：false NaN和谁都不相等，包括自己 布尔类型 只有两个值：true / false 如何把其它数据类型转换为布尔类型? Boolean ! !! 规律：在JS中只有“0/NaN/空字符串/null/undefined”这五个值转换为布尔类型的false，其余都转换为true null &amp;&amp; undefined 都代表空或者没有 null：空对象指针 undefined：未定义 null一般都是意料之中的没有（通俗理解：一般都是人为手动的先赋值为null，后面的程序中我们会再次给他赋值）123var num = null; //=&gt;null是手动赋值，预示着后面我会把num变量的值进行修改...num = 12; undefined代表的没有一般都不是人为手动控制的，大部分都是浏览器自主为空（后面可以赋值也可以不赋值）123var num; //=&gt;此时变量的值浏览器给分配的就是undefined...后面可以赋值也可以不赋值 object对象数据类型 普通对象 由大括号包裹起来的 由零到多组属性名和属性值（键值对）组成 属性是用来描述当前对象特征的，属性名是当前具备这个特征，属性值是对这个特征的描述（专业语法，属性名称为键[key]，属性值称为值[value]，一组属性名和属性值称为一组键值对） 12345678910111213141516171819//=&gt;对象的操作：对键值对的增删改查语法：对象.属性 / 对象[属性][获取]obj.name obj['name'] 一般来说，对象的属性名都是字符串格式的（属性值不固定，任何格式都可以）[增/改]JS对象中属性名是不允许重复的，是唯一的obj.name='zhangsan'; //=&gt;原有对象中存在NAME属性，此处属于修改属性值obj.sex='男'; //=&gt;原有对象中不存在SEX，此处相当于给当前对象新增加一个属性SEXobj['age']=28;[删]彻底删除：对象中不存在这个属性了delete obj['age'];假删除：并没有移除这个属性，只是让当前属性的值为空obj.sex=null; 在获取属性值的时候，如果当前对象有这个属性名，则可以正常获取到值（哪怕是null），但是如果没有这个属性名，则获取的结果是undefinedobj[‘friends’] =&gt;undefined1一个对象中的属性名不仅仅是字符串格式的，还有可能是数字格式的 var obj = { name:’珠峰培训’, 0:100};obj[0] =&gt;100obj[‘0’] =&gt;100obj.0 =&gt;Uncaught SyntaxError: Unexpected number 12345678910111213var obj = &#123; name:&apos;hello&apos;, 0:100&#125;;obj[0] =&gt;100obj[&apos;0&apos;] =&gt;100obj.0 =&gt;Uncaught SyntaxError: Unexpected number当我们存储的属性名不是字符串也不是数字的时候，浏览器会把这个值转换为字符串（toString），然后再进行存储obj[&#123;&#125;]=300; =&gt;先把(&#123;&#125;).toString()后的结果作为对象的属性名存储进来 obj[&apos;[object Object]&apos;]=300obj[&#123;&#125;] =&gt;获取的时候也是先把对象转换为字符串&apos;[object Object]&apos;,然后获取之前存储的300 12345678910数组对象（对象由键值对组成的）var oo = &#123; a:12&#125;;var ary = [12,23]; //=&gt;12和23都是属性值，属性名呢？通过观察结果，我们发现数组对象的属性名是数字（我们把数字属性名称为当前对象的索引）ary[0]ary[&apos;0&apos;]ary.0 =&gt;报错 关于条件可以怎么写？123456789101112131415// &gt;= / &lt;= / == 常规比较if(0)&#123; //=&gt;不管你在条件判断中写什么，最后总要把其计算出TRUE/FALSE来判断条件是否成立（把其它类型的值转换为布尔类型，只有 0/NaN/''/null/undefined 是false，其余都是true）&#125;if('3px'+3)&#123; //=&gt;在JS中，+ - * / % 都是数学运算，除 + 以外，其余运算符在运算的时候，如果遇到了非数字类型的值，首先会转换为数字类型（Number），然后再进行运算 //=&gt;+ 在JS中除了数学相加，还有字符串拼接的作用（如果运算中遇到了字符串，则为字符串拼接，而不是数学相加） '3px'+3 =&gt;'3px3'&#125;if('3px'-3)&#123; '3px'-3 =&gt;NaN&#125; typeof js中常用的检查数据的方式之一，还有以下几种： instanceof constructor Object.prototype.toString.call() 12345678910111213语法：typeof [value] =&gt;检测value的数据类型返回值：使用typeof检查数据出来的结果是字符串类型。"number"/"string"/"boolean"/"undefined"/"object"/"function"typeof null =&gt;"obejct" 因为null代表空对象指针（没有指向任何的内存空间）typeof检测数组/正则/对象，最后返回的都是"object"，也就是基于这种方式无法细分对象console.log(typeof []); //=&gt;"object"console.log(typeof typeof []); //=&gt;typeof "object"//=&gt;"string" switch case中每一种case情况的比较都是基于”===”绝对相等来完成的12345'10'==10 =&gt;true 相等比较,如果等号左右两边的类型不一样，首先会转换为一样的数据类型，然后再进行比较=&gt;当前案例中，就是把字符串'10'转换为数字了，然后再比较的'10'===10 绝对比较，如果两边的数据类型不一样，则直接不相等，它要求类型和值都完全一样才会相等（真实项目中为了保证代码的严谨性，我们应该更多使用绝对比较） 1234567891011121314151617181920ES3标准中：//=&gt;创建函数function 函数名([参数])&#123; 函数体：实现功能的JS代码&#125;//=&gt;函数执行函数名(); =====ES6标准中创建箭头函数：let 函数名(变量名)=([参数])=&gt;&#123; 函数体&#125;函数名();let fn=()=&gt;&#123; let total=10; ...&#125;;fn(); [创建函数] 函数也是引用类型，首先会开辟一个新的堆内存，把函数体中的代码当做“字符串”存储到内存中（对象向内存中存储的是键值对） 把开辟的堆内存地址赋值给函数名(变量名) 此时我们输出fn（切记不是fn()）代表当前函数本身如果我们执行fn()，这是把函数执行所以是否加小括号是两种不同本质的操作 [函数执行]目的：把之前存储到堆内存中的代码字符串变为真正的JS代码自上而下执行，从而实现应有的功能 1.函数执行，首先会形成一个私有的作用域（一个供代码执行的环境，也是一个栈内存）2.把之前在堆内存中存储的字符串复制一份过来，变为真正的JS代码，在新开辟的作用域中自上而下执行 函数中的参数 参数是函数的入口：当我们在函数中封装一个功能，发现一些原材料不确定，需要执行函数的时候用户传递进来才可以，此时我们就基于参数的机制，提供出入口即可12345678910111213//=&gt;此处的参数叫做形参：入口，形参是变量（n/m就是变量）function sum(n,m)&#123; //=&gt;n和m分别对应要求和的两个数字 var total = 0; total = n + m; console.log(total);&#125;//=&gt;此处函数执行传递的值是实参：实参是具体的数据值sum(10,20); //=&gt;n=10 m=20sum(10); //=&gt;n=10 m=undefinedsum(); //=&gt;n和m都是undefinedsum(10,20,30); //=&gt;n=10 m=20 30没有形参变量接收 【ECMAScript】 1.变量 可变的量称之为变量，在编程语言中，变量是一个虚拟的概念，变量是用来存储和代表具体值的，只不过它存储和代表的值是可以修改的 JS中定义变量的方式：不管变量存储的值是什么类型的，统一用以下关键词都可以创建 var 创建变量 function 创建一个函数 let (这个及以下是ES6语法中创建变量) 创建变量 const 创建常量 class 创建类 import ES6中的模块导入 123456var num = 12; //=&gt;创建了一个变量num,给他存储了一个值12num+10 //=&gt;把num存储的值12获取到，然后再加上10num = 100; //=&gt;所谓变量，就是一个名字存储和代表的值能发生改变const m = 100;m = 200; //=&gt;Uncaught TypeError: Assignment to constant variable. 基于const声明的名字，存储的值是不可以被修改的，我们把它叫做常量 ====【基本类型操作机制 =&gt;值类型】 值类型操作都是“按照值来操作的” 赋值的时候，也是直接的把这个值赋值给变量（或者说和变量关联） 一个变量把自己的值赋值给另外一个变量的时候，也是重新开辟一个新的位置，把原有变量存储的值放到新位置一份（新老位置各有相同的值，但是是独立分开的，没有关联），在把新位置上的值赋值给新变量 … ====【引用数据类型】 引用数据类型，操作的时候，都是按照“空间的引用地址来操作的” 首先不能像基本基本值一样在作用域中开辟位置存储，需要额外单独开辟一个新的空间（有一个16进制的地址，通过地址可以找到空间） 对于对象数据类型来说，它会把自己本身的键值对依次存储到这个空间中（对于函数来说，在空间中存储的是函数体中的代码字符串） 引用类型是按照引用地址来操作的，所以给变量赋的值是空间的地址，而不是对象本身，以后的操作都是通过地址找到空间然后再操作 ====【堆占内存】在JS中有两个重要的内存：堆内存/栈内存 栈内存 提供代码执行的环境 基本类型值都是直接的存储在栈内存中的 堆内存 引用类型值都存储在堆内存中 ===========================]]></content>
      <categories>
        <category>前端三剑客</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
</search>
